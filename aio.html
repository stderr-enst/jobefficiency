<!DOCTYPE html>
<!-- START: inst/pkgdown/templates/layout.html --><!-- Generated by pkgdown: do not edit by hand --><html lang="en" data-bs-theme="auto">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<title>Job Efficiency: All in One View</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<script src="assets/themetoggle.js"></script><link rel="stylesheet" type="text/css" href="assets/styles.css">
<script src="assets/scripts.js" type="text/javascript"></script><!-- mathjax --><script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      config: ["MMLorHTML.js"],
      jax: ["input/TeX","input/MathML","output/HTML-CSS","output/NativeMML", "output/PreviewHTML"],
      extensions: ["tex2jax.js","mml2jax.js","MathMenu.js","MathZoom.js", "fast-preview.js", "AssistiveMML.js", "a11y/accessibility-menu.js"],
      TeX: {
        extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"]
      },
      tex2jax: {
        inlineMath: [['\\(', '\\)']],
        displayMath: [ ['$$','$$'], ['\\[', '\\]'] ],
        processEscapes: true
      }
    });
    </script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><!-- Responsive Favicon for The Carpentries --><link rel="apple-touch-icon" sizes="180x180" href="favicons/incubator/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="favicons/incubator/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="favicons/incubator/favicon-16x16.png">
<link rel="manifest" href="favicons/incubator/site.webmanifest">
<link rel="mask-icon" href="favicons/incubator/safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="white">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="black">
</head>
<body>
    <header id="top" class="navbar navbar-expand-md top-nav incubator"><svg xmlns="http://www.w3.org/2000/svg" class="d-none"><symbol id="check2" viewbox="0 0 16 16"><path d="M13.854 3.646a.5.5 0 0 1 0 .708l-7 7a.5.5 0 0 1-.708 0l-3.5-3.5a.5.5 0 1 1 .708-.708L6.5 10.293l6.646-6.647a.5.5 0 0 1 .708 0z"></path></symbol><symbol id="circle-half" viewbox="0 0 16 16"><path d="M8 15A7 7 0 1 0 8 1v14zm0 1A8 8 0 1 1 8 0a8 8 0 0 1 0 16z"></path></symbol><symbol id="moon-stars-fill" viewbox="0 0 16 16"><path d="M6 .278a.768.768 0 0 1 .08.858 7.208 7.208 0 0 0-.878 3.46c0 4.021 3.278 7.277 7.318 7.277.527 0 1.04-.055 1.533-.16a.787.787 0 0 1 .81.316.733.733 0 0 1-.031.893A8.349 8.349 0 0 1 8.344 16C3.734 16 0 12.286 0 7.71 0 4.266 2.114 1.312 5.124.06A.752.752 0 0 1 6 .278z"></path><path d="M10.794 3.148a.217.217 0 0 1 .412 0l.387 1.162c.173.518.579.924 1.097 1.097l1.162.387a.217.217 0 0 1 0 .412l-1.162.387a1.734 1.734 0 0 0-1.097 1.097l-.387 1.162a.217.217 0 0 1-.412 0l-.387-1.162A1.734 1.734 0 0 0 9.31 6.593l-1.162-.387a.217.217 0 0 1 0-.412l1.162-.387a1.734 1.734 0 0 0 1.097-1.097l.387-1.162zM13.863.099a.145.145 0 0 1 .274 0l.258.774c.115.346.386.617.732.732l.774.258a.145.145 0 0 1 0 .274l-.774.258a1.156 1.156 0 0 0-.732.732l-.258.774a.145.145 0 0 1-.274 0l-.258-.774a1.156 1.156 0 0 0-.732-.732l-.774-.258a.145.145 0 0 1 0-.274l.774-.258c.346-.115.617-.386.732-.732L13.863.1z"></path></symbol><symbol id="sun-fill" viewbox="0 0 16 16"><path d="M8 12a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM8 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 0zm0 13a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 13zm8-5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2a.5.5 0 0 1 .5.5zM3 8a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2A.5.5 0 0 1 3 8zm10.657-5.657a.5.5 0 0 1 0 .707l-1.414 1.415a.5.5 0 1 1-.707-.708l1.414-1.414a.5.5 0 0 1 .707 0zm-9.193 9.193a.5.5 0 0 1 0 .707L3.05 13.657a.5.5 0 0 1-.707-.707l1.414-1.414a.5.5 0 0 1 .707 0zm9.193 2.121a.5.5 0 0 1-.707 0l-1.414-1.414a.5.5 0 0 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .707zM4.464 4.465a.5.5 0 0 1-.707 0L2.343 3.05a.5.5 0 1 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .708z"></path></symbol></svg><a class="visually-hidden-focusable skip-link" href="#main-content">Skip to main content</a>
  <div class="container-fluid top-nav-container">
    <div class="col-md-8">
      <div class="large-logo">
        <img id="incubator-logo" alt="HPC Carpentry lesson about assessing job efficiency by HPC.NRW" src="assets/images/incubator-logo.svg"><span class="badge text-bg-danger">
          <abbr title="This lesson is in the pre-alpha phase, which means that it is in early development, but has not yet been taught.">
            <a href="https://docs.carpentries.org/resources/curriculum/lesson-life-cycle.html" class="external-link alert-link">
              <i aria-hidden="true" class="icon" data-feather="alert-octagon" style="border-radius: 5px"></i>
              Pre-Alpha
            </a>
            <span class="visually-hidden">This lesson is in the pre-alpha phase, which means that it is in early development, but has not yet been taught.</span>
          </abbr>
        </span>

      </div>
    </div>
    <div class="selector-container">
      <div id="theme-selector">
        <li class="nav-item dropdown" id="theme-button-list">
          <button class="btn btn-link nav-link px-0 px-lg-2 dropdown-toggle d-flex align-items-center" id="bd-theme" type="button" aria-expanded="false" data-bs-toggle="dropdown" data-bs-display="static" aria-label="Toggle theme (auto)">
            <svg class="bi my-1 theme-icon-active"><use href="#circle-half"></use></svg><i data-feather="chevron-down"></i>
          </button>
          <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="bd-theme-text">
<li>
              <button type="button" class="btn dropdown-item d-flex align-items-center" data-bs-theme-value="light" aria-pressed="false">
                <svg class="bi me-2 theme-icon"><use href="#sun-fill"></use></svg>
                Light
                <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
            </li>
            <li>
              <button type="button" class="btn dropdown-item d-flex align-items-center" data-bs-theme-value="dark" aria-pressed="false">
                <svg class="bi me-2 theme-icon"><use href="#moon-stars-fill"></use></svg>
                Dark
                <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
            </li>
            <li>
              <button type="button" class="btn dropdown-item d-flex align-items-center active" data-bs-theme-value="auto" aria-pressed="true">
                <svg class="bi me-2 theme-icon"><use href="#circle-half"></use></svg>
                Auto
                <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
            </li>
          </ul>
</li>
      </div>

      <div class="dropdown" id="instructor-dropdown">
        <button class="btn btn-secondary dropdown-toggle bordered-button" type="button" id="dropdownMenu1" data-bs-toggle="dropdown" aria-expanded="false">
          <i aria-hidden="true" class="icon" data-feather="eye"></i> Learner View <i data-feather="chevron-down"></i>
        </button>
        <ul class="dropdown-menu" aria-labelledby="dropdownMenu1">
<li><button class="dropdown-item" type="button" onclick="window.location.href='instructor/aio.html';">Instructor View</button></li>
        </ul>
</div>
    </div>
  </div>
  <hr></header><nav class="navbar navbar-expand-xl bottom-nav incubator" aria-label="Main Navigation"><div class="container-fluid nav-container">
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle Navigation">
      <span class="navbar-toggler-icon"></span>
      <span class="menu-title">Menu</span>
    </button>
    <div class="nav-logo">
      <img class="small-logo" alt="HPC Carpentry lesson about assessing job efficiency by HPC.NRW" src="assets/images/incubator-logo-sm.svg">
</div>
    <div class="lesson-title-md">
      Job Efficiency
    </div>
    <div class="search-icon-sm">
      <!-- TODO: do not show until we have search
        <i role="img" aria-label="Search the All In One page" data-feather="search"></i>
      -->
    </div>
    <div class="desktop-nav">
      <ul class="navbar-nav me-auto mb-2 mb-lg-0">
<li class="nav-item">
          <span class="lesson-title">
            Job Efficiency
          </span>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="key-points.html">Key Points</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="reference.html#glossary">Glossary</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="profiles.html">Learner Profiles</a>
        </li>
        <li class="nav-item dropdown">
          <button class="nav-link dropdown-toggle" id="navbarDropdown" data-bs-toggle="dropdown" aria-expanded="false">
            More <i data-feather="chevron-down"></i>
          </button>
          <ul class="dropdown-menu" aria-labelledby="navbarDropdown">
<li><a class="dropdown-item" href="reference.html">Reference</a></li>
          </ul>
</li>
      </ul>
</div>
    <!--
    <form class="d-flex col-md-2 search-form">
      <fieldset disabled>
      <input class="form-control me-2 searchbox" type="search" placeholder="" aria-label="">
        <button class="btn btn-outline-success tablet-search-button"  type="submit">
          <i class="search-icon" data-feather="search" role="img" aria-label="Search the All In One page"></i>
        </button>
      </fieldset>
    </form>
    -->
    <a id="search-button" class="btn btn-primary" href="aio.html" role="button" aria-label="Search the All In One page">Search the All In One page</a>
  </div>
<!--/div.container-fluid -->
</nav><div class="col-md-12 mobile-title">
  Job Efficiency
</div>

<aside class="col-md-12 lesson-progress"><div style="width: %" class="percentage">
    %
  </div>
  <div class="progress incubator">
    <div class="progress-bar incubator" role="progressbar" style="width: %" aria-valuenow="" aria-label="Lesson Progress" aria-valuemin="0" aria-valuemax="100">
    </div>
  </div>
</aside><div class="container">
      <div class="row">
        <!-- START: inst/pkgdown/templates/navbar.html -->
<div id="sidebar-col" class="col-lg-4">
  <div id="sidebar" class="sidebar">
      <nav aria-labelledby="flush-headingEleven"><button role="button" aria-label="close menu" alt="close menu" aria-expanded="true" aria-controls="sidebar" class="collapse-toggle" data-collapse="Collapse " data-episodes="Episodes ">
          <i class="search-icon" data-feather="x" role="img"></i>
        </button>
        <div class="sidebar-inner">
          <div class="row mobile-row" id="theme-row-mobile">
            <div class="col" id="theme-selector">
              <li class="nav-item dropdown" id="theme-button-list">
                <button class="btn btn-link nav-link px-0 px-lg-2 dropdown-toggle d-flex align-items-center" id="bd-theme" type="button" aria-expanded="false" data-bs-toggle="dropdown" data-bs-display="static" aria-label="Toggle theme (auto)">
                  <svg class="bi my-1 theme-icon-active"><use href="#circle-half"></use></svg><span class="d-lg-none ms-1" id="bd-theme-text">Toggle Theme</span>
                </button>
                <ul class="dropdown-menu dropdown-menu-right" aria-labelledby="bd-theme-text">
<li>
                    <button type="button" class="btn dropdown-item d-flex align-items-center" data-bs-theme-value="light" aria-pressed="false">
                      <svg class="bi me-2 theme-icon"><use href="#sun-fill"></use></svg>
                      Light
                      <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
                  </li>
                  <li>
                    <button type="button" class="btn dropdown-item d-flex align-items-center" data-bs-theme-value="dark" aria-pressed="false">
                      <svg class="bi me-2 theme-icon"><use href="#moon-stars-fill"></use></svg>
                      Dark
                      <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
                  </li>
                  <li>
                    <button type="button" class="btn dropdown-item d-flex align-items-center active" data-bs-theme-value="auto" aria-pressed="true">
                      <svg class="bi me-2 theme-icon"><use href="#circle-half"></use></svg>
                      Auto
                      <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
                  </li>
                </ul>
</li>
            </div>
          </div>
          <div class="row mobile-row">
            <div class="col">
              <div class="sidenav-view-selector">
                <div class="accordion accordion-flush" id="accordionFlush9">
                  <div class="accordion-item">
                    <h2 class="accordion-header" id="flush-headingNine">
                      <button class="accordion-button collapsed" id="instructor" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseNine" aria-expanded="false" aria-controls="flush-collapseNine">
                        <i id="eye" aria-hidden="true" class="icon" data-feather="eye"></i> Learner View
                      </button>
                    </h2>
                    <div id="flush-collapseNine" class="accordion-collapse collapse" aria-labelledby="flush-headingNine" data-bs-parent="#accordionFlush2">
                      <div class="accordion-body">
                        <a href="instructor/aio.html">Instructor View</a>
                      </div>
                    </div>
                  </div>
<!--/div.accordion-item-->
                </div>
<!--/div.accordion-flush-->
              </div>
<!--div.sidenav-view-selector -->
            </div>
<!--/div.col -->

            <hr>
</div>
<!--/div.mobile-row -->

          <div class="accordion accordion-flush" id="accordionFlush11">
            <div class="accordion-item">

              <button id="chapters" class="accordion-button show" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseEleven" aria-expanded="false" aria-controls="flush-collapseEleven">
                <h2 class="accordion-header chapters" id="flush-headingEleven">
                  EPISODES
                </h2>
              </button>
              <div id="flush-collapseEleven" class="accordion-collapse show collapse" aria-labelledby="flush-headingEleven" data-bs-parent="#accordionFlush11">

                <div class="accordion-body">
                  <div class="accordion accordion-flush" id="accordionFlush1">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading1">
        <a href="index.html">Summary and Setup</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush2">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading2">
        <a href="01_introduction.html">1. Introduction</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush3">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading3">
        <a href="02_resourcerequirements.html">2. Resource Requirements</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush4">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading4">
        <a href="03_schedulertools.html">3. Scheduler Tools</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush5">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading5">
        <a href="04_scalingstudy.html">4. Scaling Study</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush6">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading6">
        <a href="05_performancereports.html">5. Performance Overview</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush7">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading7">
        <a href="06_pinning.html">6. Pinning</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush8">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading8">
        <a href="07_bottlenecks.html">7. How to identify a bottleneck?</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush9">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading9">
        <a href="08_accelerators.html">8. Performance of Accelerators</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush10">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading10">
        <a href="09_nextsteps.html">9. Next Steps</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

                </div>
              </div>
            </div>

            <hr class="half-width">
<div class="accordion accordion-flush lesson-resources" id="accordionFlush12">
              <div class="accordion-item">
                <h2 class="accordion-header" id="flush-headingTwelve">
                  <button class="accordion-button collapsed" id="lesson-resources" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseTwelve" aria-expanded="false" aria-controls="flush-collapseTwelve">
                    RESOURCES
                  </button>
                </h2>
                <div id="flush-collapseTwelve" class="accordion-collapse collapse" aria-labelledby="flush-headingTwelve" data-bs-parent="#accordionFlush12">
                  <div class="accordion-body">
                    <ul>
<li>
                        <a href="key-points.html">Key Points</a>
                      </li>
                      <li>
                        <a href="reference.html#glossary">Glossary</a>
                      </li>
                      <li>
                        <a href="profiles.html">Learner Profiles</a>
                      </li>
                      <li><a href="reference.html">Reference</a></li>
                    </ul>
</div>
                </div>
              </div>
            </div>
            <hr class="half-width lesson-resources">
<a href="aio.html">See all in one page</a>


            <hr class="d-none d-sm-block d-md-none">
<div class="d-grid gap-1">

            </div>
          </div>
<!-- /div.accordion -->
        </div>
<!-- /div.sidebar-inner -->
      </nav>
</div>
<!-- /div.sidebar -->
  </div>
<!-- /div.sidebar-col -->
<!-- END:   inst/pkgdown/templates/navbar.html-->

        <!-- START: inst/pkgdown/templates/content-extra.html -->
  <div class="col-xl-8 col-lg-12 primary-content">
    <main id="main-content" class="main-content"><div class="container lesson-content">
        
        
<section id="aio-01_introduction"><p>Content from <a href="01_introduction.html">Introduction</a></p>
<hr>
<p>Last updated on 2025-11-27 |

        <a href="https://github.com/stderr-enst/jobefficiency/edit/main/episodes/01_introduction.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>What exactly is job efficiency in the computing world?</li>
<li>Why would I care about job efficiency and what are potential
pitfalls?</li>
<li>How can I start measuring how my program performs?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<p>After completing this episode, participants should be able to …</p>
<ul>
<li>Use timing commands provided by
<code>time</code>and<code>date</code>.</li>
<li>Understand the benefits of efficient jobs in terms of runtime and
numerical accuracy.</li>
<li>Have developed some awareness about the overall high energy
consumption of HPC.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section><h2 class="section-heading" id="background">Background<a class="anchor" aria-label="anchor" href="#background"></a>
</h2>
<hr class="half-width">
<p>Job efficieny, as defined by Oxford’s English Dictionaries, is
<em>the ratio of the useful work performed by a machine […] to the total
energy expended or heat taken in</em>. In a high-performance-computing
(HPC) context, the useful work is the entirety of all calculations to be
performed by our (heat-generating) computers. Doing this eficiently thus
translates to maximizing the calculations completed in some limited time
span while minimizing the heat output. In more extreme words, we want to
avoid running big computers for <em>nothing but hot air</em>.</p>
<p>One may object that a single user’s job may hardly have an effect on
an HPC system’s power usage since such systems are in power-on state
24/7 anyway. The same may be argued about air travel. The plane will
take off anyway, whether I board the plane or not. However, we indeed
have some leverage in contributing to efficiency, defined by fuel
consumption in air travel: traveling lightly, i.e., avoiding excessive
baggage will improve the airplane’s ratio <span class="math inline">\(\frac{useful\;work}{total\;energy\;expended}\)</span>.
So let’s get back to the ground and look at some inefficiencies in
computing jobs, while we will continue to use the air-travel
analogy.</p>
<div class="section level3">
<h3 id="time-to-sleep">
<code>time</code> to <code>sleep</code>
<a class="anchor" aria-label="anchor" href="#time-to-sleep"></a>
</h3>
<p>Let’s look at the command<code>sleep</code></p>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="fu">sleep</span> 2</span></code></pre>
</div>
<p>This command triggers a “computer nap”. It actually delays whatever
would come next for the specified time, here 2 seconds. You can verify
that nap time using a stopwatch, the latter given by
the<code>time</code>command:</p>
<div class="codewrapper sourceCode" id="cb2">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="bu">time</span> sleep 2</span></code></pre>
</div>
<p>which will report something like</p>
<pre><code>real	0m2.002s
user	0m0.001s
sys	0m0.000s</code></pre>
<p>The <code>time</code> command shall be our first
performance-measuring tool. <code>time</code>has become a bit of a
<em>hello-world</em> equivalent in HPC contexts. This command gives you
a breakdown of how your program uses CPU (Central Processing Unit) and
wall-clock time. The standard output of <code>time</code> reports three
fields, <em>real</em>, <em>user</em> and <em>sys</em>:</p>
<table class="table">
<colgroup>
<col width="8%">
<col width="91%">
</colgroup>
<tbody>
<tr class="odd">
<td>Time</td>
<td>Meaning</td>
</tr>
<tr class="even">
<td>real</td>
<td>Wall-clock time = total runtime as seen on a stopwatch</td>
</tr>
<tr class="odd">
<td>user</td>
<td>Time spent in <em>user</em>-mode: actual computations like math,
loops, logic</td>
</tr>
<tr class="even">
<td>sys</td>
<td>Time spent in OS’s <em>kernel</em>-mode (system calls): I/O =
reading/writing files, handling memory, talking to other devices</td>
</tr>
</tbody>
</table>
<p>The above<code>sleep</code>command abstains from any kind of math,
I/O, or other work that would show up in <em>user</em> or <em>sys</em>
time, hence these entries show (almost) zero.</p>
<div id="accordionSpoiler1" class="accordion spoiler-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button spoiler-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSpoiler1" aria-expanded="false" aria-controls="collapseSpoiler1">
  <h3 class="accordion-header" id="headingSpoiler1">  <div class="note-square"><i aria-hidden="true" class="callout-icon" data-feather="eye"></i></div> time or /usr/bin/time? that’s the question </h3>
</button>
<div id="collapseSpoiler1" class="accordion-collapse collapse" aria-labelledby="headingSpoiler1" data-bs-parent="#accordionSpoiler1">
<div class="accordion-body">
<p>The<code>time</code>commmand is both a keyword directly built into
the Bash shell as well as an executable file, usually residing
under<code>/usr/bin/time</code>. While very similar, they are not
exactly the same. Shell/Bash keywords take precedence, so preceding a
command with<code>time</code>invokes the shell keyword. Therefore, if
you want to force the usage of<code>/usr/bin/time</code>, you would
do</p>
<div class="codewrapper sourceCode" id="cb4">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a><span class="ex">/usr/bin/time</span> sleep 2</span></code></pre>
</div>
<p>Further note, that shell keyword documentation is invoked
via<code>help &lt;KEYWORD&gt;</code>, for example
<code>help time</code>, while most executables have manual pages,
e.g.,<code>man time</code>. At last, you can prefix the shell keyword
with a backslash in order to stop Bash from evaluating it,
so<code>\time sleep 2</code>will revert
to<code>/usr/bin/time</code>.</p>
</div>
</div>
</div>
</div>
</div>
<div class="section level3">
<h3 id="time-for-a-date">Time for a <code>date</code>
<a class="anchor" aria-label="anchor" href="#time-for-a-date"></a>
</h3>
<p>The<code>date</code>command, as its manpage (<code>man date</code>)
says, prints or sets the system date and time. In fact, this gives us a
super accurate stopwatch when used like this:</p>
<div class="codewrapper sourceCode" id="cb5">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a><span class="fu">date</span> +%s.%N</span></code></pre>
</div>
<p>reports a point in time as a number of seconds elapsed since a fixed
reference point.</p>
<div id="accordionSpoiler2" class="accordion spoiler-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button spoiler-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSpoiler2" aria-expanded="false" aria-controls="collapseSpoiler2">
  <h3 class="accordion-header" id="headingSpoiler2">  <div class="note-square"><i aria-hidden="true" class="callout-icon" data-feather="eye"></i></div> Epoch time </h3>
</button>
<div id="collapseSpoiler2" class="accordion-collapse collapse" aria-labelledby="headingSpoiler2" data-bs-parent="#accordionSpoiler2">
<div class="accordion-body">
<p>A referenced time point is also referred to as Epoch time, where,
according to the manpage of<code>date</code>, the (default) reference
point is the beginning of the year 1970, given as “1970-01-01 00:00
UTC”.</p>
</div>
</div>
</div>
</div>
<p>While<code>%s</code>invokes output of a referenc<strong>ed</strong>
time, the additional specifier<code>%N</code>enforces an accuracy down
to nanoseconds. Give it a try and you will see a large number (of
seconds) followed by 9 digits after the decimal point.</p>
<div id="an-accurate-stopwatch-date" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<span class="callout-header">Challenge</span>
<div id="an-accurate-stopwatch-date" class="callout-inner">
<h3 class="callout-title">An accurate stopwatch: <code>date</code>
</h3>
<div class="callout-content">
<p>You can use the construct<code>date +%s.%N</code>on the command line
or in a Bash script to save start and end time points as a variable:</p>
<div class="codewrapper sourceCode" id="cb6">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="va">start</span><span class="op">=</span><span class="va">$(</span><span class="fu">date</span> +%s.%N<span class="va">)</span></span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a><span class="co"># ... run some command(s)</span></span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a><span class="va">end</span><span class="op">=</span><span class="va">$(</span><span class="fu">date</span> +%s.%N<span class="va">)</span></span></code></pre>
</div>
<p>This gives you a stopwatch by setting a start time, running some
<strong>command(s)</strong>, and then storing the end time after
<strong>command(s)</strong> into a second variable. Differencing the two
times produces the elapsed time. Give this a try with
the<code>sleep</code>command in between.</p>
</div>
</div>
</div>
<div id="accordionHint1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button hint-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseHint1" aria-expanded="false" aria-controls="collapseHint1">
  <h4 class="accordion-header" id="headingHint1"> Give me a hint </h4>
</button>
<div id="collapseHint1" class="accordion-collapse collapse" aria-labelledby="headingHint1" data-bs-parent="#accordionHint1">
<div class="accordion-body">
<p>Differencing two numbers can be done, among other ways, using
the<code>bc</code>calculator tool:</p>
<div class="codewrapper sourceCode" id="cb7">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="bu">echo</span> <span class="st">"</span><span class="va">$end</span><span class="st"> - </span><span class="va">$start</span><span class="st">"</span> <span class="kw">|</span> <span class="fu">bc</span> <span class="at">-l</span></span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1"> Show me the solution </h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" aria-labelledby="headingSolution1" data-bs-parent="#accordionSolution1">
<div class="accordion-body">
<div class="codewrapper sourceCode" id="cb8">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a><span class="va">start</span><span class="op">=</span><span class="va">$(</span><span class="fu">date</span> +%s.%N<span class="va">)</span> <span class="kw">&amp;&amp;</span> <span class="fu">sleep</span> 2 <span class="kw">&amp;&amp;</span> <span class="va">end</span><span class="op">=</span><span class="va">$(</span><span class="fu">date</span> +%s.%N<span class="va">)</span> <span class="kw">&amp;&amp;</span> <span class="bu">echo</span> <span class="st">"</span><span class="va">$end</span><span class="st"> - </span><span class="va">$start</span><span class="st">"</span> <span class="kw">|</span> <span class="fu">bc</span> <span class="at">-l</span></span></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</section><section><h2 class="section-heading" id="part-1-example-for-an-inefficient-job">Part 1: Example for an inefficient job<a class="anchor" aria-label="anchor" href="#part-1-example-for-an-inefficient-job"></a>
</h2>
<hr class="half-width">
<p>After warming up with some timing methods, let’s analyze the
efficiency of a small script that makes our computer sweat a bit more
than the<code>sleep</code>command. Have a look at the following Bash
shell 7-liner.</p>
<div class="codewrapper sourceCode" id="cb9">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a><span class="co">#!/bin/bash</span></span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a><span class="va">sum</span><span class="op">=</span>0</span>
<span id="cb9-3"><a href="#cb9-3" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="va">$(</span><span class="fu">seq</span> 1 1000<span class="va">)</span><span class="kw">;</span> <span class="cf">do</span></span>
<span id="cb9-4"><a href="#cb9-4" tabindex="-1"></a>  <span class="va">val</span><span class="op">=</span><span class="kw">`</span><span class="bu">echo</span> <span class="st">"e(2 * l(</span><span class="va">${i}</span><span class="st">))"</span> <span class="kw">|</span> <span class="fu">bc</span> <span class="at">-l</span><span class="kw">`</span></span>
<span id="cb9-5"><a href="#cb9-5" tabindex="-1"></a>  <span class="va">sum</span><span class="op">=</span><span class="va">$(</span><span class="bu">echo</span> <span class="st">"</span><span class="va">$sum</span><span class="st"> + </span><span class="va">$val</span><span class="st">"</span> <span class="kw">|</span> <span class="fu">bc</span> <span class="at">-l</span><span class="va">)</span></span>
<span id="cb9-6"><a href="#cb9-6" tabindex="-1"></a><span class="cf">done</span></span>
<span id="cb9-7"><a href="#cb9-7" tabindex="-1"></a><span class="bu">echo</span> Sum=<span class="va">$sum</span></span></code></pre>
</div>
<p>Copy-paste this to a file, say<code>sum.bash</code>, and make it
executable via</p>
<div class="codewrapper sourceCode" id="cb10">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a><span class="fu">chmod</span> u+x sum.bash</span></code></pre>
</div>
<p>The main part of this shell script consists of
a<code>for</code>statement which runs a loop over 1000 iterations; note
that<code>seq 1 1000</code>creates the number sequence (<span class="math inline">\(i=1,2,3,...,1000\)</span>). Inside the
<code>for</code>loop the<code>bc</code>calculator tool is employed. The
first statement inside the loop (<code>val=...</code>) prints the
expression <code>e(2 * l(${i}))</code>, which is <code>bc</code>-talk
for the expression <span class="math inline">\(i^2\)</span> because of
the relation <span class="math inline">\(i^x=e^{x\cdot \ln(i)}\)</span>,
for example <span class="math inline">\(e^{2\cdot\ln(3)}=3^2\)</span>,
where ln is the natural logarithm. The second statement inside the loop
(<code>sum=...</code>) accumulates the expressions
<code>val=</code><span class="math inline">\(i^2\)</span>
into<code>sum</code>, so the output of the final<code>echo</code>line is
the total, <span class="math inline">\(\sum_{i=1}^{1000}i^2\)</span>.</p>
<div id="identify-the-inefficient-pieces" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<span class="callout-header">Challenge</span>
<div id="identify-the-inefficient-pieces" class="callout-inner">
<h3 class="callout-title">Identify the inefficient pieces</h3>
<div class="callout-content">
<p>In the above Bash script, the<code>for</code>loop invokes the
<code>bc</code>calculator twice during every loop iteration. Compared to
another method to be investigated below, this method is rather slow. Any
idea why that is the case?</p>
</div>
</div>
</div>
<div id="accordionHint2" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button hint-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseHint2" aria-expanded="false" aria-controls="collapseHint2">
  <h4 class="accordion-header" id="headingHint2"> Give me a hint </h4>
</button>
<div id="collapseHint2" class="accordion-collapse collapse" aria-labelledby="headingHint2" data-bs-parent="#accordionHint2">
<div class="accordion-body">
<p>Each statement<code>echo … | bc -l</code>spawns a
new<code>bc</code>process via a subshell.</p>
</div>
</div>
</div>
</div>
<div id="accordionSolution2" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution2" aria-expanded="false" aria-controls="collapseSolution2">
  <h4 class="accordion-header" id="headingSolution2"> Show me the solution </h4>
</button>
<div id="collapseSolution2" class="accordion-collapse collapse" aria-labelledby="headingSolution2" data-bs-parent="#accordionSolution2">
<div class="accordion-body">
<p>The statement<code>echo … | bc -l</code>spawns a
new<code>bc</code>process via a subshell. Here, each loop iteration
invokes two of those. Each subshell is essentially a separate process
and involves a certain startup cost, parsing overhead, and OS-internal
inter‑process communication. Such overhead will account for most of the
total runtime of<code>sum.bash</code>.</p>
</div>
</div>
</div>
</div>
<p>The overhead in this shell script is dominated by process creation
and context switching, that is, calling the<code>bc</code>tool so many
times. Going back to our air-travel analogy, the summation of 1000
numbers shall be equivalent to having a total of 1000 passengers board a
large plane. When total boarding time counts, an inefficient boarding
procedure would involve every passenger loading two carryon pieces. Many
of you may have experienced, how stuffing an excessive number of baggage
pieces into the overhead compartments can slow things down in the
plane’s aisles, similar to the overhead due to the 2000 (two for each
loop iteration)<code>bc</code>sub-processes that hinder the data stream
inside the CPU’s “aisles”.</p>
<div id="lets-pull-out-our-stopwatches" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<span class="callout-header">Challenge</span>
<div id="lets-pull-out-our-stopwatches" class="callout-inner">
<h3 class="callout-title">Let’s pull out our stopwatches</h3>
<div class="callout-content">
<p>Using either<code>time</code>or<code>date</code>, can you get a
runtime measurement for<code>sum.bash</code>?</p>
</div>
</div>
</div>
<div id="accordionHint3" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button hint-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseHint3" aria-expanded="false" aria-controls="collapseHint3">
  <h4 class="accordion-header" id="headingHint3"> Give me a hint </h4>
</button>
<div id="collapseHint3" class="accordion-collapse collapse" aria-labelledby="headingHint3" data-bs-parent="#accordionHint3">
<div class="accordion-body">
<p>You can precede any command with<code>time</code>. If you want to
use<code>date</code>, remember that<code>now=$(date +%s.%N)</code>lets
you store the current time point and<code>&amp;&amp;</code>lets you join
commands together.</p>
</div>
</div>
</div>
</div>
<div id="accordionSolution3" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution3" aria-expanded="false" aria-controls="collapseSolution3">
  <h4 class="accordion-header" id="headingSolution3"> Show me the solution </h4>
</button>
<div id="collapseSolution3" class="accordion-collapse collapse" aria-labelledby="headingSolution3" data-bs-parent="#accordionSolution3">
<div class="accordion-body">
<p>A straightforward way is</p>
<div class="codewrapper sourceCode" id="cb11">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a><span class="bu">time</span> ./sum.bash</span></code></pre>
</div>
<p>Alternatively,<code>date</code>and<code>&amp;&amp;</code>can be
combined to a wrapper in order to
time<code>sum.bash</code>externally,</p>
<div class="codewrapper sourceCode" id="cb12">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a><span class="va">start</span><span class="op">=</span><span class="va">$(</span><span class="fu">date</span> +%s.%N<span class="va">)</span> <span class="kw">&amp;&amp;</span> <span class="ex">./sum.bash</span> <span class="kw">&amp;&amp;</span> <span class="va">end</span><span class="op">=</span><span class="va">$(</span><span class="fu">date</span> +%s.%N<span class="va">)</span> <span class="kw">&amp;&amp;</span> <span class="bu">echo</span> <span class="st">"</span><span class="va">$end</span><span class="st"> - </span><span class="va">$start</span><span class="st">"</span> <span class="kw">|</span> <span class="fu">bc</span> <span class="at">-l</span></span></code></pre>
</div>
<p>Another option is to place<code>date</code>inside the
script<code>sum.bash</code>,</p>
<div class="codewrapper sourceCode" id="cb13">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a><span class="co">#!/bin/bash</span></span>
<span id="cb13-2"><a href="#cb13-2" tabindex="-1"></a><span class="va">start</span><span class="op">=</span><span class="va">$(</span><span class="fu">date</span> +%s.%N<span class="va">)</span> <span class="co"># set start time</span></span>
<span id="cb13-3"><a href="#cb13-3" tabindex="-1"></a><span class="va">sum</span><span class="op">=</span>0</span>
<span id="cb13-4"><a href="#cb13-4" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="va">$(</span><span class="fu">seq</span> 1 1000<span class="va">)</span><span class="kw">;</span> <span class="cf">do</span></span>
<span id="cb13-5"><a href="#cb13-5" tabindex="-1"></a>  <span class="va">val</span><span class="op">=</span><span class="kw">`</span><span class="bu">echo</span> <span class="st">"e(2 * l(</span><span class="va">${i}</span><span class="st">))"</span> <span class="kw">|</span> <span class="fu">bc</span> <span class="at">-l</span><span class="kw">`</span></span>
<span id="cb13-6"><a href="#cb13-6" tabindex="-1"></a>  <span class="va">sum</span><span class="op">=</span><span class="va">$(</span><span class="bu">echo</span> <span class="st">"</span><span class="va">$sum</span><span class="st"> + </span><span class="va">$val</span><span class="st">"</span> <span class="kw">|</span> <span class="fu">bc</span> <span class="at">-l</span><span class="va">)</span></span>
<span id="cb13-7"><a href="#cb13-7" tabindex="-1"></a><span class="cf">done</span></span>
<span id="cb13-8"><a href="#cb13-8" tabindex="-1"></a><span class="va">end</span><span class="op">=</span><span class="va">$(</span><span class="fu">date</span> +%s.%N<span class="va">)</span> <span class="co"># set end time</span></span>
<span id="cb13-9"><a href="#cb13-9" tabindex="-1"></a><span class="bu">echo</span> Sum=<span class="va">$sum</span> runtime=<span class="kw">`</span><span class="bu">echo</span> <span class="st">"</span><span class="va">$end</span><span class="st"> - </span><span class="va">$start</span><span class="st">"</span> <span class="kw">|</span> <span class="fu">bc</span> <span class="at">-l</span><span class="kw">`</span></span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="section level3">
<h3 id="speeding-things-up">Speeding things up<a class="anchor" aria-label="anchor" href="#speeding-things-up"></a>
</h3>
<p>A remedy to the inefficiencies we found inside
the<code>for</code>loop of<code>sum.bash</code>is to avoid the spawning
of many sub-processes that are caused by repetitively
calling<code>bc</code>. In other words, ideally, the many sub-processes
conflate into one. In terms of the airplane analogy, we want people to
store all their carryon pieces in a big container, where its subsequent
loading onto the plane is a single process, as opposed to every
passenger running a proprietary sub-process. Collapsing things into one
sub-processes can be achieved by replacing the external loop by
a<code>bc</code>-internal one:</p>
<div class="codewrapper sourceCode" id="cb14">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a><span class="bu">echo</span> <span class="st">"s=0; for(i=1; i&lt;=1000; i++)s+=i^2; s"</span> <span class="kw">|</span> <span class="fu">bc</span> <span class="at">-l</span></span></code></pre>
</div>
<p>In this method, to be called the <em>one-liner</em>, the loop,
arithmetic, and accumulation are free of the overhead. This example
shall be a placeholder for a common scenario, where potentially large
efficiency gains can be achieved by replacing inefficient math
implementations by numerically optimized software
<em>libraries</em>.</p>
<div id="evaluate-the-runtime-improvement" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<span class="callout-header">Challenge</span>
<div id="evaluate-the-runtime-improvement" class="callout-inner">
<h3 class="callout-title">Evaluate the runtime improvement</h3>
<div class="callout-content">
<p>Compare the runtimes of the summation
script<code>sum.bash</code>versus the one-liner.</p>
</div>
</div>
</div>
<div id="accordionHint4" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button hint-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseHint4" aria-expanded="false" aria-controls="collapseHint4">
  <h4 class="accordion-header" id="headingHint4"> Give me a hint </h4>
</button>
<div id="collapseHint4" class="accordion-collapse collapse" aria-labelledby="headingHint4" data-bs-parent="#accordionHint4">
<div class="accordion-body">
<p>The Bash keyword<code>time</code>is sufficient to see the runtime
difference.</p>
</div>
</div>
</div>
</div>
<div id="accordionSolution4" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution4" aria-expanded="false" aria-controls="collapseSolution4">
  <h4 class="accordion-header" id="headingSolution4"> Show me the solution </h4>
</button>
<div id="collapseSolution4" class="accordion-collapse collapse" aria-labelledby="headingSolution4" data-bs-parent="#accordionSolution4">
<div class="accordion-body">
<p>You can use<code>time</code>for both summation methods,</p>
<div class="codewrapper sourceCode" id="cb15">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a><span class="bu">time</span> ./sum.bash</span>
<span id="cb15-2"><a href="#cb15-2" tabindex="-1"></a><span class="bu">time</span> echo <span class="st">"s=0; for(i=1; i&lt;=1000; i++)s+=i^2; s"</span> <span class="kw">|</span> <span class="fu">bc</span> <span class="at">-l</span></span></code></pre>
</div>
</div>
</div>
</div>
</div>
<p>While it depends a bit on the employed hardware, one will notice that
the one-liner runs roughly 1000 times faster than<code>sum.bash</code>.
Of course, one could live with this inefficiency when it is just needed
once in a while and the script’s overall runtime amounts to just a few
seconds. However, imagine some large-scale computing job that is
supposed to finish within an hour on a supercomputer for which one has
to pay a usage fee on a per-hour basis. If implemented poorly, an
already small overhead increase, say by a factor of 2, would render this
computing job expensive, both in terms of time and money.</p>
<div id="accordionSpoiler3" class="accordion spoiler-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button spoiler-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSpoiler3" aria-expanded="false" aria-controls="collapseSpoiler3">
  <h3 class="accordion-header" id="headingSpoiler3">  <div class="note-square"><i aria-hidden="true" class="callout-icon" data-feather="eye"></i></div> CPU-bound versus memory-bound </h3>
</button>
<div id="collapseSpoiler3" class="accordion-collapse collapse" aria-labelledby="headingSpoiler3" data-bs-parent="#accordionSpoiler3">
<div class="accordion-body">
<p>The above runtime comparisons merely look at calculation speed, which
depends on CPU processing speed. Such a task is thus called
<em>CPU-bound</em>. On the other hand, the peformance of a
<em>memory-bound</em> process is limited by the speed of memory access.
This happens when the CPU spends most of its time waiting for data to be
fetched from memory (RAM), cache, or storage, causing its execution
pipeline to stall. Optimization of memory-bound tasks addresses
performance bottlenecks due to data transfer speeds rather than
calculation speeds. Finally, when data transfer involves a high
percentage of disk or network access, disk/networking speed becomes a
limiting factor, rendering a process <em>I/O-bound</em>.</p>
</div>
</div>
</div>
</div>
</div>
<div class="section level3">
<h3 id="to-be-precise-numerical-efficiency">To be precise: Numerical efficiency<a class="anchor" aria-label="anchor" href="#to-be-precise-numerical-efficiency"></a>
</h3>
<p>Inefficient computing is not only limited to being unneccessarily
slow. It can also entail the scenario where an excessive accuracy can
lead to unneccessary runtime increases. Without going into details,
let’s just keep in mind that in computing, accuracy depends on the
<em>precision</em> of the numbers that are being processed by the CPU.
Precision essentially governs how many digits after the decimal point
are accounted for in mathematical operations. The higher the precision,
the fewer calculations can be processed within a fixed time. On the
other hand, within that same time, the CPU can crank through more
low-precision numbers; however, an insufficient precision can render
lengthy calculations useless. The optimal degree of precision, in terms
of computing efficiency, is application dependent.</p>
<!---
The internal accuracy of`bc`is defined by an adjustable parameter`scale`which
defines how some operations use digits after the decimal point. The default value of`scale`is 0.
During each`bc`call within the summation loop of`sum.bash`, the intermediate result is rounded
according to the current setting of`scale`. An insufficiently low precision setting
leads to an accumulation of rounding errors over many loop iterations,
rendering the final result (like a sum or product) erroneous.--->
<div id="compare-numerical-results" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<span class="callout-header">Challenge</span>
<div id="compare-numerical-results" class="callout-inner">
<h3 class="callout-title">Compare numerical results</h3>
<div class="callout-content">
<p>Our summation implementation via<code>sum.bash</code>exemplifies the
case of an inaccurate calculation. When running the two summation
methods in the previous challenge, have a look at the actual summation
results. Which of the two end results do you think is more accurate and
why? Is the erroneous result smaller or larger and why?</p>
</div>
</div>
</div>
<div id="accordionHint5" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button hint-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseHint5" aria-expanded="false" aria-controls="collapseHint5">
  <h4 class="accordion-header" id="headingHint5"> Give me a hint </h4>
</button>
<div id="collapseHint5" class="accordion-collapse collapse" aria-labelledby="headingHint5" data-bs-parent="#accordionHint5">
<div class="accordion-body">
<p>Think of another airplane example. Which scenario is more prone to
things getting lost or forgotten? 1) Passengers bring and take their own
baggage pieces to the cabin, or 2) Baggage pieces are stored and
retrieved collectively.</p>
</div>
</div>
</div>
</div>
<div id="accordionSolution5" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution5" aria-expanded="false" aria-controls="collapseSolution5">
  <h4 class="accordion-header" id="headingSolution5"> Show me the solution </h4>
</button>
<div id="collapseSolution5" class="accordion-collapse collapse" aria-labelledby="headingSolution5" data-bs-parent="#accordionSolution5">
<div class="accordion-body">
<p>The method<code>sum.bash</code>, using the
external<code>for</code>loop, and the one-liner return the final sums,
respectively,</p>
<pre><code><span><span class="fl">103075329</span>  <span class="co"># bc, external loop (sum.bash)</span></span>
<span><span class="fl">333833500</span>  <span class="co"># bc, internal loop (one-liner)</span></span></code></pre>
<p>where the first result may vary on your machine. The
method<code>sum.bash</code>is affected by the setting of the
<code>bc</code>-internal parameter<code>scale</code>which defines how
some operations, here the exponential function <strong>e(…)</strong> and
logarithm <strong>ln(…)</strong> use digits after the decimal point. The
default value of<code>scale</code>is 0, which basically leads to
truncations after the decimal point, so rounding errors accumulate at
every loop iteration. Hence, the final sum drifts downward (by a lot)
compared to the second (true) value. Of course,<code>scale</code>can be
increased. The manpage of<code>bc</code>actually says that it is “an
arbitrary precision calculator language”.</p>
</div>
</div>
</div>
</div>
</div>
</section><section><h2 class="section-heading" id="part-2-about-hpc-power-consumption">Part 2: About HPC power consumption<a class="anchor" aria-label="anchor" href="#part-2-about-hpc-power-consumption"></a>
</h2>
<hr class="half-width">
<p>The <em>HP</em> (high performace) in HPC refers to the fact that the
employed computer hardware is able to do a lot of multitasking, also
called parallel computing. Parallel programming essentially exploits the
CPU’s multitasking ability. Therefore, a lot of HPC-efficiency aspects
revolve around keeping everyone in a CPU’s multitasking team equally
busy. We will look at some of those aspects during the course of later
episodes.</p>
<div class="section level3">
<h3 id="the-more-the-merrier-cpugpu-cores">The more the merrier: CPU/GPU cores<a class="anchor" aria-label="anchor" href="#the-more-the-merrier-cpugpu-cores"></a>
</h3>
<p>Common parallel-computing jobs employ multiple cores of a CPU, or
even multiple CPUs, simultaneously. A core is a processing unit within a
CPU that independently executes instructions. These days (as of 2025),
typical CPUs are quad-core (4 cores), octa-core (8 cores), and so on.
High-end gaming CPUs often have 16+ cores, HPC cluster nodes feature
multiple CPUs, oftentimes with 64+ cores each; and all these numbers
keep going up.</p>
<p>Nowadays, almost all HPC centers are also equipped with GPU (Graphics
Processing Unit) hardware. Such hardware is optimal for jobs where
<em>many cores</em> is more important than fewer powerful cores.<br>
The number of GPU cores varies greatly depending on the model, ranging
from a few hundred in low-end GPU cards to over 16,000 in high-end
ones.</p>
</div>
<div class="section level3">
<h3 id="measuring-parallel-runtime-core-hours">Measuring parallel runtime: core hours<a class="anchor" aria-label="anchor" href="#measuring-parallel-runtime-core-hours"></a>
</h3>
<p>Owing to the inherent parallelism in the HPC world, people came up
with some measure which takes the <em>granularity</em> into account when
allocating not only runtime but also the number of requested cores. The
unit <strong>core hour</strong> (<strong>core-h</strong>) represents the
usage of one CPU core for one hour and scales with core count. For
example, assume you have a monthly allocation of 500 core-h, with a fee
incurred when exceeding that quota. So with 500 core-h, you could run a
one-hour parallel job utilizing 500 CPU cores for free. Or, in the other
extreme, if your program does not or cannot multitask, you could run a
single-core job for 500 hours, provided you won’t forget at the end what
this job was about.</p>
<div id="accordionSpoiler4" class="accordion spoiler-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button spoiler-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSpoiler4" aria-expanded="false" aria-controls="collapseSpoiler4">
  <h3 class="accordion-header" id="headingSpoiler4">  <div class="note-square"><i aria-hidden="true" class="callout-icon" data-feather="eye"></i></div> Other HPC resource types </h3>
</button>
<div id="collapseSpoiler4" class="accordion-collapse collapse" aria-labelledby="headingSpoiler4" data-bs-parent="#accordionSpoiler4">
<div class="accordion-body">
<p>So far, the focus has been on core number and hours for HPC resource
allocation. Keep in mind, however, that the HPC resource portfolio
involves other hardware components as well:</p>
<ul>
<li>Memory: There are (whether parallel or not) jobs, that request a
large amount of memory (RAM). For example, some mathematical solution
methods for large equation systems do not allow the compartmentalization
of the total required memory across CPU cores, that is, many-core
processes need to know each other’s memory chunks. HPC centers usually
have large-memory nodes assigned for such applications.</li>
<li>Storage: Other applications process huge amounts of data, think of
genomics or climate modelling, which can involve terabytes or even
petabytes of data to be stored and analyzed.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="section level3">
<h3 id="a-typical-hpc-computing-job">A typical HPC computing job<a class="anchor" aria-label="anchor" href="#a-typical-hpc-computing-job"></a>
</h3>
<p>Like in the automotive world, high performance means high power,
which in turn involves a high energy demand. Let’s consider a typical
parallel scientific-computing job to be run in some HPC center. Our
example job shall be deemed too large for one CPU, so it employs
multiple CPUs, which in turn are distributed across nodes. Node power
usage is measured in W=Watt, which is the SI unit of power and
corresponds to the rate of consumption of energy in an electric circuit.
One compute node with a 64-core CPU can consume between 300 W in idle
state, and 900 W (maximum load) for air-cooled systems, whereas this
range is roughly 250-850 W for the slightly more efficient liquid-cooled
systems. For comparison, an average coffee maker consumes between 800 W
(drip coffee maker) and 1500 W (espresso machine). Our computing job
shall then use these resources:</p>
<ul>
<li>12 nodes are crunching numbers in parallel</li>
<li>64 cores/node (e.g., Intel® Xeon® 6774P, or AMD® EPYC® 9534)</li>
<li>12 hours of full load (realistic for many scientific
simulations)</li>
<li>Power per node: (idle vs. full load):
<ul>
<li>Idle: ~300 W</li>
<li>Full load: ~900 W</li>
<li>Extra power per node: 600 W</li>
</ul>
</li>
<li>Total extra power: 12 nodes × 600 W × 12 hours = 86,400 Wh = 86.4
kWh</li>
</ul>
<div id="how-many-core-hours-does-this-job-involve" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<span class="callout-header">Challenge</span>
<div id="how-many-core-hours-does-this-job-involve" class="callout-inner">
<h3 class="callout-title">How many core hours does this job
involve?</h3>
<div class="callout-content">
<p>HPC centers have different job <em>queues</em> for different kinds of
computing jobs. For example, a queue named <em>big-jobs</em> may be
reserved for jobs exceeding a total of 1024 parallel processes =
<em>tasks</em>. Another queue named <em>big-mem</em> may accomodate
tasks with high memory demands by giving access to high-memory nodes
(e.g., 512 GB, 1 TB, or more RAM per compute node).</p>
<p>Let’s assume, you have three job queues available, all with identical
memory layout:</p>
<ul>
<li>
<code>small-jobs</code>: Total task count of up to 511.</li>
<li>
<code>medium-jobs</code>: Total task count 512-1023.</li>
<li>
<code>big-jobs</code>: Total task count of 1024 or more.</li>
</ul>
<p>When submitting the above computing job, in which queue would it end
up? And, if there would be a charge of 1 Cent per core-h, what is the
total cost in € (1€ = 100 Cents)?</p>
</div>
</div>
</div>
<div id="accordionHint6" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button hint-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseHint6" aria-expanded="false" aria-controls="collapseHint6">
  <h4 class="accordion-header" id="headingHint6"> Give me a hint </h4>
</button>
<div id="collapseHint6" class="accordion-collapse collapse" aria-labelledby="headingHint6" data-bs-parent="#accordionHint6">
<div class="accordion-body">
<p>The total number of tasks results from the product
<em>cores-per-node</em> <span class="math inline">\(\times\)</span>
<em>nodes</em>. Total core hours is the task count multiplied by the
job’s requested time in hours.</p>
</div>
</div>
</div>
</div>
<div id="accordionSolution6" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution6" aria-expanded="false" aria-controls="collapseSolution6">
  <h4 class="accordion-header" id="headingSolution6"> Show me the solution </h4>
</button>
<div id="collapseSolution6" class="accordion-collapse collapse" aria-labelledby="headingSolution6" data-bs-parent="#accordionSolution6">
<div class="accordion-body">
<p>The total number of tasks is <em>cores-per-node</em> <span class="math inline">\(\times\)</span> <em>nodes</em> = <span class="math inline">\(64\times 12 = 768\)</span>, which would put the
job into the<code>medium-jobs</code>queue. The HPC center would bill us
for <span class="math inline">\(64\times 12\times 12 = 9216\)</span>
core hours, hence €92.16.</p>
</div>
</div>
</div>
</div>
</div>
<div class="section level3">
<h3 id="what-are-watt-hours">What are Watt hours?<a class="anchor" aria-label="anchor" href="#what-are-watt-hours"></a>
</h3>
<p>The unit Wh (Watt-hours) measures energy, so 86,400 Wh is the energy
that a 86,400 W (or 86.4 kW, k=kilo) powerful machine consumes in one
hour. Back to coffee, brewing one cup needs 50-100 Wh, depending on
preparation time and method. So, running your 12-node HPC job for 12
hours is equivalent to brewing between 864 and 1,728 cups of coffee. For
those of us who don’t drink coffee, assuming 100% conversion efficiency
from our compute job’s heat to mechanical energy, which is unrealistic,
we could lift an average African elephant (~6 tons) about 5,285 meters
straight up, not quite to the top but in sight of Mount Kilimanjaro’s
(5,895 m) summit.</p>
<div id="accordionSpoiler5" class="accordion spoiler-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button spoiler-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSpoiler5" aria-expanded="false" aria-controls="collapseSpoiler5">
  <h3 class="accordion-header" id="headingSpoiler5">  <div class="note-square"><i aria-hidden="true" class="callout-icon" data-feather="eye"></i></div> Power-consuming hardware pieces </h3>
</button>
<div id="collapseSpoiler5" class="accordion-collapse collapse" aria-labelledby="headingSpoiler5" data-bs-parent="#accordionSpoiler5">
<div class="accordion-body">
<p>Note that the focus is on <strong>extra</strong> power, that is,
beyond the CPU’s idle state. Attributing our job’s extra power only to
CPU usage underestimates its footprint. In practice, the actual delta
from idle to full load will vary based on the load posed on other
hardware components. Therefore, it is interesting to shed some light
onto those other hardware components that start gearing up after hitting
that Enter key which submits the above kind of HPC job.</p>
<ul>
<li>
<p>CPUs consume power through two main processes:</p>
<ol style="list-style-type: decimal">
<li>Dynamic power consumption: It is caused by the constant switching of
transistors and is influenced by the CPU’s clock frequency and
voltage.</li>
<li>Static power consumption: It is caused by small leakage currents
even when the CPU is idle. This is a function of the total number of
transistors.</li>
</ol>
<p>Both processes convert electrical energy into heat, which makes CPU
cooling so important.</p>
</li>
<li><p>Memory (DRAM) consumes power primarily through its refresh
cycles. These are required to counteract the charge leakage in the
data-storing capacitors. Periodic refreshing is necessary to maintain
data integrity, which is the main reason why DRAM draws power even when
idle. Other power consumption factors include the static power drawn by
the memory’s circuitry and the active power used during read/write
operations.</p></li>
<li><p>Network interface cards (NICs) consume power by converting
digital data into electrical signals for transmission and reception.
Power draw increases with data throughput, physical-media complexity,
like fiber optics, and also depends on the specific interconnect
technology used.</p></li>
<li><p>Storage components: Hard drives (HDDs) require constant energy
due to moving mechanical parts, like the disc-spinning motors. SSDs
store data electronically via flash memory chips and are thus more
power-efficient, especially when idle. However, when performing heavy
read/write tasks, SSD power consumption can also be significant, though
they complete these tasks faster than HDDs and return to their idle
state sooner.</p></li>
<li>
<p>Cooling is one of the biggest contributors to total energy use in
HPC:</p>
<ul>
<li>Idle: Cooling uses ~10–20% of total system power.</li>
<li>Max load: Cooling can consume ~50–70% of total power (depends on
liquid- or air-cooled systems).</li>
</ul>
<p>Cooling is essential because all electrical circuits generate heat
during operation. Under heavy computational loads, insufficiently cooled
CPUs and GPUs exceed their safe temperature limits.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<p>These considerations hopefully highlight why there is benefit in
identifying potential efficiency bottlenecks before submitting an
energy-intense HPC job. If all passengers care about efficient job
design, i.e., the total baggage load, more can simultaneously jump onto
the HPC plane.</p>
<!---
 Use timing commands provided by `time`and`date`.
- Understand the benefits of efficient jobs in terms of runtime and numerical accuracy.
- Have developed some awareness about the overall high energy consumption of HPC.
--->
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<span class="callout-header">Key Points</span>
<div class="callout-inner">
<div class="callout-content">
<ul>
<li>Using a <em>stopwatch</em> like<code>time</code>gives you a first
tool to log actual versus expected runtimes; it is also useful for
carrying out runtime comparisons.</li>
<li>Most HPC centers offer sophisticated tools for measuring various
performance metrics. Knowing one or a couple of those tools will help a
lot in tuning your applications.</li>
<li>Which hardware piece (CPU, memory/RAM, disk, network, etc.) poses a
limiting factor, depends on the nature of a particular application.</li>
<li>Large-scale computing is power hungry, so we want to use the energy
wisely. As shown in the next episodes, you have more <em>power</em> than
it may be expected over controlling job efficiency and thus overall
energy footprint.</li>
<li>Computing job efficiency goes beyond individual gain in runtime as
shared resources are used more effectively, that is, the ratio <span class="math inline">\(\frac{useful\;work}{total\;energy\;expended}\sim\frac{number\;of\;users}{total\;energy\;expended}\)</span>
improves.</li>
</ul>
</div>
</div>
</div>
</div>
</section><section><h2 class="section-heading" id="so-whats-next">So what’s next?<a class="anchor" aria-label="anchor" href="#so-whats-next"></a>
</h2>
<hr class="half-width">
<p>The following episodes will put a number of these introductory
thoughts into concrete action by looking at some efficiency aspects
around a compute-intense graphical program. While it is not directly an
action-loaded video game, it does contain essential pieces thereof,
because it uses the technique of ray tracing.</p>
<p>Ray tracing is a technique that simulates how light travels in a 3D
scene to create realistic images. It simulates the behaviour of light in
terms of optical effects like reflection, refraction, shadows,
absorption, etc. The underlying calculations involve real-world physics,
which makes them computationally expensive - a perfect HPC case. So are
you ready for running a ray tracer on HPC hardware? Here is a basic run
script, which you can copy-paste for now. We will go into more details
later.</p>
<pre><code>#!/usr/bin/bash
#SBATCH --time=01:00:00
#SBATCH --nodes=1
#SBATCH --tasks-per-node=4

# Put in the same "module load ..." command when building the raytracer program
time mpirun -np 4 raytracer -width=800 -height=800 -spp=128 -alloc_mode=3</code></pre>
<p>Check the<code>time</code>output at the end of the job’s output file
(named something like <code>slurm-&lt;NUMBER&gt;.out</code>). You will
notice that <em>user</em> time is by a certain factor larger than
<em>real</em> time. Any guess which number in the
<code>mpirun</code>line corresponds roughly to that factor? <!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 --></p>
</section></section><section id="aio-02_resourcerequirements"><p>Content from <a href="02_resourcerequirements.html">Resource Requirements</a></p>
<hr>
<p>Last updated on 2025-11-05 |

        <a href="https://github.com/stderr-enst/jobefficiency/edit/main/episodes/02_resourcerequirements.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>How many resources should I request initially?</li>
<li>What scheduler options exist to request resources?</li>
<li>How do I know if they are used well?</li>
<li>How large is my HPC cluster?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<p>After completing this episode, participants should be able to …</p>
<ul>
<li>Identify the size of their jobs in relation to the HPC system.</li>
<li>Request a good amount of resources from the scheduler.</li>
<li>Change the parameters to see how the execution time changes.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section><h2 class="section-heading" id="starting-somewhere">Starting Somewhere<a class="anchor" aria-label="anchor" href="#starting-somewhere"></a>
</h2>
<hr class="half-width">
<p>Didactic path: I have no idea how many resources to ask for -&gt;
just guess and start with some combinations. Next identify slower, or
failed (OOM, timelimit) and choose the best What does that say about
efficiency?</p>
<div id="what-is-a-scheduler-and-why-do-we-need-one" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<span class="callout-header">Callout</span>
<div id="what-is-a-scheduler-and-why-do-we-need-one" class="callout-inner">
<h3 class="callout-title">What is a scheduler and why do we need
one?</h3>
<div class="callout-content">
<p>HPC machines offer a large amount of compute power but are too
expensive for a single person or a small research group. Therefore, HPC
machines are deployed as shared resources with substantional user
communities ranging from dozens to thousands of users. In such a
scenario you need a way to manage who gets to run which calculation on
what part of the machine at what time. A scheduler is a software package
to let users request resources for a job. It creates the schedule of
what job gets to run on what resources and when.</p>
<p>Historically, there have been many schedulers, for example, <a href="https://www.ibm.com/products/load-balancer" class="external-link"><code>Loadbalancer</code></a>,
<a href="https://docs.oracle.com/cd/E19279-01/820-3257-12/n1ge.html" class="external-link"><code>GridEngine</code></a>,
<a href="https://www.openpbs.org/" class="external-link"><code>PBS</code></a>, <a href="https://docs.adaptivecomputing.com/maui/" class="external-link"><code>Maui</code></a>,
and others. In the early 2000s the development of “<a href="https://doi.org/10.1007/10968987_3" class="external-link">SLURM</a>: Simple Linux
Utility for Resource Management” began. With the rise of Linux on HPC
systems SLURM has become a widely used scheduling system. For that
reason this course assumes that SLURM is available on your HPC
system.</p>
</div>
</div>
</div>
<div id="exercise-starting-somewhere" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<span class="callout-header">Discussion</span>
<div id="exercise-starting-somewhere" class="callout-inner">
<h3 class="callout-title">Exercise: Starting Somewhere</h3>
<div class="callout-content">
<ul>
<li>Run job with a timelimit of 1 minute -&gt; Trigger timelimit. What’s
a good timelimit for our task?</li>
<li>Run job with few cores, but too much memory/core -&gt; Trigger OOM.
What’s a good memory limit for our task?</li>
<li>Run job with requesting way too many cores -&gt; Endless waiting or
not accepted due to account limits. What’s a good CPU limit for our
task?</li>
<li>
<code>squeue</code> to learn about scheduling issues / reasons</li>
</ul>
</div>
</div>
</div>
<p>Summarize dimensions in which a job has to be sized correctly (time,
cores, memory, gpus, …).</p>
</section><section><h2 class="section-heading" id="compared-to-the-hpc-system">Compared to the HPC System<a class="anchor" aria-label="anchor" href="#compared-to-the-hpc-system"></a>
</h2>
<hr class="half-width">
<ul>
<li>What’s the relationship between your job and existing hardware of
the system?
<ul>
<li>What hardware does your HPC system offer?</li>
<li>Documentation and Slurm commands</li>
</ul>
</li>
<li>Is my job large or small?
<ul>
<li>What’s considered large, medium, small? Maybe as percentage of whole
system?</li>
<li>Issues of large jobs: long waiting times</li>
<li>Issues of many (thousands) small jobs:</li>
</ul>
</li>
<li>How many resources are currently free?</li>
<li>How long do I have to wait? (looking up scheduler estimate + apply
common sense)</li>
</ul>
<div id="exercise-comparing-to-the-system" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<span class="callout-header">Discussion</span>
<div id="exercise-comparing-to-the-system" class="callout-inner">
<h3 class="callout-title">Exercise: Comparing to the system</h3>
<div class="callout-content">
<ul>
<li>
<code>sinfo</code> to learn about partitions and free resources</li>
<li>
<code>scontrol</code> to learn about nodes in those partitions</li>
<li>
<code>lscpu</code> and <code>cat /proc/cpuinfo</code>
</li>
<li>Submit a job with a reasonable number of resources and use
<code>squeue</code> and/or <code>scontrol show job</code> to learn about
Slurms estimated start time</li>
</ul>
<p>Answer questions about number and type of CPUs, HT/SMT, memory/core,
timelimits.</p>
<p>Summarize with a well sized job that’s a good start for the
example.</p>
</div>
</div>
</div>
</section><section><h2 class="section-heading" id="requesting-resources">Requesting Resources<a class="anchor" aria-label="anchor" href="#requesting-resources"></a>
</h2>
<hr class="half-width">
<p>More detail about what <a href="https://slurm.schedmd.com/sbatch.html" class="external-link">Slurm provides</a> (among
others):</p>
<ul>
<li>
<code>-t, --time=&lt;time&gt;</code>: Time limit of the job</li>
<li>
<code>-N, --nodes</code>: Number of nodes</li>
<li>
<code>-n, --ntasks</code>: Number of tasks/processes</li>
<li>
<code>-c, --cpus-per-task</code>: Number of CPUs per
task/process</li>
<li>
<code>--threads-per-core=&lt;threads&gt;</code>: Select nodes with
at least the number threads per CPU</li>
<li>
<code>--mem=&lt;size&gt;[units]</code>: Memory, but can also be as
<code>--mem-per-cpu</code>, …</li>
<li>
<code>-G, --gpus</code>: Number of GPUs</li>
<li><code>--exclusive</code></li>
</ul>
<p>Maybe discuss:</p>
<ul>
<li>Minimizing/maximizing involved number of nodes
<ul>
<li>Shared nodes: longer waiting times until a whole node is empty</li>
<li>Min/max number of nodes min/maximizes communication</li>
</ul>
</li>
<li>Different wait times for certain configurations
<ul>
<li>Few tasks on many shared nodes might schedule faster than many tasks
on few exclusive nodes.</li>
</ul>
</li>
<li>What is a task / process – Difference?</li>
<li>Requesting memory, more than mem/core -&gt; idle cores</li>
</ul></section><section><h2 class="section-heading" id="changing-requirements">Changing requirements<a class="anchor" aria-label="anchor" href="#changing-requirements"></a>
</h2>
<hr class="half-width">
<ul>
<li>Motivate why requirements might change (resolution in simulation,
more data, more complex model, …)</li>
<li>How to change requested resources if application should run
differently? (e.g. more processes)</li>
<li>Considerations &amp; estimates for
<ul>
<li>changing compute-time (more/less workload)</li>
<li>changing memory requirements (smaller/larger model)</li>
<li>changing number of processes / nodes</li>
<li>changing I/O -&gt; more/less or larger/smaller files</li>
</ul>
</li>
</ul>
<div id="exercise-changing-requirements" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<span class="callout-header">Discussion</span>
<div id="exercise-changing-requirements" class="callout-inner">
<h3 class="callout-title">Exercise: Changing requirements</h3>
<div class="callout-content">
<ul>
<li>Walk through how to estimate increase in CPU cores / memory,
etc.</li>
<li>Run previous job with larger workload</li>
<li>Check if and how it behaves differently than the smaller job</li>
</ul>
</div>
</div>
</div>
</section><section><h2 class="section-heading" id="summary">Summary<a class="anchor" aria-label="anchor" href="#summary"></a>
</h2>
<hr class="half-width">
<div id="discussion-recollection" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<span class="callout-header">Discussion</span>
<div id="discussion-recollection" class="callout-inner">
<h3 class="callout-title">Discussion: Recollection</h3>
<div class="callout-content">
<p>Circle back to efficiency. What’s considered good/efficient in
context of job requirements and parameters?</p>
</div>
</div>
</div>
<p>Leading question: <code>time</code> doesn’t give much information, is
there an easy way to get more? -&gt; See what Slurm tools can tell about
our previous jobs</p>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<span class="callout-header">Key Points</span>
<div class="callout-inner">
<div class="callout-content">
<ul>
<li>Estimate resource requirements and request them in terms the
scheduler understands</li>
<li>Be aware of your job in relation to the whole system (available
hardware, size)</li>
<li>Aim for a good match between requested and utilized resources</li>
<li>Optimal time-to-solution by minimizing batch queue times and
maximizing parallelism</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</section></section><section id="aio-03_schedulertools"><p>Content from <a href="03_schedulertools.html">Scheduler Tools</a></p>
<hr>
<p>Last updated on 2025-11-11 |

        <a href="https://github.com/stderr-enst/jobefficiency/edit/main/episodes/03_schedulertools.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>What can the scheduler tell about job performance?</li>
<li>What’s the meaning of collected metrics?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<p>After completing this episode, participants should be able to …</p>
<ul>
<li>Explain basic performance metrics.</li>
<li>Use tools provided by the scheduler to collect basic performance
metrics of their jobs.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section><h2 class="section-heading" id="scheduler-tools">Scheduler Tools<a class="anchor" aria-label="anchor" href="#scheduler-tools"></a>
</h2>
<hr class="half-width">
<p>A scheduler performs important tasks such as accepting and scheduling
jobs, monitoring job status, starting user applications, cleaning up
jobs that have finished or exceeded their allocated time. The scheduler
also keeps a history of jobs that have been run and how they behaved.
The information that is collected can be queried by the job owner to
learn about how the job utilized the resources it was given.</p>
<div class="section level3">
<h3 id="the-seff-tool">The <code>seff</code> tool<a class="anchor" aria-label="anchor" href="#the-seff-tool"></a>
</h3>
<p>The <code>seff</code> command can be used to learn about how
efficiently your job has run. The <code>seff</code> command takes the
job identifier as an argument to select which job it displays
information about. That means we need to run a job first to get a job
identifier we can query SLURM about. Then we can ask about the
efficiency of the job.</p>
<div id="seff-may-not-be-available" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<span class="callout-header">Callout</span>
<div id="seff-may-not-be-available" class="callout-inner">
<h3 class="callout-title">
<code>seff</code> may not be available</h3>
<div class="callout-content">
<p><code>seff</code> is an optional SLURM tool for more convenient
access to <code>saact</code>. It does not come standard with every SLURM
installation. Your particular HPC system may or may not provide it.
Check for it’s availability on your login nodes, or consult your cluster
documentation or support staff.</p>
<p>Other third party alternatives, e.g. <a href="https://github.com/troycomi/reportseff/" class="external-link">reportseff</a>, can be
installed with default user permissions.</p>
</div>
</div>
</div>
<p>The <code>sbatch</code> command is used to submit a job. It takes a
job script as an argument. The job script contains the resource
requests, such as the amount of time needed for the calculation, the
number of nodes, the number of tasks per node, and so on. It also
contains the commands to execute the calculations.</p>
<p>Using your favorite editor, create the job script
<code>render_snowman.sbatch</code> with the contents below.</p>
<pre class="input"><code>#!/usr/bin/bash
#SBATCH --time=01:00:00
#SBATCH --nodes=1
#SBATCH --tasks-per-node=4

# Possibly a "module load ..." command to load required libraries
# Depends on your particular HPC system

mpirun -np 4 raytracer -width=800 -height=800 -spp=128 -alloc_mode=3</code></pre>
<p>Next submit the job with <code>sbatch</code>, and see what
<code>seff</code> says about the job with the following commands.</p>
<div class="codewrapper sourceCode" id="cb2">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="va">jobid</span><span class="op">=</span><span class="va">$(</span><span class="ex">sbatch</span> <span class="at">--parsable</span> render_snowman.sbatch<span class="va">)</span></span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a><span class="ex">seff</span> <span class="va">$jobid</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>Job ID: 309489
Cluster: bigiron
User/Group: usr123/grp123
State: COMPLETED (exit code 0)
Nodes: 1
Cores per node: 4
CPU Utilized: 00:07:43
CPU Efficiency: 98.93% of 00:07:48 core-walltime
Job Wall-clock time: 00:01:57
Memory Utilized: 35.75 MB
Memory Efficiency: 0.20% of 17.58 GB (4.39 GB/core)</code></pre>
</div>
<p>The job script we created asks for 4 CPUs for an hour. After
submitting the job script we need to wait until the job has finished as
<code>seff</code> can only report sensible statistics after the job is
completed. The report from <code>seff</code> shows basic statistics
about the job, such as</p>
<ul>
<li>The resources the job was given
<ul>
<li>the number of nodes</li>
<li>the number of cores per node</li>
<li>the amount of memory per core</li>
</ul>
</li>
<li>The amount of resources used
<ul>
<li>
<code>CPU Utilized</code> the aggregate CPU time (the time the job
took times the number of CPUs allocated)</li>
<li>
<code>CPU Efficiency</code> the actual CPU usage as a percentage of
the total available CPU capacity</li>
<li>
<code>Job Wall-clock time</code> the time the job took from start to
finish</li>
<li>
<code>Memory Utilized</code> the aggregate memory usage</li>
<li>
<code>Memory Efficiency</code> the actual memory usage as a
percentage of the total avaialable memory</li>
</ul>
</li>
</ul>
<p>Looking at the <code>Job Wall-clock time</code> it shows that the job
took just under 2 minutes. Therefore this job took a lot less time than
the one hour we asked for. This can be problematic as the scheduler
looks for time windows when it can fit a job in. Long running jobs
cannot be squeezed in as easily as short running jobs. As a result, jobs
that request a long time to complete typically have to wait longer
before they can be started. Therefore asking for more than 10 times as
much time as the job really needs, simply means that you will have to
wait longer for the job to start. On the other hand you do not want to
ask for too little time. Few things are more annoying than waiting for a
long running calculation to finish, just to see the job being killed
right before the end because it would have needed a couple of minutes
more than you asked for. So the best approach is to ask for more time
than the job needs, but not go overboard here. As the job elapse time
depends on many machine conditions, including congestion in the data
communication, disk access, operating system jitter, and so on, you
might want to ask for a substantial buffer. Nevertheless, asking for
more than twice as much time as job is expected to need, usually doesn’t
make sense.</p>
<p>Another thing is that SLURM by default reserves a certain amount of
memory per core. In this case the actual memory usage is just a fraction
of that amount. We could reduce the memory allocation by explicitly
asking for less by modifying the <code>render_snowman.sbatch</code> job
script.</p>

<div id="challenge1" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<span class="callout-header">Challenge</span>
<div class="callout-inner">
<h3 class="callout-title">Challenge</h3>
<div class="callout-content">
<p>Edit the batch file to reduce the amount of memory requested for the
job. Note that the amount of memory per node can be requested with the
<code>--mem=</code> argument. The amount of memory is specified by a
number followed by a unit. The units can represent kilobtytes (KB),
megabytes (MB), gigabytes (GB). For the calculations we are doing here
100 megabytes per node is more than sufficient. Submit the job, and
inspect the efficiency with <code>seff</code>. What is the memory usage
efficiency you get?</p>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1"> Show me the solution </h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" aria-labelledby="headingSolution1" data-bs-parent="#accordionSolution1">
<div class="accordion-body">
<p>The batch file after adding the memory request becomes.</p>
<pre class="input"><code>#!/usr/bin/bash
#SBATCH --time=01:00:00
#SBATCH --nodes=1
#SBATCH --tasks-per-node=4
#SBATCH --mem=100MB

# Possibly a "module load ..." command to load required libraries
# Depends on your particular HPC system

mpirun -np 4 raytracer -width=800 -height=800 -spp=128 -alloc_mode=3</code></pre>
<p>Submit this jobscript, as before, with the following command.</p>
<div class="codewrapper sourceCode" id="cb5">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a><span class="va">jobid</span><span class="op">=</span><span class="va">$(</span><span class="ex">sbatch</span> <span class="at">--parsable</span> render_snowman.sbatch<span class="va">)</span></span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a><span class="ex">seff</span> <span class="va">$jobid</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>Job ID: 310002
Cluster: bigiron
User/Group: usr123/grp123
State: COMPLETED (exit code 0)
Nodes: 1
Cores per node: 4
CPU Utilized: 00:07:43
CPU Efficiency: 98.09% of 00:07:52 core-walltime
Job Wall-clock time: 00:01:58
Memory Utilized: 50.35 MB
Memory Efficiency: 50.35% of 100.00 MB (100.00 MB/node)</code></pre>
</div>
<p>The output of <code>seff</code> shows that about 50% of requested
memory was used.</p>
</div>
</div>
</div>
</div>
<p>Now we see that a much larger fraction of the allocated memory has
been used. Normally you would not worry too much about the memory
request. Lately HPC clusters are used more for machine learning work
loads which tend to require a lot of memory. Their memory requirements
per core might actually be so large that they cannot use all the cores
in a node. So there may be spare cores available for jobs that need
little memory. In such a scenario tightening the memory allocation up
could allow the scheduler to start your job early. How much milage you
might get from this depends on the job mix at the HPC site where you run
your calculations.</p>
<p>Note that the CPU utilization is reported as almost 100%, but this
just means that the CPU was busy with your job 100% of the time. It does
not mean that this time was well spent. For example, every parallel
program has some serial parts to the code. Typically those parts are
executed redundantly on all cores, which is wasteful but not reflected
in the CPU efficiency. Also, this number does not reflect how well the
capabilities of the CPU are used. If your CPU offers vector
instructions, for example, but your code does not use them then your
code will just run slow. The CPU efficiency will still show that the CPU
was busy 100% of the time even though the program is just running at a
fraction of the speed it could achieve if it fully exploited the
hardware capabilities. It is worth keeping these limitations of
<code>seff</code> in mind.</p>
<div id="good-utilization-does-not-imply-efficiency" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<span class="callout-header">Callout</span>
<div id="good-utilization-does-not-imply-efficiency" class="callout-inner">
<h3 class="callout-title">Good utilization does not imply
efficiency</h3>
<div class="callout-content">
<p>Measuring close to 100% CPU utilization does not say anything about
how useful the calculations are. It’s merely stating, that the CPU was
mostly busy with calculations, instead of waiting for data or running
idle, waiting for other conditions to occur.</p>
<p>Good CPU utilization is only efficient, if it runs only “useful”
calculations that contribute with new results towards an intended
goal.</p>
</div>
</div>
</div>
<p>The <code>seff</code> command cannot give you any information about
the I/O performance of your job. You have to use other approaches for
that, and <code>sacct</code> may be one of them.</p>
</div>
<div class="section level3">
<h3 id="the-sacct-tool">The <code>sacct</code> tool<a class="anchor" aria-label="anchor" href="#the-sacct-tool"></a>
</h3>

<p>The <code>sacct</code> command shows data stored in the job
accounting database. You can query the data of any of your previously
run jobs. Just like with <code>seff</code> you will need to provide the
job ID to query the accounting database. Rather than keeping track of
all your jobs yourself you can ask <code>sacct</code> to provide you
with an overview of the jobs you have run.</p>
<div class="codewrapper sourceCode" id="cb7">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="ex">sacct</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>JobID           JobName  Partition    Account  AllocCPUS      State ExitCode
------------ ---------- ---------- ---------- ---------- ---------- --------
309902       render_sn+  STD-s-96h  project_a          4  COMPLETED      0:0
309902.batch      batch             project_a          4  COMPLETED      0:0
309902.exte+     extern             project_a          4  COMPLETED      0:0
309903       render_sn+  STD-s-96h  project_a          4  COMPLETED      0:0
309903.batch      batch             project_a          4  COMPLETED      0:0
309903.exte+     extern             project_a          4  COMPLETED      0:0
310002       render_sn+  STD-s-96h  project_a          4  COMPLETED      0:0
310002.batch      batch             project_a          4  COMPLETED      0:0
310002.exte+     extern             project_a          4  COMPLETED      0:0</code></pre>
</div>
<p>In the output every job is shown three times here. This is because
<code>sacct</code> lists one line for the primary job entry, followed by
a line for every job step. A job step corresponds to an
<code>mpirun</code> or <code>srun</code> command. The
<code>extern</code> line corresponds to all work that is done outside of
SLURM’s control, for example an <code>ssh</code> command that runs
something somewhere else.</p>
<p>Note that by default <code>sacct</code> only lists the jobs that have
been run today. You can use the <code>--starttime</code> option to list
all jobs that have been run since the given start date. For example, try
running</p>
<div class="codewrapper sourceCode" id="cb9">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a><span class="ex">sacct</span> <span class="at">--starttime</span><span class="op">=</span>2025-09-25</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>JobID           JobName  Partition    Account  AllocCPUS      State ExitCode
------------ ---------- ---------- ---------- ---------- ---------- --------
308755       snowman.s+  STD-s-96h  project_a         16  COMPLETED      0:0
308755.batch      batch             project_a         16  COMPLETED      0:0
308755.exte+     extern             project_a         16  COMPLETED      0:0
308756       snowman.s+  STD-s-96h  project_a          4  COMPLETED      0:0
308756.batch      batch             project_a          4  COMPLETED      0:0
308756.exte+     extern             project_a          4  COMPLETED      0:0
309486       interacti+  STD-s-96h  project_a          4     FAILED      1:0
309486.exte+     extern             project_a          4  COMPLETED      0:0
309486.0          prted             project_a          4  COMPLETED      0:0
309489       render_sn+  STD-s-96h  project_a          4  COMPLETED      0:0
309489.batch      batch             project_a          4  COMPLETED      0:0
309489.exte+     extern             project_a          4  COMPLETED      0:0
309902       render_sn+  STD-s-96h  project_a          4  COMPLETED      0:0
309902.batch      batch             project_a          4  COMPLETED      0:0
309902.exte+     extern             project_a          4  COMPLETED      0:0
309903       render_sn+  STD-s-96h  project_a          4  COMPLETED      0:0
309903.batch      batch             project_a          4  COMPLETED      0:0
309903.exte+     extern             project_a          4  COMPLETED      0:0
310002       render_sn+  STD-s-96h  project_a          4  COMPLETED      0:0
310002.batch      batch             project_a          4  COMPLETED      0:0
310002.exte+     extern             project_a          4  COMPLETED      0:0</code></pre>
</div>
<p>You may want to change the date of <code>2025-09-25</code> to
something more sensible when you work through this tutorial. Note that
some HPC systems may limit the range of such a request to a maximum of,
for example, 30 days to avoid overloading the slurm database with too
large requests.</p>
<p>With the job ID you can ask <code>sacct</code> for information about
a specific job as in</p>
<div class="codewrapper sourceCode" id="cb11">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a><span class="ex">sacct</span> <span class="at">--jobs</span><span class="op">=</span>310002</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>JobID           JobName  Partition    Account  AllocCPUS      State ExitCode
------------ ---------- ---------- ---------- ---------- ---------- --------
310002       render_sn+  STD-s-96h  project_a          4  COMPLETED      0:0
310002.batch      batch             project_a          4  COMPLETED      0:0
310002.exte+     extern             project_a          4  COMPLETED      0:0</code></pre>
</div>
<p>Using <code>sacct</code> with the <code>--jobs</code> flag is just
another way to select which jobs we want more information about. In
itself it does not provide any additional information. To get more
specific data we need to explicitly ask for the information we want. As
SLURM collects a broad range of data about every job it is worth to
evaluate what the most relevant items are.</p>

<ul>
<li>
<code>MaxRSS</code>, <code>AveRSS</code>, or the Maximum or Average
Resident Size Set (RSS). The RSS is the memory allocated by a program
that is actually resident in the main memory of the computer. If the
computer gets low on memory then the virtual memory manager can extend
the apparently available memory by moving some of the data from memory
to disk. This is done entirely transparently to the application, but the
data that has been moved to disk is no longer resident in main memory.
As a result accessing it will be slower because it needs to retrieved
from disk first. Therefore if the RSS is small compared to the total
amount of memory the program uses this might affect the performance of
the program.</li>
<li>
<code>MaxPages</code>, <code>AvePages</code>, or the Maximum or
Average number of Page Faults. These quantities are related to the
Resident Size Sets. When the program tries to access data that is not
resident in main memory this triggers a page fault. The virtual memory
manager responds to a page fault by retrieving the accessed data from
disk (and potentially migrating other data to disk to make space). These
operations are typically costly. Therefore high numbers of page faults
typically correspond to a significant reduction in the program’s
performance. For example, the CPU utilization might drop from as high as
98% to as low as 2% due to page faults. For that reason some HPC
machines are configured to kill your job if the application generates a
high rate of page faults.</li>
<li>
<code>AllocCPUS</code> is the number of CPUs allocated for the
job.</li>
<li>
<code>Elapsed</code> is the amount of wall clock time it took to
complete the job. I.e. the amount of time that passed between the start
and finish of the job.</li>
<li>
<code>MaxDiskRead</code>, the Maximum amount of data read from
disk.</li>
<li>
<code>MaxDiskWrite</code>, the Maximum amount of data written to
disk.</li>
<li>
<code>ConsumedEnergy</code>, the amount of energy consumed by the
job if that information was collected. The data may not be collected on
your particular HPC system and is reported as 0.</li>
<li>
<code>AveCPUFreq</code>, the average CPU frequency of all tasks in a
job, given in kHz. In general the higher the clock frequency of the
processor the faster the calculation runs. The exception is if the
application is memory bandwidth limited and the data cannot be moved to
processor fast enough to keep it busy. In that case modern hardware
might throttle the frequency. This saves energy as the power consumption
scales linearly with the clock frequency, but doesn’t slow the
calculation down as the processor was having to wait for data
anyway.</li>
</ul>
<p>We can explicitly select the data elements that we are interested in.
To see how long the job took to complete run</p>
<div class="codewrapper sourceCode" id="cb13">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a><span class="ex">sacct</span> <span class="at">--jobs</span><span class="op">=</span>310002 <span class="at">--format</span><span class="op">=</span>Elapsed</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code><span>   <span class="va">Elapsed</span></span>
<span><span class="op">-</span><span class="op">-</span><span class="op">-</span><span class="op">-</span><span class="op">-</span><span class="op">-</span><span class="op">-</span><span class="op">-</span><span class="op">-</span><span class="op">-</span></span>
<span>  <span class="fl">00</span><span class="op">:</span><span class="fl">01</span><span class="op">:</span><span class="fl">58</span></span>
<span>  <span class="fl">00</span><span class="op">:</span><span class="fl">01</span><span class="op">:</span><span class="fl">58</span></span>
<span>  <span class="fl">00</span><span class="op">:</span><span class="fl">01</span><span class="op">:</span><span class="fl">58</span></span></code></pre>
</div>
<div id="challenge2" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<span class="callout-header">Challenge</span>
<div class="callout-inner">
<h3 class="callout-title">Challenge</h3>
<div class="callout-content">
<p>Request information regarding all of the above variables from
<code>sacct</code>, including <code>JobID</code>. Note that the
<code>--format</code> flag takes a comma separated list. Also note that
the result shows that more data is read than written, even though the
program generates and write an image, and reads no data at all. Why
would that be?</p>
</div>
</div>
</div>
<div id="accordionSolution2" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution2" aria-expanded="false" aria-controls="collapseSolution2">
  <h4 class="accordion-header" id="headingSolution2"> Show me the solution </h4>
</button>
<div id="collapseSolution2" class="accordion-collapse collapse" aria-labelledby="headingSolution2" data-bs-parent="#accordionSolution2">
<div class="accordion-body">
<p>To query all of the above variable run</p>
<div class="codewrapper sourceCode" id="cb15">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a><span class="ex">sacct</span> <span class="at">--jobs</span><span class="op">=</span>310002 <span class="at">--format</span><span class="op">=</span>MaxRSS,AveRSS,MaxPages,AvePages,AllocCPUS,Elapsed,MaxDiskRead,MaxDiskWrite,ConsumedEnergy,AveCPUFreq</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>    MaxRSS     AveRSS MaxPages   AvePages  AllocCPUS    Elapsed  MaxDiskRead MaxDiskWrite ConsumedEnergy AveCPUFreq
---------- ---------- -------- ---------- ---------- ---------- ------------ ------------ -------------- ----------
                                                   4   00:01:58                                        0
    51556K     51556K      132        132          4   00:01:58        6.91M        0.72M              0         3M
         0          0        0          0          4   00:01:58        0.01M        0.00M              0         3M</code></pre>
</div>
<p>Although the program we have run generates an image and writes that
to a file, there is also a none zero amount of data read. The writing
part is associated with the image file the program writes. The reading
part is not associated with anything that the program does, as it
doesn’t read anything from disk. It is instead associated with the fact
that the operating system has to read the program itself and it’s
dependencies to execute it.</p>
</div>
</div>
</div>
</div>

</div>
</section><section><h2 class="section-heading" id="shortcomings">Shortcomings<a class="anchor" aria-label="anchor" href="#shortcomings"></a>
</h2>
<hr class="half-width">
<p>While <code>seff</code> and <code>sacct</code> provide a lot of
information it is still incomplete. For example, the information is
accumulated for the entire calculation. Variations in the metrics as a
function of time throughout the job are not available. Communication
between different MPI processes is not recorded. The collection of the
energy consumption depends on the hardware and system configuration at
the HPC center and might not be available. We are also often missing
reliable measurements for I/O via the interconnect between nodes and the
parallel file system.</p>
<p>So while we might be able to glean some indications for different
types of performance problems, for a proper analysis more detailed
information is needed.</p>
</section><section><h2 class="section-heading" id="summary">Summary<a class="anchor" aria-label="anchor" href="#summary"></a>
</h2>
<hr class="half-width">
<p>This episode introduced the SLURM tools <code>seff</code> and
<code>sacct</code> to get a high level perspective on a job’s
performance. As these tools just use the statistics that SLURM collected
on a job as it ran, they can always be used without any special
preparation.</p>
<div id="challenge3" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<span class="callout-header">Challenge</span>
<div class="callout-inner">
<h3 class="callout-title">Challenge</h3>
<div class="callout-content">
<p>So far we have considered our initial calculation using 4 cores. To
run the calculation faster we could consider using more cores. Run the
same calculation on 8, 16, and 32 cores as well. Collect and compare the
results from <code>sacct</code> and see how the job performance
changes.</p>
</div>
</div>
</div>
<div id="accordionSolution3" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution3" aria-expanded="false" aria-controls="collapseSolution3">
  <h4 class="accordion-header" id="headingSolution3"> Show me the solution </h4>
</button>
<div id="collapseSolution3" class="accordion-collapse collapse" aria-labelledby="headingSolution3" data-bs-parent="#accordionSolution3">
<div class="accordion-body">
<p>The machine these calculations have been run on has 112 core per
node. So we can double the number of cores from 4 until 64 and stay
within one node. If we go to two nodes then some of the communication
between tasks will have to go across the interconnect. At that point the
performance characteristics might change in a discontinuous manner.
Hence we try to avoid doing that.</p>
<p>Alternatively you might scale the calculation across multiple nodes,
for example 2, 4, 8, 16 nodes. With 112 cores per node you would have to
make sure that the calculation is large enough for such a large number
of cores to make sense.</p>
<p>Create <code>running_snowmen.sh</code> with</p>
<pre class="input"><code>#!/usr/bin/bash
for nn in 4 8 16 32; do
    id=`sbatch --parsable --time=00:12:00 --nodes=1 --tasks-per-node=$nn --ntasks-per-core=1 render_snowman.sh`
    echo "ntasks $nn jobid $id"
done</code></pre>
<p>Create <code>render_snowman.sh</code> with</p>
<pre class="input"><code>#!/usr/bin/bash

# Possibly a "module load ..." command to load required libraries
# Depends on your particular HPC system

export START=`pwd`
# Create a sub-directory for this job if it doesn't exist already
mkdir -p $START/test.$SLURM_NTASKS
cd $START/test.$SLURM_NTASKS
# The -spp flag ensures we have enough samples per ray such that the job
# on 32 cores takes longer than 30s. Slurm by default is configured such
# that job data is collected every 30s. If the job finishes in less than
# that Slurm might fail to collect some of the data about the job.
mpirun -np $SLURM_NTASKS raytracer -width=800 -height=800 -spp 1024 -threads=1 -alloc_mode=3 -png=rendered_snowman.png</code></pre>
<p>Next we submit this whole set of calculations</p>
<div class="codewrapper sourceCode" id="cb19">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb19-1"><a href="#cb19-1" tabindex="-1"></a><span class="ex">./running_snowmen.sh</span></span></code></pre>
</div>
<p>producing</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>ntasks 4 jobid 349291
ntasks 8 jobid 349292
ntasks 16 jobid 349293
ntasks 32 jobid 349294</code></pre>
</div>
<p>After the jobs are completed we can run</p>
<div class="codewrapper sourceCode" id="cb21">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb21-1"><a href="#cb21-1" tabindex="-1"></a><span class="ex">sacct</span> <span class="at">--jobs</span><span class="op">=</span>349291,349292,349293,349294 <span class="dt">\</span></span>
<span id="cb21-2"><a href="#cb21-2" tabindex="-1"></a>      <span class="at">--format</span><span class="op">=</span>MaxRSS,AveRSS,MaxPages,AvePages,AllocCPUS,Elapsed,MaxDiskRead,MaxDiskWrite,ConsumedEnergy,AveCPUFreq</span></code></pre>
</div>
<p>to produce</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>    MaxRSS     AveRSS MaxPages   AvePages  AllocCPUS    Elapsed  MaxDiskRead MaxDiskWrite ConsumedEnergy AveCPUFreq
---------- ---------- -------- ---------- ---------- ---------- ------------ ------------ -------------- ----------
                                                   4   00:09:35                                        0
   142676K    142676K        1          1          4   00:09:35        7.75M        0.72M              0       743K
         0          0        0          0          4   00:09:35        0.01M        0.00M              0      2.61M
                                                   8   00:05:01                                        0
   289024K    289024K        0          0          8   00:05:01       10.15M        1.45M              0       960K
         0          0        0          0          8   00:05:02        0.01M        0.00M              0      2.42M
                                                  16   00:02:21                                        0
   563972K    563972K       93         93         16   00:02:21       15.00M        2.94M              0      1.03M
         0          0        0          0         16   00:02:21        0.01M        0.00M              0      2.99M
                                                  32   00:01:14                                        0
  1082540K   1082540K      260        260         32   00:01:14       24.83M        6.07M              0      1.08M
         0          0        0          0         32   00:01:14        0.01M        0.00M              0         3M</code></pre>
</div>
<p>Note that the elapse time goes down as the number of cores increases,
which is reasonable as more cores normally can get the job done quicker.
The amount of data read also increases as every MPI rank has to read the
executable and all associated shared libraries. The volume of data
written is harder to understand. Every run produces an image file
<code>rendered_snowman.png</code> that is about 100KB in size. This file
is written just by the root MPI rank. This cannot explain the increase
in data written with increasing numbers of cores. The increasing number
of page faults with increasing numbers of cores suggests that paging
memory to disk is responsible for the majority of data written.</p>
</div>
</div>
</div>
</div>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<span class="callout-header">Key Points</span>
<div class="callout-inner">
<div class="callout-content">
<ul>
<li>Schedulers provide tools for a high level view on our jobs,
e.g. <code>sacct</code> and <code>seff</code>
</li>
<li>Important basic performance metrics we can gather this way are:
<ul>
<li>
<strong>CPU Utilization</strong>, often as fraction of
<code>time where CPU was active</code>/<code>elapsed time of the job</code>
</li>
<li>
<strong>Memory utilization</strong>, often measured as <em>Resident
Set Size</em> (RSS) and number of <em>Pages</em>
</li>
</ul>
</li>
<li>
<code>sacct</code> can also provide metrics about disk I/O and
energy consumption</li>
<li>Metrics through <code>sacct</code> are accumulated for the whole job
runtime and may be too broad for more specific insight</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</section></section><section id="aio-04_scalingstudy"><p>Content from <a href="04_scalingstudy.html">Scaling Study</a></p>
<hr>
<p>Last updated on 2025-11-26 |

        <a href="https://github.com/stderr-enst/jobefficiency/edit/main/episodes/04_scalingstudy.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>How many resources should be requested for a given job?</li>
<li>How does our application behave at different scales?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<p>After completing this episode, participants should be able to …</p>
<ul>
<li>Perform a scaling study for a given application.</li>
<li>Notice different perspectives on scaling parameters.</li>
<li>Identify good working points for the job configuration.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<p>The deadline is approaching way too fast and we may not finish our
project in time. Maybe requesting more resources from our clusters
scheduler does the trick? How could we know if it helps and by how
much?</p>
<section><h2 class="section-heading" id="what-is-scaling">What is Scaling?<a class="anchor" aria-label="anchor" href="#what-is-scaling"></a>
</h2>
<hr class="half-width">
<p>The execution time of parallel applications changes with the number
of parallel processes or threads. In a <em>scaling study</em> we measure
how much the execution time changes by scanning a reasonable range of
number of processes. In a common phrasing, this approach answers how the
execution time <em>scales</em> with the number of parallel
processors.</p>
<p>Starting from the job script <code>render_snowman.sbatch</code>:</p>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="co">#!/usr/bin/bash</span></span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="co">#SBATCH --time=01:00:00</span></span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a><span class="co">#SBATCH --nodes=1</span></span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a><span class="co">#SBATCH --mem=2GB</span></span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a><span class="ex">module</span> load 2025 GCC/13.2.0 OpenMPI/4.1.6 buildenv/default Boost/1.83.0 CMake/3.27.6 libpng/1.6.40</span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a><span class="bu">time</span> mpirun <span class="at">-n</span> <span class="va">${SLURM_NTASKS}</span> ./build/raytracer <span class="at">-width</span><span class="op">=</span>1024 <span class="at">-height</span><span class="op">=</span>1024 <span class="at">-spp</span><span class="op">=</span>256 <span class="at">-png</span> <span class="st">"</span><span class="va">$(</span><span class="fu">date</span> +%Y-%m-%d_%H%M%S<span class="va">)</span><span class="st">.png"</span></span></code></pre>
</div>
<p>we can manually run such a scaling study by submitting multiple jobs.
Here we use the environment variable <code>${SLURM_NTASKS}</code>, which
is set by Slurm to the number of tasks during job submission. Let’s
start some measurements:</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>$ sbatch --ntasks 1 render_snowman.sbatch
Submitted batch job 15462593
$ sbatch --ntasks 2 render_snowman.sbatch
Submitted batch job 15462596
$ sbatch --ntasks 4 render_snowman.sbatch
Submitted batch job 15462597
$ sbatch --ntasks 8 render_snowman.sbatch
Submitted batch job 15462598</code></pre>
</div>
<p>Now we have to wait until all four jobs are finished.</p>
<div id="regular-update-of-squeue" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<span class="callout-header">Callout</span>
<div id="regular-update-of-squeue" class="callout-inner">
<h3 class="callout-title">Regular update of <code>squeue</code>
</h3>
<div class="callout-content">
<p>You can use <code>squeue --me -i 30</code> to get an update of all of
your jobs every 30 seconds.</p>
<p>If you don’t need a more regular update, it is good practice to keep
the interval on the order of 30s to a couple of minutes. This will ease
the load on the Slurm servers in situations where potentially hundreds
of users access the information for many thousand jobs at the same
time.</p>
</div>
</div>
</div>
<p>Once the jobs are finished, we can use <code>grep</code> to get the
wall clock time of all four jobs:</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>$ grep "real" slurm-1546259*.out
slurm-15462593.out:real	6m52.719s
slurm-15462596.out:real	3m24.359s
slurm-15462597.out:real	1m41.754s
slurm-15462598.out:real	0m51.534s</code></pre>
</div>
<p>The real-, wallclock-, time is decreasing significantly each time we
double the number of Slurm tasks. From this, we feel that doubling the
number of CPU cores really is a winning strategy!</p>

<div id="exercise-continue-scaling-study-to-larger-values" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<span class="callout-header">Challenge</span>
<div id="exercise-continue-scaling-study-to-larger-values" class="callout-inner">
<h3 class="callout-title">Exercise: Continue scaling study to larger
values</h3>
<div class="callout-content">
<p>Run the same scaling study and continue it for even larger number of
<code>--ntasks</code>, e.g. 16, 32, 64, 128. So far, we have been using
<code>--nodes=1</code> to stay on a single node. At which point are your
MPI processes distributed across more than one node? Use Slurm
commandline tools to find out the how many CPU cores – in our case
equivalent to the number of one-core MPI processes – are available on a
single node. You may have to increase the number of nodes
<code>--nodes</code>, if you want to go beyond that limitation.</p>
<p>Gather your <code>real</code> time results and place them in a
<code>.csv</code> file. Here is an example for our previous
measurements:</p>
<pre class="csv"><code>ntasks,time
1,412.719
2,204.359
4,101.754
8,51.534
...</code></pre>
<p>How much does each doubling of the CPU resources help with running
the parallel raytracer? You can also use <code>seff</code> to answer
that question!</p>
<p>COMPARE <code>real</code> TIME WITH JOB WALLCLOCK TIMES! DECIDE WHAT
TO GO WITH!</p>
</div>
</div>
</div>
<div id="accordionHint1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button hint-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseHint1" aria-expanded="false" aria-controls="collapseHint1">
  <h4 class="accordion-header" id="headingHint1"> Give me a hint </h4>
</button>
<div id="collapseHint1" class="accordion-collapse collapse" data-bs-parent="#accordionHint1" aria-labelledby="headingHint1">
<div class="accordion-body">
<p>You can use <code>sinfo</code> to find out the node names of your
particular Slurm partition. Then use <code>scontrol</code> to show all
details about a single node from that partition. It will show you the
number of CPU (cores) available on that node.</p>
</div>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1"> Show me the solution </h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" data-bs-parent="#accordionSolution1" aria-labelledby="headingSolution1">
<div class="accordion-body">
<p>PUT RESULTING TIMES HERE!</p>
<p>Adding more resources does not help indefinitely. At some point the
overhead of managing the calculation in separate tasks outweighs the
benefit of parallel calculation. There is too little to do in each tasks
and the overhead starts to dominate.</p>
<p>With <code>seff</code> and <code>grep</code> we can see a lower CPU
efficiency with each doubling of the number of tasks:</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>$ for jobid in 15462593 15462596 15462597 15462598; do seff $jobid&amp;&amp; echo "" ; done | grep "CPU Efficiency"
CPU Efficiency: 97.85% of 00:06:59 core-walltime
CPU Efficiency: 95.73% of 00:07:02 core-walltime
CPU Efficiency: 91.90% of 00:07:12 core-walltime
CPU Efficiency: 84.27% of 00:07:44 core-walltime</code></pre>
</div>
<p>So at some point adding more CPU cores will not help us.</p>
</div>
</div>
</div>
</div>

<p>Adding more CPU cores can actively slow down the calculation after a
certain point. The optimal point is different for each application and
each configuration. It depends on the ratio between calculations,
communications and various management overheads in the whole process of
running everything.</p>
<div id="overheads-and-reliable-measurements" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<span class="callout-header">Callout</span>
<div id="overheads-and-reliable-measurements" class="callout-inner">
<h3 class="callout-title">Overheads and Reliable Measurements</h3>
<div class="callout-content">
<p>Many overheads and when they show also depend on the underlying
hardware. So the sweet spot may very well be different for different
clusters, even if the application and configuration stays the same!</p>
<p>Another common issue lies within our measurements themself. We
perform a single time measurement on a worker node that is possibly
shared with other jobs at the same time. What if another user runs an
application that hogs shared resources like the local disk or network
interface card? In this case our measurements become somewhat
non-deterministic. Running the same measurement twice may result in
significantly different values. If you need reliable results, e.g. for a
publication, requesting exclusive access to Slurms resources through the
<code>sbatch</code> flag <code>--exclusive</code> is the best approach.
As a drawback, this typically results in longer waiting times, since
whole nodes have to be reserved for the measurement jobs, even if not
all resources are used.</p>
<p>Even on exclusive resources, the measurements cannot be 100%
reliable. For example, the scheduling behavior of the Linux kernel, or
access to remote resources like the parallel file system or data from
the web, are still affecting your measurements in unpredictable ways.
Therefore, the best results are achieved by taking the mean and standard
deviations of repeated measurements for the same configuration. The
measured minimum also has strong informative value, since it proofs the
best observed behavior.</p>
</div>
</div>
</div>
<p>A scaling study can in fact be done with respect to different
application parameters and circumstances. For example, what is the
execution time when we change the <em>workload</em>, e.g. a larger
number of pixels, samples per pixels, or a more complex scene? How much
does a communication overhead change, if we change the number of
involved nodes while keeping the workload and number of tasks fixed,
i.e. changing the <em>network communication surface</em>? Different
scaling studies like these can help to identify pressure points that
affect the applications performance.</p>
<p>Scaling studies typically occur in a <em>preparation phase</em> where
the application is evaluated with a representative example workload.
Once a good configuration is found, we know the application is running
close to an optimal performance and larger number of calculations can
start, often called the <em>production phase</em>.</p>
<p>In a similar vein, scaling studies can be a formal requirement for
compute time applications on larger HPC systems. On these systems and
for larger calculation campaigns it is more crucial to run efficient
calculations, since the resources are typically more contested and the
potential energy- and carbon footprint becomes much larger.</p>
</section><section><h2 class="section-heading" id="speedup-efficiency-and-strong-scaling">Speedup, Efficiency, and Strong Scaling<a class="anchor" aria-label="anchor" href="#speedup-efficiency-and-strong-scaling"></a>
</h2>
<hr class="half-width">
<p>To quantitatively and empirically study the scaling behavior of a
given application, it is common to look at the <em>speedup</em> and
<em>efficiency</em> <em>Speedup</em> is a metric to compare the
execution times with different amounts of resources. It answers the
question</p>
<blockquote>
<p>How much faster is the application with <span class="math inline">\(N\)</span> parallel processes (threads), compared
to the serial execution with <span class="math inline">\(1\)</span>
process (threads)?</p>
</blockquote>
<p>It is defined by the comparison of wall times <span class="math inline">\(T(N)\)</span> of the application with <span class="math inline">\(N\)</span> parallel processes: <span class="math display">\[S(N) = \frac{T(1)}{T(N)}\]</span> Here, <span class="math inline">\(T(1)\)</span> is the wall time for a sequential
execution, and <span class="math inline">\(T(N)\)</span> is the
execution with <span class="math inline">\(N\)</span> parallel
processes.</p>
<p><em>Efficiency</em> in this context is defined as <span class="math display">\[\eta(N) = \frac{S(N)}{N}\]</span> with speedup
<span class="math inline">\(S(N)\)</span> and describes by how much
additional parallel processes, <span class="math inline">\(N\)</span>,
deviate from the theoretical linear optimum.</p>
<div id="exercise-calculate-speedup-and-efficency" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<span class="callout-header">Discussion</span>
<div id="exercise-calculate-speedup-and-efficency" class="callout-inner">
<h3 class="callout-title">Exercise: Calculate Speedup and Efficency</h3>
<div class="callout-content">
<p>RUN WITH WALL-CLOCK TIMES &amp; CPU EFFICIENCY INSTEAD!</p>
<pre class="csv"><code>ntasks,time,speedup,efficiency
1,412.719,1.00,1.00
2,204.359,2.02,1.01
4,101.754,4.06,1.015
8,51.534,8.01,1.00125
...</code></pre>
</div>
</div>
</div>
<p>So far, we kept the workload size fixed to <span class="math inline">\(1024 \times 1024\)</span> pixels and <span class="math inline">\(256\)</span> samples per pixel for the same scene
with three snowmen. The diminishing returns for adding more and more
parallel processors leads to a famous observation. The speedup of a
program through parallelization is limited by the execution time of the
serial fraction that is not parallelizable. No application is 100%
parallelizable, so adding an arbitrary amount of parallel processors can
only affect the parallelizable section. In the best case, the execution
time gets reduced to the serial fraction of the application.</p>
<p>An application is said to <em>scale strongly</em>, if adding more
cores significantly reduces the execution time.</p>
<p>INSERT PICTURES OF AMDAHLS FRACTIONS HERE</p>
<div id="amdahls-law" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<span class="callout-header">Callout</span>
<div id="amdahls-law" class="callout-inner">
<h3 class="callout-title">Amdahls Law<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>
</h3>
<div class="callout-content">
<p>The speedup of a program through parallelization is limited by the
execution time of the serial fraction that is not parallelizable.
Speedup <span class="math inline">\(S\)</span>, with <span class="math inline">\(N\)</span> processors, <span class="math inline">\(s\)</span> the time for the serial fraction, and
<span class="math inline">\(p\)</span>, the time for parallel fraction:
<span class="math display">\[S(N) = \frac{s+p}{s+\frac{p}{N}} =
\frac{1}{s + \frac{p}{N}} \Rightarrow \lim_{N\rightarrow \infty}  S(N) =
\frac{1}{s}\]</span></p>
</div>
</div>
</div>
<div id="exercise-speedup-and-efficiency" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<span class="callout-header">Discussion</span>
<div id="exercise-speedup-and-efficiency" class="callout-inner">
<h3 class="callout-title">Exercise: Speedup and Efficiency</h3>
<div class="callout-content">
<p>Plot results (Black board, prepared python script, piece of paper?)
Draw speedup &amp; efficiency vs. <span class="math inline">\(N\)</span>
Plot efficiency and make a guess when adding more cores is not worth
it.</p>
</div>
</div>
</div>
<div id="discussion-when-should-we-stop-adding-cpu-cores" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<span class="callout-header">Discussion</span>
<div id="discussion-when-should-we-stop-adding-cpu-cores" class="callout-inner">
<h3 class="callout-title">Discussion: When should we stop adding CPU
cores?</h3>
<div class="callout-content">
<p>Discuss the previous (potentially subjective) results and decide on a
good approach in the group.</p>
<p>Depends on X, Y, and Z. Could be around #N cores. It’s an
optimization problem!</p>
</div>
</div>
</div>
</section><section><h2 class="section-heading" id="if-scaling-is-limited-why-are-there-larger-hpc-systems">If scaling is limited, why are there larger HPC systems?<a class="anchor" aria-label="anchor" href="#if-scaling-is-limited-why-are-there-larger-hpc-systems"></a>
</h2>
<hr class="half-width">
<p>We observed that for a fixed problem size adding more parallel
processors can only help up to a certain point. But what if the project
benefits from increasing the workload size? Does a higher resolution,
more accuracy, or more statistics, etc., improve our insights and
results? If that is the case, the perspective on the issue changes and
adding more parallel processors can become more feasible as well. For
our raytracer example, increasing the workload corresponds to more
pixels, more samples per pixel, and/or a more complex scene.</p>
<p><em>Weak scaling</em> refers to the scaling behavior of an
application for a fixed workload per parallel processing unit,
e.g. increasing the number of pixels by the same amount as the number of
parallel processors <span class="math inline">\(N\)</span>.</p>
<div id="gustafsons-law" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<span class="callout-header">Callout</span>
<div id="gustafsons-law" class="callout-inner">
<h3 class="callout-title">Gustafsons Law<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>
</h3>
<div class="callout-content">
<p>A program scales on <span class="math inline">\(N\)</span> parallel
processors, if the problem size also scales with the number of
processors. The speedup <span class="math inline">\(S\)</span> becomes
<span class="math display">\[\text{S(N)} = \frac{s+pN}{s+p} = s+pN =
N+s(1-N)\]</span> with <span class="math inline">\(N\)</span>
processors, <span class="math inline">\(s\)</span> the time for the
serial fraction, and <span class="math inline">\(p\)</span>, the time
for parallel fraction:</p>
</div>
</div>
</div>
<p>To scale the workload of the snowmen raytracer, we can multiply the
number of parallel MPI processes, <code>${SLURM_NTASKS}</code>, with the
intended samples per pixel (<code>-spp=256</code>). For a single
process, the whole <span class="math inline">\(1024 \times 1024\)</span>
pixel picture is calculated in a single MPI process with 256 per pixel.
Running with two MPI processes, both have to calculate half the number
of pixels, but twice the amount of samples per pixel.</p>
<div class="codewrapper sourceCode" id="cb7">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="co">#!/usr/bin/bash</span></span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a><span class="co">#SBATCH --time=01:00:00</span></span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a><span class="co">#SBATCH --nodes=1</span></span>
<span id="cb7-4"><a href="#cb7-4" tabindex="-1"></a><span class="co">#SBATCH --mem=2GB</span></span>
<span id="cb7-5"><a href="#cb7-5" tabindex="-1"></a></span>
<span id="cb7-6"><a href="#cb7-6" tabindex="-1"></a><span class="ex">module</span> load 2025 GCC/13.2.0 OpenMPI/4.1.6 buildenv/default Boost/1.83.0 CMake/3.27.6 libpng/1.6.40</span>
<span id="cb7-7"><a href="#cb7-7" tabindex="-1"></a></span>
<span id="cb7-8"><a href="#cb7-8" tabindex="-1"></a><span class="va">SPP</span><span class="op">=</span><span class="st">"$[</span><span class="va">${SLURM_NTASKS}</span><span class="st">*256]"</span></span>
<span id="cb7-9"><a href="#cb7-9" tabindex="-1"></a></span>
<span id="cb7-10"><a href="#cb7-10" tabindex="-1"></a><span class="bu">time</span> mpirun <span class="at">-n</span> <span class="va">${SLURM_NTASKS}</span> ./build/raytracer <span class="at">-width</span><span class="op">=</span>1024 <span class="at">-height</span><span class="op">=</span>1024 <span class="at">-spp</span><span class="op">=</span><span class="va">${SPP}</span> <span class="at">-png</span> <span class="st">"</span><span class="va">$(</span><span class="fu">date</span> +%Y-%m-%d_%H%M%S<span class="va">)</span><span class="st">.png"</span></span></code></pre>
</div>
<p>Increasing the samples per pixels can be a qualitative improvement to
the final result, since more effort is put into the calculation of the
raytraced picture. In practice, there is a cutoff, beyond which no
reasonable improvement is to be expected. This is a question about
accuracy, error margins, and overall quality, which can only be answered
in the specific context of each research project. If there is no real
improvement by increasing the workload, running a weakly scaling
application is really just wasting valuable computational time and
energy.</p>
<div id="exercise-weak-scaling" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<span class="callout-header">Challenge</span>
<div id="exercise-weak-scaling" class="callout-inner">
<h3 class="callout-title">Exercise: Weak scaling</h3>
<div class="callout-content">
<p>Repeat the previous scaling study and increase the samples per pixel
accordingly to study the raytracers weak scaling behavior.</p>
<ul>
<li>Run with 1, 2, 4, 8, 16, 32, 64 MPI processes on single node</li>
<li>Increase the samples per pixel by the same fraction</li>
<li>Take <code>time</code> measurements and consider running with
<code>--exclusive</code> to ensure more reliable results.</li>
<li>Create a <code>.csv</code> file and run the plotting script</li>
</ul>
<p>UPDATE CSV AND PLOTTING</p>
<pre class="csv"><code>ntasks,spp,time,speedup,efficiency
1,256,
2,512,
4,1024,
...</code></pre>
<p>How well does the application scale with an increasing workload size?
Do you see a qualitative difference in the resulting <code>.png</code>
files and is the increased sample-per-pixel size worth the computational
costs?</p>
</div>
</div>
</div>
<div id="accordionSolution2" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution2" aria-expanded="false" aria-controls="collapseSolution2">
  <h4 class="accordion-header" id="headingSolution2"> Show me the solution </h4>
</button>
<div id="collapseSolution2" class="accordion-collapse collapse" data-bs-parent="#accordionSolution2" aria-labelledby="headingSolution2">
<div class="accordion-body">
<p>INCLUDE CSV AND PLOTTED PICTURE COMPARE SPP PNGS HERE, IS IT WORTH
IT?</p>
</div>
</div>
</div>
</div>
</section><section><h2 class="section-heading" id="summary">Summary<a class="anchor" aria-label="anchor" href="#summary"></a>
</h2>
<hr class="half-width">
<p>In this episode, we have seen that we can study the <em>scaling</em>
behavior of our application with respect to different metrics, while
varying its configuration. Most commonly, we study the execution time of
an application with an increasing number of parallel processors. In such
a scaling study, we collect comparable walltime measurements for an
increasing number of Slurm tasks of a parallelizable and representative
job. If a good working point is found, larger scale “production” jobs
can be submitted to the HPC system.</p>
<p>If the application has good <em>strong scaling</em> behavior, adding
more cores leads to an effective improvement in execution time. We
observe diminishing returns of adding more cores to a fixed-size
problem, so there is an optimal number of parallel processors for a
given application configuration. (Amdahls Law)</p>
<p>If increasing the workload size leads to better results, because of
improved accuracy and quality, that can be used in the project at hand,
we can study the <em>weak scaling</em> behavior and increase the
workload size by the same factor of increasing parallel processors.</p>
<p>A good working point depends on the availability of resources,
specifics of the underlying hardware, the particular application, and a
particular configuration for the application. For that reason, scaling
studies are a common requirement for formal compute time applications to
prove an efficient execution of a given application.</p>
<p>We can study the impact of any parameter on metrics like, for
example, walltime, CPU utilization, FLOPS, memory utilization,
communication, output size on disk, and so on.</p>
<div id="accordionSpoiler1" class="accordion spoiler-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button spoiler-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSpoiler1" aria-expanded="false" aria-controls="collapseSpoiler1">
  <h3 class="accordion-header" id="headingSpoiler1">  <div class="note-square"><i aria-hidden="true" class="callout-icon" data-feather="eye"></i></div> Automating Scaling Studies </h3>
</button>
<div id="collapseSpoiler1" class="accordion-collapse collapse" data-bs-parent="#accordionSpoiler1" aria-labelledby="headingSpoiler1">
<div class="accordion-body">
<p>If you find yourself repeating similar measurements over and over
again, you may be interested in an automation approach. This can be done
by creating <a href="https://carpentries-incubator.github.io/hpc-workflows-jube/" class="external-link">reproducible
HPC workflows using JUBE</a>, among other things.</p>
</div>
</div>
</div>
</div>
<p>Up to now, we were still working with basic metrics like the
wall-clock time. In the next episode, we start with more in-depth
measurements of many other aspects of our job and application.</p>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<span class="callout-header">Key Points</span>
<div class="callout-inner">
<div class="callout-content">
<ul>
<li>Jobs behave differently with increasing parallel resources and fixed
or scaling workloads</li>
<li>Scaling studies can help to quantitatively grasp this changing
behavior</li>
<li>Good working points are defined by configurations where more cores
still provide sufficient speedup or improve quality through increasing
workloads</li>
<li>Amdahl’s law: speedup is limited by the serial fraction of a
program</li>
<li>Gustafson’s law: more resources for parallel processing still help,
if larger workloads can meaningfully contribute to project results</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</section><div class="footnotes footnotes-end-of-document">
<hr>
<ol>
<li id="fn1"><p>G. M. Amdahl, ‘Validity of the single processor approach
to achieving large scale computing capabilities’, in Proceedings of the
April 18-20, 1967, spring joint computer conference, in AFIPS ’67
(Spring). New York, NY, USA: Association for Computing Machinery,
Apr. 1967, pp. 483–485. doi: 10.1145/1465482.1465560.<a href="#fnref1" class="footnote-back">↩︎</a></p></li>
<li id="fn2"><p>J. L. Gustafson, ‘Reevaluating Amdahl’s law’, Commun.
ACM, vol. 31, no. 5, pp. 532–533, May 1988, doi: 10.1145/42411.42415.<a href="#fnref2" class="footnote-back">↩︎</a></p></li>
</ol>
</div></section><section id="aio-05_performancereports"><p>Content from <a href="05_performancereports.html">Performance Overview</a></p>
<hr>
<p>Last updated on 2025-11-11 |

        <a href="https://github.com/stderr-enst/jobefficiency/edit/main/episodes/05_performancereports.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>Is it enough to look at a jobs walltime?</li>
<li>What steps can I take to evaluate a jobs performance?</li>
<li>What popular types of reports exist?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<p>After completing this episode, participants should be able to …</p>
<ul>
<li>Explain different approaches to performance measurements.</li>
<li>Understand common terms and concepts in performance analyses.</li>
<li>Create a performance report through a third-party tool.</li>
<li>Describe what a performance report is meant for (establish baseline,
documentation of issues and improvements through optimization,
publication of results, finding the next thread to pull in a quest for
optimization)</li>
<li>Measure the performance of central components of underlying hardware
(CPU, Memory, I/O, …) (split episode?)</li>
<li>Identify which general areas of computer hardware may affect
performance.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section><h2 class="section-heading" id="workflow">Workflow<a class="anchor" aria-label="anchor" href="#workflow"></a>
</h2>
<hr class="half-width">
<ul>
<li>Previously checked scaling behavior by looking at walltime</li>
<li>what if we would count other things while our job is running? Could
be
<ul>
<li>CPU utilization</li>
<li>FLOPS</li>
<li>Memory uitilization</li>
<li>…</li>
</ul>
</li>
<li>Two possible ways to look at this data with respect to time:
<ol style="list-style-type: decimal">
<li>
<em>tracing</em>: over time</li>
<li>
<em>sampling</em>: accumulated results at the end</li>
</ol>
</li>
<li>Third-party tools to measure these things - you can use them with
your jobs</li>
</ul>
<div id="callout1" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<span class="callout-header">Callout</span>
<div class="callout-inner">
<div class="callout-content">
<p>Here you can choose between three alternative perspectives on our
job:</p>
<ol style="list-style-type: decimal">
<li>
<a href="https://clustercockpit.org/" class="external-link"><em>ClusterCockpit</em></a>: A
job monitoring service available on many of our clusters. Needs to be
centrally maintained by your HPC administration team.</li>
<li>
<a href="https://docs.linaroforge.com/25.0.4/html/forge/performance_reports/index.html" class="external-link"><em>Linaro
Forge Performance Reports</em></a>: A commercial application providing a
single page performance overview of your job. Your cluster may have
licenses available.</li>
<li>
<em>TBD</em>: A free, open source tool/set of tools, to get a
general performance overview of your job.</li>
</ol>
<p>Performance counters and permissions, may require
<code>--exclusive</code>, depends on system! Look at documentation /
talk to your administrators / support.</p>
<pre><code>cap_perfmon,cap_sys_ptrace,cap_syslog=ep
kernel.perf_event_paranoid</code></pre>
</div>
</div>
</div>
<p>Live coding:</p>
<ul>
<li>Set up the main tool. How do I access it? How can I use it with my
job?</li>
<li>Run snowman with 8 cores</li>
</ul>
<div class="tabs">
<nav><div id="nav-tab-1" class="nav nav-tabs" role="tablist">
<button class="nav-link active" id="nav-tab-1-ClusterCockpit" name="ClusterCockpit" data-bs-toggle="tab" data-bs-target="#nav-tabpanel-1-ClusterCockpit" type="button" role="tab" aria-controls="nav-tabpanel-1-ClusterCockpit" aria-selected="true">
  <h3 class="tab-header" id="nav-tab-heading-1-ClusterCockpit">
  ClusterCockpit
  </h3>
</button>
<button class="nav-link" id="nav-tab-1-PerformanceReports" name="PerformanceReports" data-bs-toggle="tab" data-bs-target="#nav-tabpanel-1-PerformanceReports" type="button" role="tab" aria-controls="nav-tabpanel-1-PerformanceReports" aria-selected="false">
  <h3 class="tab-header" id="nav-tab-heading-1-PerformanceReports">
  Performance Reports
  </h3>
</button>
<button class="nav-link" id="nav-tab-1-TBD" name="TBD" data-bs-toggle="tab" data-bs-target="#nav-tabpanel-1-TBD" type="button" role="tab" aria-controls="nav-tabpanel-1-TBD" aria-selected="false">
  <h3 class="tab-header" id="nav-tab-heading-1-TBD">
  TBD
  </h3>
</button>
</div>
</nav><div id="nav-tabContent-1" class="tab-content">
<div id="nav-tabpanel-1-ClusterCockpit" class="tab-pane show active" role="tabpanel" aria-labelledby="nav-tab-1-ClusterCockpit">
<ol style="list-style-type: decimal">
<li>Setup: webpage &amp; login. An conditions on when it is enabled in
your particular cluster?</li>
<li>If always enabled: figure out jobid of previous 8-core job from
Episode 4</li>
</ol>
</div>
<div id="nav-tabpanel-1-PerformanceReports" class="tab-pane" role="tabpanel" aria-labelledby="nav-tab-1-PerformanceReports">
<ol style="list-style-type: decimal">
<li>(Check for licenses?)</li>
<li>Setup: load software modules</li>
<li>Submit job with <code>perf-report</code>
</li>
</ol>
</div>
<div id="nav-tabpanel-1-TBD" class="tab-pane" role="tabpanel" aria-labelledby="nav-tab-1-TBD">
<p>N/A</p>
</div>
</div>
</div>
</section><section><h2 class="section-heading" id="general-report">General report<a class="anchor" aria-label="anchor" href="#general-report"></a>
</h2>
<hr class="half-width">
<div class="tabs">
<nav><div id="nav-tab-2" class="nav nav-tabs" role="tablist">
<button class="nav-link active" id="nav-tab-2-ClusterCockpit" name="ClusterCockpit" data-bs-toggle="tab" data-bs-target="#nav-tabpanel-2-ClusterCockpit" type="button" role="tab" aria-controls="nav-tabpanel-2-ClusterCockpit" aria-selected="true">
  <h3 class="tab-header" id="nav-tab-heading-2-ClusterCockpit">
  ClusterCockpit
  </h3>
</button>
<button class="nav-link" id="nav-tab-2-PerformanceReports" name="PerformanceReports" data-bs-toggle="tab" data-bs-target="#nav-tabpanel-2-PerformanceReports" type="button" role="tab" aria-controls="nav-tabpanel-2-PerformanceReports" aria-selected="false">
  <h3 class="tab-header" id="nav-tab-heading-2-PerformanceReports">
  Performance Reports
  </h3>
</button>
<button class="nav-link" id="nav-tab-2-TBD" name="TBD" data-bs-toggle="tab" data-bs-target="#nav-tabpanel-2-TBD" type="button" role="tab" aria-controls="nav-tabpanel-2-TBD" aria-selected="false">
  <h3 class="tab-header" id="nav-tab-heading-2-TBD">
  TBD
  </h3>
</button>
</div>
</nav><div id="nav-tabContent-2" class="tab-content">
<div id="nav-tabpanel-2-ClusterCockpit" class="tab-pane show active" role="tabpanel" aria-labelledby="nav-tab-2-ClusterCockpit">
<ul>
<li>Job meta data</li>
<li>Footprint</li>
<li>Roofline plot</li>
<li>Detailed plots</li>
<li>Tabled statistics</li>
</ul>
<ol style="list-style-type: decimal">
<li>Go to webpage</li>
<li>Navigate to the job</li>
<li>Discuss overall info on a broad level
<ul>
<li>Job meta data</li>
<li>Footprint</li>
<li>Roofline plot</li>
<li>Detailed plots</li>
<li>Tabled statistics</li>
</ul>
</li>
</ol>
</div>
<div id="nav-tabpanel-2-PerformanceReports" class="tab-pane" role="tabpanel" aria-labelledby="nav-tab-2-PerformanceReports">
<ul>
<li>Computing</li>
<li>Memory</li>
<li>Communication</li>
<li>…</li>
</ul>
<ol style="list-style-type: decimal">
<li>Identify result files (txt, html)</li>
<li>Look at txt with editor</li>
<li>Copy html to local computer &amp; open it with browser</li>
<li>Discuss report on a broad level
<ul>
<li>Computing</li>
<li>Memory</li>
<li>Communication</li>
<li>…</li>
</ul>
</li>
</ol>
</div>
<div id="nav-tabpanel-2-TBD" class="tab-pane" role="tabpanel" aria-labelledby="nav-tab-2-TBD">
<p>N/A</p>
</div>
</div>
</div>
</section><section><h2 class="section-heading" id="how-does-performance-relate-to-hardware">How Does Performance Relate to Hardware?<a class="anchor" aria-label="anchor" href="#how-does-performance-relate-to-hardware"></a>
</h2>
<hr class="half-width">
<p>(Following this structure throughout the course, trying to understand
the performance in these terms)</p>
<p>Broad dimensions of performance:</p>
<ul>
<li>CPU (Front- and Backend, FLOPS)
<ul>
<li>Frontend: decoding instructions, branch prediction, pipeline</li>
<li>Backend: getting data from memory, cache hierarchy &amp;
alignment</li>
<li>Raw calculations</li>
<li>Vectorization</li>
<li>Out-of-order execution</li>
</ul>
</li>
<li>Accelerators (e.g. GPUs)
<ul>
<li>More calculations</li>
<li>Offloading</li>
<li>Memory &amp; communication models</li>
</ul>
</li>
<li>Memory (data hierarchy)
<ul>
<li>Working memory, reading data from/to disk</li>
<li>Bandwidth of data</li>
</ul>
</li>
<li>I/O (broader data hierarchy: disk, network)
<ul>
<li>Stored data</li>
<li>Local disk (caching)</li>
<li>Parallel fs (cluster-wide)</li>
<li>MPI-Communiction</li>
</ul>
</li>
<li>Parallel timeline (synchronization, etc.)
<ul>
<li>Application logic</li>
</ul>
</li>
</ul>
<figure><img src="fig/JobEfficiency.drawio.png" alt="Hardware" class="figure mx-auto d-block"><div class="figcaption">Hardware</div>
</figure><div id="exercise-match-application-behavior-to-hardware" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<span class="callout-header">Challenge</span>
<div id="exercise-match-application-behavior-to-hardware" class="callout-inner">
<h3 class="callout-title">Exercise: Match application behavior to
hardware</h3>
<div class="callout-content">
<p>Which part of the computer hardware may become an issue for the
following application patterns:</p>
<ol style="list-style-type: decimal">
<li>Calculating matrix multiplications</li>
<li>Reading data from processes on other computers</li>
<li>Calling many different functions from many equally likely if/else
branches</li>
<li>Writing very large files (TB)</li>
<li>Comparing many different strings if they match</li>
<li>Constructing a large simulation model</li>
<li>Reading thousands of small files for each iteration</li>
</ol>
<p>Maybe not the best questions, also missing something for
accelerators.</p>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1"> Show me the solution </h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" data-bs-parent="#accordionSolution1" aria-labelledby="headingSolution1">
<div class="accordion-body">
<ol style="list-style-type: decimal">
<li>CPU (FLOPS) and/or Parallel timeline</li>
<li>I/O (network)</li>
<li>CPU (Front-End)</li>
<li>I/O (disk)</li>
<li>(?) CPU-Backend, getting strings through the cache?</li>
<li>Memory (size)</li>
<li>I/O (disk)</li>
</ol>
</div>
</div>
</div>
</div>
</section><section><h2 class="section-heading" id="summary">Summary<a class="anchor" aria-label="anchor" href="#summary"></a>
</h2>
<hr class="half-width">
<ul>
<li>General reports show direction in which to continue
<ul>
<li>Specialized tools may be necessary to move on</li>
</ul>
</li>
</ul>
<p>Leading question: Connection to hardware is quite deep, why does it
matter? -&gt; Drill deeper, e.g. on NUMA &amp; pinning</p>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<span class="callout-header">Key Points</span>
<div class="callout-inner">
<div class="callout-content">
<ul>
<li>First things first, second things second, …</li>
<li>Profiling, tracing</li>
<li>Sampling, summation</li>
<li>Different HPC centers may provide different approaches to this
workflow</li>
<li>Performance reports offer more insight into the job and application
behavior</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</section></section><section id="aio-06_pinning"><p>Content from <a href="06_pinning.html">Pinning</a></p>
<hr>
<p>Last updated on 2025-10-31 |

        <a href="https://github.com/stderr-enst/jobefficiency/edit/main/episodes/06_pinning.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>What is “pinning” of job resources?</li>
<li>How can pinning improve the performance?</li>
<li>How can I see, if pinning resources would help?</li>
<li>What requirement hints can I give to the scheduler?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<p>After completing this episode, participants should be able to …</p>
<ul>
<li>Define the concept of “pinning” and how it can affect job
performance.</li>
<li>Name Slurms options for memory- and cpu- binding.</li>
<li>Use hints to tell Slurm how to optimize their job allocation.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<p>Binding / pinning:</p>
<ul>
<li><code>--mem-bind=[{quiet|verbose},]&lt;type&gt;</code></li>
<li><code>-m, --distribution={*|block|cyclic|arbitrary|plane=&lt;size&gt;}[:{*|block|cyclic|fcyclic}[:{*|block|cyclic|fcyclic}]][,{Pack|NoPack}]</code></li>
<li>
<code>--hint=</code>: Hints for CPU- (<code>compute_bound</code>)
and memory-bound (<code>memory_bound</code>), but also
<code>multithread</code>, <code>nomultithread</code>
</li>
<li>
<code>--cpu-bind=[{quiet|verbose},]&lt;type&gt;</code>
(<code>srun</code>)</li>
<li>Mapping of application &lt;-&gt; job resources</li>
</ul>
<section><h2 class="section-heading" id="motivation">Motivation<a class="anchor" aria-label="anchor" href="#motivation"></a>
</h2>
<hr class="half-width">
<div id="exercise" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<span class="callout-header">Challenge</span>
<div id="exercise" class="callout-inner">
<h3 class="callout-title">Exercise</h3>
<div class="callout-content">
<p>Case 1: 1 thread per rank
<code>mpirun -n 8 ./raytracer -width=512 -height=512 -spp=128 -threads=1 -alloc_mode=3 -png=snowman.png</code></p>
<p>Case 2: 2 thread per rank
<code>mpirun -n 8 ./raytracer -width=512 -height=512 -spp=128 -threads=2 -alloc_mode=3 -png=snowman.png</code></p>
<p>Questions: - Do you notice any difference in runtime between the two
cases? - Is the increase in threads providing a speedup as expected?</p>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1"> Show me the solution </h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" aria-labelledby="headingSolution1" data-bs-parent="#accordionSolution1">
<div class="accordion-body">
<ul>
<li>Observation: The computation times are almost the same.</li>
<li>Expected behavior: Increasing threads should ideally reduce
runtime.</li>
<li>Hypothesis: Additional threads do not contribute.</li>
</ul>
</div>
</div>
</div>
</div>
</section><section><h2 class="section-heading" id="how-to-investigate">How to investigate?<a class="anchor" aria-label="anchor" href="#how-to-investigate"></a>
</h2>
<hr class="half-width">
<p>You can verify the actual core usage in two ways: 1. Use
<code>--report-bindings</code> with <code>mpirun</code> 2. Use
<code>htop</code>command on the compute node</p>

<div id="exercise-1" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<span class="callout-header">Challenge</span>
<div id="exercise-1" class="callout-inner">
<h3 class="callout-title">Exercise</h3>
<div class="callout-content">
<p>Follow any one of the option above and run for 2 threads per rank
<code>mpirun -n 8 ./raytracer -width=512 -height=512 -spp=128 -threads=2 -alloc_mode=3 -png=snowman.png</code></p>
<p>Questions: - Did you find any justification for the hypothesis we
made?</p>
</div>
</div>
</div>
<div id="accordionSolution2" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution2" aria-expanded="false" aria-controls="collapseSolution2">
  <h4 class="accordion-header" id="headingSolution2"> Show me the solution </h4>
</button>
<div id="collapseSolution2" class="accordion-collapse collapse" aria-labelledby="headingSolution2" data-bs-parent="#accordionSolution2">
<div class="accordion-body">
<p>Only 8 cores are active instead of 16</p>
</div>
</div>
</div>
</div>
<p>Explanation:</p>
<ul>
<li>Eventhough we requested 2 threads per MPI rank, both threads are
pinned to the same core.</li>
<li>The second thread waits for the first thread to finish, so no actual
thread-level parallelization is achieved.</li>
</ul></section><section><h2 class="section-heading" id="how-to-achieve">How to achieve?<a class="anchor" aria-label="anchor" href="#how-to-achieve"></a>
</h2>
<hr class="half-width"></section><section><h2 class="section-heading" id="exercise-understanding-process-and-thread-binding">Exercise: Understanding Process and Thread Binding<a class="anchor" aria-label="anchor" href="#exercise-understanding-process-and-thread-binding"></a>
</h2>
<hr class="half-width">
<p>Pinning (or binding) means locking a process or thread to a specific
hardware resource such as a CPU core, socket, or NUMA region. Without
pinning, the operating system may move tasks between cores, which can
reduce cache reuse and increase memory latency, directly diminishes
performance.</p>
<p>In this exercise we will explore how MPI process and thread binding
works. We will try binding to <strong>core</strong>,
<strong>socket</strong>, and <strong>numa</strong>, and observe timings
and bindings.</p>

<div id="exercise-2" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<span class="callout-header">Challenge</span>
<div id="exercise-2" class="callout-inner">
<h3 class="callout-title">Exercise</h3>
<div class="callout-content">
<p>Case 1: <code>--bind-to numa</code>
<code>mpirun -n 8 --bind-to numa ./raytracer -width=512 -height=512 -spp=128 -threads=12 -alloc_mode=3 -png=snowman.png</code></p>
<p>Case 2: <code>--bind-to socket</code>
<code>mpirun -n 4 --bind-to socket /raytracer -width=512 -height=512 -spp=128 -threads=48 -alloc_mode=3 -png=snowman.png</code></p>
<p>Questions: - What is difference between Case 1 and Case 2. Any
difference in performance? How many workers? - How could you adjust
process/thread counts to better utilize the hardware in Case 2?</p>
</div>
</div>
</div>
<div id="accordionSolution3" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution3" aria-expanded="false" aria-controls="collapseSolution3">
  <h4 class="accordion-header" id="headingSolution3"> Show me the solution </h4>
</button>
<div id="collapseSolution3" class="accordion-collapse collapse" aria-labelledby="headingSolution3" data-bs-parent="#accordionSolution3">
<div class="accordion-body">
<ul>
<li>MPI and thread pinning is hardware-aware.</li>
<li>If the number of processes matches the number of domains (socket or
NUMA), then the number of threads should equal the cores per domain to
fully utilize the node.</li>
<li>No speedup in Case 2: Oversubscription occurs because we requested 4
processes on a system with only 2 sockets.</li>
<li>Threads compete for the same cores → OpenMPI queues threads and
waits until other processes finish.</li>
</ul>
</div>
</div>
</div>
</div>
</section><section><h2 class="section-heading" id="best-practices-for-mpi-process-and-thread-pinning">Best Practices for MPI Process and Thread Pinning<a class="anchor" aria-label="anchor" href="#best-practices-for-mpi-process-and-thread-pinning"></a>
</h2>
<hr class="half-width">
<div class="section level3">
<h3 id="difference-between-binding-and-mapping">Difference between Binding and Mapping<a class="anchor" aria-label="anchor" href="#difference-between-binding-and-mapping"></a>
</h3>
<p><strong>Mapping</strong> is about distributing MPI ranks across
hardware hierarchy which tells where your processes will be placed.</p>
<p>**Binding* is locking your MPI processes/threads to a specific
resource which prevents from moving it around from one to another.</p>
</div>
</section><section><h2 class="section-heading" id="mapping-vs--binding-analogy">Mapping vs. Binding Analogy<a class="anchor" aria-label="anchor" href="#mapping-vs--binding-analogy"></a>
</h2>
<hr class="half-width">
<p>Think of running MPI processes and threads like booking seats for a
group of friends:</p>
<ul>
<li>
<strong>Mapping</strong> is like planning where your group will sit
in the theatre or on a flight.
<ul>
<li>Example: You decide some friends sit in Economy, some in Premium
Economy, and some in Business.<br>
</li>
<li>Similarly, <code>--map-by</code> distributes MPI ranks across nodes,
sockets, or NUMA regions.</li>
</ul>
</li>
<li>
<strong>Binding</strong> is like reserving the exact seats for each
friend in the planned area.
<ul>
<li>Example: Once the seating area is chosen, you assign specific seat
numbers to each friend.<br>
</li>
<li>Similarly, <code>--bind-to</code> pins each MPI process or thread to
a specific core or hardware unit to avoid movement.</li>
</ul>
</li>
</ul>
<p>This analogy helps illustrate why <strong>mapping defines
placement</strong> and <strong>binding enforces it</strong>.</p>
<p>We will use <code>--bind-to core</code> (the smallest hardware unit)
and <code>--map-by</code> to distribute MPI processes across sockets or
NUMA or node regions efficiently.</p>
<div class="section level3">
<h3 id="choosing-the-smallest-hardware-unit">Choosing the Smallest Hardware Unit<a class="anchor" aria-label="anchor" href="#choosing-the-smallest-hardware-unit"></a>
</h3>
<p>Binding processes to the smallest unit (core) is recommended
because:</p>
<ol style="list-style-type: decimal">
<li><p><strong>Exclusive use of resources</strong><br>
Each process or thread is pinned to its own core, preventing multiple
threads or processes from competing for the same CPU.</p></li>
<li><p><strong>Predictable performance</strong><br>
When processes share cores, execution times can fluctuate due to
scheduling conflicts. Binding to cores ensures consistent timing across
runs.</p></li>
</ol>
<ul>
<li>Best practice: Always bind processes to the smallest unit (core) and
spread processes evenly across the available hardware using
<code>--map-by</code>.</li>
<li>Example options:
<ul>
<li>
<code>--bind-to core</code> → binds each process to a dedicated core
(avoids oversubscription).<br>
</li>
<li>
<code>--map-by socket:PE=&lt;threads&gt;</code> → spreads given
number of threads as a processing element across the socket</li>
<li>
<code>--map-by numa:PE=&lt;threads&gt;</code> → spreads processes
across NUMA domains, assigning <code>&lt;threads&gt;</code> cores per
process.</li>
<li>similarly <code>--map-by numa:PE=&lt;threads&gt;</code>
</li>
<li>
<code>--cpus-per-rank &lt;n&gt;</code>→ Assigns
<code>&lt;n&gt;</code> cores (hardware threads) to each MPI rank -
ensuring that all threads within a rank occupy separate cores.</li>
</ul>
</li>
</ul>
<div id="exercise-3" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<span class="callout-header">Challenge</span>
<div id="exercise-3" class="callout-inner">
<h3 class="callout-title">Exercise</h3>
<div class="callout-content">
<p>Use the given best practices above for case 1: <code>-n 8</code>,
<code>-threads=1</code> and case 2: <code>-n 8</code>,
<code>-threads=4</code> and answer following questions</p>
<p>Questions: - How many cores does the both jobs use? - Did you get
more workers than you requested? - Did you see the scaling when running
with 4 threads?</p>
</div>
</div>
</div>
<div id="accordionSolution4" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution4" aria-expanded="false" aria-controls="collapseSolution4">
  <h4 class="accordion-header" id="headingSolution4"> Show me the solution </h4>
</button>
<div id="collapseSolution4" class="accordion-collapse collapse" aria-labelledby="headingSolution4" data-bs-parent="#accordionSolution4">
<div class="accordion-body">
<ul>
<li>8 and 32</li>
<li>No.</li>
<li>Yes</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</section><section><h2 class="section-heading" id="summary">Summary<a class="anchor" aria-label="anchor" href="#summary"></a>
</h2>
<hr class="half-width">
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<span class="callout-header">Key Points</span>
<div class="callout-inner">
<div class="callout-content">
<ul>
<li><p><strong>Always check how pinning works</strong><br>
Use verbose reporting (e.g., <code>--report-bindings</code>) to see how
MPI processes and threads are mapped to cores and sockets.</p></li>
<li><p><strong>Documentation is your friend</strong><br>
For OpenMPI with <code>mpirun</code>, consult the manual: <a href="https://www.open-mpi.org/doc/v4.1/man1/mpirun.1.php" class="external-link">https://www.open-mpi.org/doc/v4.1/man1/mpirun.1.php</a></p></li>
<li><p><strong>Know your hardware</strong><br>
Understanding the number of sockets, cores per socket, and NUMA regions
on your cluster helps you make effective binding decisions.</p></li>
<li><p><strong>Avoid oversubscription</strong><br>
Assigning more threads or processes than available cores hurts
performance — it causes contention and idle waits.</p></li>
<li><p><strong>Recommended practice for OpenMPI</strong><br>
Use <code>--bind-to core</code> along with <code>--map-by</code> to
control placement and threads per process to maximize
throughput.</p></li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</section></section><section id="aio-07_bottlenecks"><p>Content from <a href="07_bottlenecks.html">How to identify a bottleneck?</a></p>
<hr>
<p>Last updated on 2025-09-24 |

        <a href="https://github.com/stderr-enst/jobefficiency/edit/main/episodes/07_bottlenecks.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>How can I find the bottlenecks in a given job?</li>
<li>What are common workflows to evaluate performance?</li>
<li>What are some common types of bottlenecks?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<p>After completing this episode, participants should be able to …</p>
<ul>
<li>Choose between multiple workflows to evaluate job performance.</li>
<li>Name typical performance issues.</li>
<li>Determine if their job is affected by one of these issues.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section><h2 class="section-heading" id="how-to-identify-a-bottleneck">How to identify a bottleneck?<a class="anchor" aria-label="anchor" href="#how-to-identify-a-bottleneck"></a>
</h2>
<hr class="half-width">
<!-- EPISODE CONTENT HERE --></section><section><h2 class="section-heading" id="summary">Summary<a class="anchor" aria-label="anchor" href="#summary"></a>
</h2>
<hr class="half-width">
<p>Leading question: We were looking at a standard configuration with
CPU, Memory, Disks, Network, so far. What about GPU applications, which
are very common these days?</p>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<span class="callout-header">Key Points</span>
<div class="callout-inner">
<div class="callout-content">
<ul>
<li>General advice on the workflow</li>
<li>Performance reports may provide an automated summary with
recommendations</li>
<li>Performance metrics can be categorized by the underlying hardware,
e.g. CPU, memory, I/O, accelerators.</li>
<li>Bottlenecks can appear by metrics being saturated at the physical
limits of the hardware or indirectly by other metrics being far from
what the physical limits are.</li>
<li>Interpreting bottlenecks is closely related to what the application
is supposed to do.</li>
<li>Relative measurements (baseline vs. change)
<ul>
<li>system is quiescent, fixed CPU freq + affinity, warmups, …</li>
<li>Reproducibility -&gt; link to git course?</li>
</ul>
</li>
<li>Scanning results for smoking guns</li>
<li>Any best practices etc.</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</section></section><section id="aio-08_accelerators"><p>Content from <a href="08_accelerators.html">Performance of Accelerators</a></p>
<hr>
<p>Last updated on 2025-09-24 |

        <a href="https://github.com/stderr-enst/jobefficiency/edit/main/episodes/08_accelerators.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>What are accelerators?</li>
<li>How do they affect my jobs performance?</li>
<li>How can I measure accelerator utilization?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<p>After completing this episode, participants should be able to …</p>
<ul>
<li>Understand difference of performance measurements on accelerators
(GPUs, FPGAs) to CPUs.</li>
<li>Understand how batch systems and performance measurements tools
treat accelerators.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section><h2 class="section-heading" id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<hr class="half-width">
<p>Run the same example workload on GPU and compare.</p>


<!-- EPISODE CONTENT HERE -->
</section><section><h2 class="section-heading" id="summary">Summary<a class="anchor" aria-label="anchor" href="#summary"></a>
</h2>
<hr class="half-width">
<p>Leading question: Performance optimization is a deep topic and we are
not done learning. How could I continue exploring the topic?</p>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<span class="callout-header">Key Points</span>
<div class="callout-inner">
<div class="callout-content">
<ul>
<li>Tools to measure GPU/FPGA performance of a job</li>
<li>Common symptoms of GPU/FPGA problems</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</section></section><section id="aio-09_nextsteps"><p>Content from <a href="09_nextsteps.html">Next Steps</a></p>
<hr>
<p>Last updated on 2025-10-29 |

        <a href="https://github.com/stderr-enst/jobefficiency/edit/main/episodes/09_nextsteps.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>What are other patterns of performance bottlenecks?</li>
<li>How to evaluate an application in more detail?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<p>After completing this episode, participants should be able to …</p>
<ul>
<li>Find collection of performance patterns on hpc-wiki.info</li>
<li>Identify next steps to take with regard to performance
optimization.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section><h2 class="section-heading" id="next-steps">Next Steps<a class="anchor" aria-label="anchor" href="#next-steps"></a>
</h2>
<hr class="half-width">
<p>hpc-wiki.info - I/O - CPU Front End - CPU Back End - Memory leak -
Oversubscription - Underutilization</p>
<!-- EPISODE CONTENT HERE -->
</section><section><h2 class="section-heading" id="summary">Summary<a class="anchor" aria-label="anchor" href="#summary"></a>
</h2>
<hr class="half-width">
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<span class="callout-header">Key Points</span>
<div class="callout-inner">
<div class="callout-content">
<ul>
<li>There are many profilers, some are language-specific, others are
vendor-related, …</li>
<li>Simple profile with exclusive resources</li>
<li>Repeated measurements for reliability</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</section></section>
</div>
    </main>
</div>
<!-- END  : inst/pkgdown/templates/content-extra.html -->

      </div>
<!--/div.row-->
      		<footer class="row footer mx-md-3"><hr>
<div class="col-md-6">
        <p>This lesson is subject to the <a href="CODE_OF_CONDUCT.html">Code of Conduct</a></p>
        <p>

        <a href="https://github.com/stderr-enst/jobefficiency/edit/main/README.md" class="external-link">Edit on GitHub</a>

	
        | <a href="https://github.com/stderr-enst/jobefficiency/blob/main/CONTRIBUTING.md" class="external-link">Contributing</a>
        | <a href="https://github.com/stderr-enst/jobefficiency/" class="external-link">Source</a></p>
				<p><a href="https://github.com/stderr-enst/jobefficiency/blob/main/CITATION.cff" class="external-link">Cite</a> | <a href="mailto:helpdesk@hpc.nrw">Contact</a> | <a href="https://carpentries.org/about/" class="external-link">About</a></p>
			</div>
			<div class="col-md-6">

        <p>Materials licensed under <a href="LICENSE.html">CC-BY 4.0</a> by the authors</p>

        <p>Template licensed under <a href="https://creativecommons.org/licenses/by-sa/4.0/" class="external-link">CC-BY 4.0</a> by <a href="https://carpentries.org/" class="external-link">The Carpentries</a></p>
        <p>Built with <a href="https://github.com/carpentries/sandpaper/tree/0.17.1" class="external-link">sandpaper (0.17.1)</a>, <a href="https://github.com/carpentries/pegboard/tree/0.7.9" class="external-link">pegboard (0.7.9)</a>, and <a href="https://github.com/carpentries/varnish/tree/1.0.7" class="external-link">varnish (1.0.7)</a></p>
			</div>
		</footer>
</div> <!-- / div.container -->
	<div id="to-top">
		<a href="#top">
      <i class="search-icon" data-feather="arrow-up" role="img" aria-label="Back To Top"></i><br><!-- <span class="d-none d-sm-none d-md-none d-lg-none d-xl-block">Back</span> To Top --><span class="d-none d-sm-none d-md-none d-lg-none d-xl-block">Back</span> To Top
		</a>
	</div>
  <script type="application/ld+json">
    {
  "@context": "https://schema.org",
  "@type": "LearningResource",
  "@id": "https://stderr-enst.github.io/jobefficiency/aio.html",
  "inLanguage": "en",
  "dct:conformsTo": "https://bioschemas.org/profiles/LearningResource/1.0-RELEASE",
  "description": "A Carpentries Lesson teaching foundational data and coding skills to researchers worldwide",
  "keywords": "hpc, software, data, lesson, The Carpentries",
  "name": "All in One View",
  "creativeWorkStatus": "active",
  "url": "https://stderr-enst.github.io/jobefficiency/aio.html",
  "identifier": "https://stderr-enst.github.io/jobefficiency/aio.html",
  "dateCreated": "2025-03-28",
  "dateModified": "2025-12-02",
  "datePublished": "2025-12-02"
}

  </script><script>
		feather.replace();
	</script>
</body>
</html><!-- END:   inst/pkgdown/templates/layout.html-->

