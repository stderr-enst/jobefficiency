<!DOCTYPE html>
<!-- START: inst/pkgdown/templates/layout.html --><!-- Generated by pkgdown: do not edit by hand --><html lang="en" data-bs-theme="auto">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<title>Job Efficiency: All in One View</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<script src="../assets/themetoggle.js"></script><link rel="stylesheet" type="text/css" href="../assets/styles.css">
<script src="../assets/scripts.js" type="text/javascript"></script><!-- mathjax --><script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      config: ["MMLorHTML.js"],
      jax: ["input/TeX","input/MathML","output/HTML-CSS","output/NativeMML", "output/PreviewHTML"],
      extensions: ["tex2jax.js","mml2jax.js","MathMenu.js","MathZoom.js", "fast-preview.js", "AssistiveMML.js", "a11y/accessibility-menu.js"],
      TeX: {
        extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"]
      },
      tex2jax: {
        inlineMath: [['\\(', '\\)']],
        displayMath: [ ['$$','$$'], ['\\[', '\\]'] ],
        processEscapes: true
      }
    });
    </script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><!-- Responsive Favicon for The Carpentries --><link rel="apple-touch-icon" sizes="180x180" href="../favicons/incubator/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="../favicons/incubator/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="../favicons/incubator/favicon-16x16.png">
<link rel="manifest" href="../favicons/incubator/site.webmanifest">
<link rel="mask-icon" href="../favicons/incubator/safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="white">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="black">
</head>
<body>
    <header id="top" class="navbar navbar-expand-md top-nav incubator"><svg xmlns="http://www.w3.org/2000/svg" class="d-none"><symbol id="check2" viewbox="0 0 16 16"><path d="M13.854 3.646a.5.5 0 0 1 0 .708l-7 7a.5.5 0 0 1-.708 0l-3.5-3.5a.5.5 0 1 1 .708-.708L6.5 10.293l6.646-6.647a.5.5 0 0 1 .708 0z"></path></symbol><symbol id="circle-half" viewbox="0 0 16 16"><path d="M8 15A7 7 0 1 0 8 1v14zm0 1A8 8 0 1 1 8 0a8 8 0 0 1 0 16z"></path></symbol><symbol id="moon-stars-fill" viewbox="0 0 16 16"><path d="M6 .278a.768.768 0 0 1 .08.858 7.208 7.208 0 0 0-.878 3.46c0 4.021 3.278 7.277 7.318 7.277.527 0 1.04-.055 1.533-.16a.787.787 0 0 1 .81.316.733.733 0 0 1-.031.893A8.349 8.349 0 0 1 8.344 16C3.734 16 0 12.286 0 7.71 0 4.266 2.114 1.312 5.124.06A.752.752 0 0 1 6 .278z"></path><path d="M10.794 3.148a.217.217 0 0 1 .412 0l.387 1.162c.173.518.579.924 1.097 1.097l1.162.387a.217.217 0 0 1 0 .412l-1.162.387a1.734 1.734 0 0 0-1.097 1.097l-.387 1.162a.217.217 0 0 1-.412 0l-.387-1.162A1.734 1.734 0 0 0 9.31 6.593l-1.162-.387a.217.217 0 0 1 0-.412l1.162-.387a1.734 1.734 0 0 0 1.097-1.097l.387-1.162zM13.863.099a.145.145 0 0 1 .274 0l.258.774c.115.346.386.617.732.732l.774.258a.145.145 0 0 1 0 .274l-.774.258a1.156 1.156 0 0 0-.732.732l-.258.774a.145.145 0 0 1-.274 0l-.258-.774a1.156 1.156 0 0 0-.732-.732l-.774-.258a.145.145 0 0 1 0-.274l.774-.258c.346-.115.617-.386.732-.732L13.863.1z"></path></symbol><symbol id="sun-fill" viewbox="0 0 16 16"><path d="M8 12a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM8 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 0zm0 13a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 13zm8-5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2a.5.5 0 0 1 .5.5zM3 8a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2A.5.5 0 0 1 3 8zm10.657-5.657a.5.5 0 0 1 0 .707l-1.414 1.415a.5.5 0 1 1-.707-.708l1.414-1.414a.5.5 0 0 1 .707 0zm-9.193 9.193a.5.5 0 0 1 0 .707L3.05 13.657a.5.5 0 0 1-.707-.707l1.414-1.414a.5.5 0 0 1 .707 0zm9.193 2.121a.5.5 0 0 1-.707 0l-1.414-1.414a.5.5 0 0 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .707zM4.464 4.465a.5.5 0 0 1-.707 0L2.343 3.05a.5.5 0 1 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .708z"></path></symbol></svg><a class="visually-hidden-focusable skip-link" href="#main-content">Skip to main content</a>
  <div class="container-fluid top-nav-container">
    <div class="col-md-8">
      <div class="large-logo">
        <img id="incubator-logo" alt="HPC Carpentry lesson about assessing job efficiency by HPC.NRW" src="../assets/images/incubator-logo.svg"><span class="badge text-bg-danger">
          <abbr title="This lesson is in the pre-alpha phase, which means that it is in early development, but has not yet been taught.">
            <a href="https://docs.carpentries.org/resources/curriculum/lesson-life-cycle.html" class="external-link alert-link">
              <i aria-hidden="true" class="icon" data-feather="alert-octagon" style="border-radius: 5px"></i>
              Pre-Alpha
            </a>
            <span class="visually-hidden">This lesson is in the pre-alpha phase, which means that it is in early development, but has not yet been taught.</span>
          </abbr>
        </span>

      </div>
    </div>
    <div class="selector-container">
      <div id="theme-selector">
        <li class="nav-item dropdown" id="theme-button-list">
          <button class="btn btn-link nav-link px-0 px-lg-2 dropdown-toggle d-flex align-items-center" id="bd-theme" type="button" aria-expanded="false" data-bs-toggle="dropdown" data-bs-display="static" aria-label="Toggle theme (auto)">
            <svg class="bi my-1 theme-icon-active"><use href="#circle-half"></use></svg><i data-feather="chevron-down"></i>
          </button>
          <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="bd-theme-text">
<li>
              <button type="button" class="btn dropdown-item d-flex align-items-center" data-bs-theme-value="light" aria-pressed="false">
                <svg class="bi me-2 theme-icon"><use href="#sun-fill"></use></svg>
                Light
                <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
            </li>
            <li>
              <button type="button" class="btn dropdown-item d-flex align-items-center" data-bs-theme-value="dark" aria-pressed="false">
                <svg class="bi me-2 theme-icon"><use href="#moon-stars-fill"></use></svg>
                Dark
                <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
            </li>
            <li>
              <button type="button" class="btn dropdown-item d-flex align-items-center active" data-bs-theme-value="auto" aria-pressed="true">
                <svg class="bi me-2 theme-icon"><use href="#circle-half"></use></svg>
                Auto
                <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
            </li>
          </ul>
</li>
      </div>


      <div class="dropdown" id="instructor-dropdown">
        <button class="btn btn-secondary dropdown-toggle bordered-button" type="button" id="dropdownMenu1" data-bs-toggle="dropdown" aria-expanded="false">
          <i aria-hidden="true" class="icon" data-feather="eye"></i> Instructor View <i data-feather="chevron-down"></i>
        </button>
        <ul class="dropdown-menu" aria-labelledby="dropdownMenu1">
<li><button class="dropdown-item" type="button" onclick="window.location.href='../aio.html';">Learner View</button></li>
        </ul>
</div>
    </div>
  </div>
  <hr></header><nav class="navbar navbar-expand-xl bottom-nav incubator" aria-label="Main Navigation"><div class="container-fluid nav-container">
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle Navigation">
      <span class="navbar-toggler-icon"></span>
      <span class="menu-title">Menu</span>
    </button>
    <div class="nav-logo">
      <img class="small-logo" alt="HPC Carpentry lesson about assessing job efficiency by HPC.NRW" src="../assets/images/incubator-logo-sm.svg">
</div>
    <div class="lesson-title-md">
      Job Efficiency
    </div>
    <div class="search-icon-sm">
      <!-- TODO: do not show until we have search
        <i role="img" aria-label="Search the All In One page" data-feather="search"></i>
      -->
    </div>
    <div class="desktop-nav">
      <ul class="navbar-nav me-auto mb-2 mb-lg-0">
<li class="nav-item">
          <span class="lesson-title">
            Job Efficiency
          </span>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="../instructor/key-points.html">Key Points</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="../instructor/instructor-notes.html">Instructor Notes</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="../instructor/images.html">Extract All Images</a>
        </li>
        <li class="nav-item dropdown">
          <button class="nav-link dropdown-toggle" id="navbarDropdown" data-bs-toggle="dropdown" aria-expanded="false">
            More <i data-feather="chevron-down"></i>
          </button>
          <ul class="dropdown-menu" aria-labelledby="navbarDropdown">
<hr>
<li><a class="dropdown-item" href="reference.html">Reference</a></li>
          </ul>
</li>
      </ul>
</div>
    <!--
    <form class="d-flex col-md-2 search-form">
      <fieldset disabled>
      <input class="form-control me-2 searchbox" type="search" placeholder="" aria-label="">
        <button class="btn btn-outline-success tablet-search-button"  type="submit">
          <i class="search-icon" data-feather="search" role="img" aria-label="Search the All In One page"></i>
        </button>
      </fieldset>
    </form>
    -->
    <a id="search-button" class="btn btn-primary" href="../instructor/aio.html" role="button" aria-label="Search the All In One page">Search the All In One page</a>
  </div>
<!--/div.container-fluid -->
</nav><div class="col-md-12 mobile-title">
  Job Efficiency
</div>

<aside class="col-md-12 lesson-progress"><div style="width: %" class="percentage">
    %
  </div>
  <div class="progress incubator">
    <div class="progress-bar incubator" role="progressbar" style="width: %" aria-valuenow="" aria-label="Lesson Progress" aria-valuemin="0" aria-valuemax="100">
    </div>
  </div>
</aside><div class="container">
      <div class="row">
        <!-- START: inst/pkgdown/templates/navbar.html -->
<div id="sidebar-col" class="col-lg-4">
  <div id="sidebar" class="sidebar">
      <nav aria-labelledby="flush-headingEleven"><button role="button" aria-label="close menu" alt="close menu" aria-expanded="true" aria-controls="sidebar" class="collapse-toggle" data-collapse="Collapse " data-episodes="Episodes ">
          <i class="search-icon" data-feather="x" role="img"></i>
        </button>
        <div class="sidebar-inner">
          <div class="row mobile-row" id="theme-row-mobile">
            <div class="col" id="theme-selector">
              <li class="nav-item dropdown" id="theme-button-list">
                <button class="btn btn-link nav-link px-0 px-lg-2 dropdown-toggle d-flex align-items-center" id="bd-theme" type="button" aria-expanded="false" data-bs-toggle="dropdown" data-bs-display="static" aria-label="Toggle theme (auto)">
                  <svg class="bi my-1 theme-icon-active"><use href="#circle-half"></use></svg><span class="d-lg-none ms-1" id="bd-theme-text">Toggle Theme</span>
                </button>
                <ul class="dropdown-menu dropdown-menu-right" aria-labelledby="bd-theme-text">
<li>
                    <button type="button" class="btn dropdown-item d-flex align-items-center" data-bs-theme-value="light" aria-pressed="false">
                      <svg class="bi me-2 theme-icon"><use href="#sun-fill"></use></svg>
                      Light
                      <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
                  </li>
                  <li>
                    <button type="button" class="btn dropdown-item d-flex align-items-center" data-bs-theme-value="dark" aria-pressed="false">
                      <svg class="bi me-2 theme-icon"><use href="#moon-stars-fill"></use></svg>
                      Dark
                      <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
                  </li>
                  <li>
                    <button type="button" class="btn dropdown-item d-flex align-items-center active" data-bs-theme-value="auto" aria-pressed="true">
                      <svg class="bi me-2 theme-icon"><use href="#circle-half"></use></svg>
                      Auto
                      <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
                  </li>
                </ul>
</li>
            </div>
          </div>
          <div class="row mobile-row">
            <div class="col">
              <div class="sidenav-view-selector">
                <div class="accordion accordion-flush" id="accordionFlush9">
                  <div class="accordion-item">
                    <h2 class="accordion-header" id="flush-headingNine">
                      <button class="accordion-button collapsed" id="instructor" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseNine" aria-expanded="false" aria-controls="flush-collapseNine">
                        <i id="eye" aria-hidden="true" class="icon" data-feather="eye"></i> Instructor View
                      </button>
                    </h2>
                    <div id="flush-collapseNine" class="accordion-collapse collapse" aria-labelledby="flush-headingNine" data-bs-parent="#accordionFlush2">
                      <div class="accordion-body">
                        <a href="../aio.html">Learner View</a>
                      </div>
                    </div>
                  </div>
<!--/div.accordion-item-->
                </div>
<!--/div.accordion-flush-->
              </div>
<!--div.sidenav-view-selector -->
            </div>
<!--/div.col -->

            <hr>
</div>
<!--/div.mobile-row -->

          <div class="accordion accordion-flush" id="accordionFlush11">
            <div class="accordion-item">

              <button id="chapters" class="accordion-button show" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseEleven" aria-expanded="false" aria-controls="flush-collapseEleven">
                <h2 class="accordion-header chapters" id="flush-headingEleven">
                  EPISODES
                </h2>
              </button>
              <div id="flush-collapseEleven" class="accordion-collapse show collapse" aria-labelledby="flush-headingEleven" data-bs-parent="#accordionFlush11">

                <div class="accordion-body">
                  <div class="accordion accordion-flush" id="accordionFlush1">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading1">
        <a href="index.html">Summary and Schedule</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush2">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading2">
        <a href="01_introduction.html">1. Introduction</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush3">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading3">
        <a href="02_resourcerequirements.html">2. Resource Requirements</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush4">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading4">
        <a href="03_schedulertools.html">3. Scheduler Tools</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush5">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading5">
        <a href="04_scalingstudy.html">4. Scaling Study</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush6">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading6">
        <a href="05_performancereports.html">5. Performance Overview</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush7">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading7">
        <a href="06_pinning.html">6. Pinning</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush8">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading8">
        <a href="07_bottlenecks.html">7. How to identify a bottleneck?</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush9">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading9">
        <a href="08_accelerators.html">8. Performance of Accelerators</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush10">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading10">
        <a href="09_nextsteps.html">9. Next Steps</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

                </div>
              </div>
            </div>

            <hr class="half-width">
<div class="accordion accordion-flush lesson-resources" id="accordionFlush12">
              <div class="accordion-item">
                <h2 class="accordion-header" id="flush-headingTwelve">
                  <button class="accordion-button collapsed" id="lesson-resources" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseTwelve" aria-expanded="false" aria-controls="flush-collapseTwelve">
                    RESOURCES
                  </button>
                </h2>
                <div id="flush-collapseTwelve" class="accordion-collapse collapse" aria-labelledby="flush-headingTwelve" data-bs-parent="#accordionFlush12">
                  <div class="accordion-body">
                    <ul>
<li>
                        <a href="../instructor/key-points.html">Key Points</a>
                      </li>
                      <li>
                        <a href="../instructor/instructor-notes.html">Instructor Notes</a>
                      </li>
                      <li>
                        <a href="../instructor/images.html">Extract All Images</a>
                      </li>
                      <hr>
<li><a class="dropdown-item" href="reference.html">Reference</a></li>
                    </ul>
</div>
                </div>
              </div>
            </div>
            <hr class="half-width lesson-resources">
<a href="../instructor/aio.html">See all in one page</a>


            <hr class="d-none d-sm-block d-md-none">
<div class="d-grid gap-1">

            </div>
          </div>
<!-- /div.accordion -->
        </div>
<!-- /div.sidebar-inner -->
      </nav>
</div>
<!-- /div.sidebar -->
  </div>
<!-- /div.sidebar-col -->
<!-- END:   inst/pkgdown/templates/navbar.html-->

        <!-- START: inst/pkgdown/templates/content-extra.html -->
  <div class="col-xl-8 col-lg-12 primary-content">
    <main id="main-content" class="main-content"><div class="container lesson-content">
        
        
<section id="aio-01_introduction"><p>Content from <a href="01_introduction.html">Introduction</a></p>
<hr>
<p>Last updated on 2025-12-12 |

        <a href="https://github.com/stderr-enst/jobefficiency/edit/main/episodes/01_introduction.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 10 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>What exactly is job efficiency in the computing world?</li>
<li>Why would I care about job efficiency and what are potential
pitfalls?</li>
<li>How can I start measuring how my program performs?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<p>After completing this episode, participants should be able to …</p>
<ul>
<li>Use timing commands provided by
<code>time</code>and<code>date</code>.</li>
<li>Understand the benefits of efficient jobs in terms of runtime and
numerical accuracy.</li>
<li>Have developed some awareness about the overall high energy
consumption of HPC.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="accordionInstructor1" class="accordion instructor-note accordion-flush">
<div class="accordion-item">
<button class="accordion-button instructor-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseInstructor1" aria-expanded="false" aria-controls="collapseInstructor1">
  <h3 class="accordion-header" id="headingInstructor1">  <div class="note-square"><i aria-hidden="true" class="callout-icon" data-feather="edit-2"></i></div> Intention: Step into the narrative </h3>
</button>
<div id="collapseInstructor1" class="accordion-collapse collapse" aria-labelledby="headingInstructor1" data-bs-parent="#accordionInstructor1">
<div class="accordion-body">
<p>Set up narrative:</p>
<ul>
<li>Important upcoming conference presentation</li>
<li>Time is ticking, the deadline is approaching way too fast</li>
<li>The talk is almost done, but, critically, we’re missing a picture
for the title slide</li>
<li>It should contain three snowmen, and we’ve exhausted our credits for
all generative AI models in previous chats with colleagues</li>
<li>=&gt; Ray tracing a scene to the rescue!</li>
<li>Issue: we need to try many different iterations of the scene to find
the exact right picture. How can we maximise the number of raytraced
snowman images before our conference deadline?</li>
<li>Ray tracing is expensive, but luckily we have access to an HPC
system</li>
</ul>
<p>What we’re doing here:</p>
<ul>
<li>Run workflow example for the first time</li>
<li>Simple <code>time</code> measurement to get started</li>
<li>Introduce different perspectives on efficiency</li>
<li>Core-h and correlation to cost in energy/money</li>
<li>Either set up the first Slurm job here or in the next episode</li>
</ul>
</div>
</div>
</div>
</div>
<div id="accordionInstructor2" class="accordion instructor-note accordion-flush">
<div class="accordion-item">
<button class="accordion-button instructor-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseInstructor2" aria-expanded="false" aria-controls="collapseInstructor2">
  <h3 class="accordion-header" id="headingInstructor2">  <div class="note-square"><i aria-hidden="true" class="callout-icon" data-feather="edit-2"></i></div> TODO: Possible to highlight individual benefits of efficient jobs more? </h3>
</button>
<div id="collapseInstructor2" class="accordion-collapse collapse" aria-labelledby="headingInstructor2" data-bs-parent="#accordionInstructor2">
<div class="accordion-body">
<p>Maybe good to also address perspective of “why should I care”. You
get more out of your fair share. Shorter iteration times =&gt;
more/better insight …</p>
</div>
</div>
</div>
</div>
<section><h2 class="section-heading" id="background">Background<a class="anchor" aria-label="anchor" href="#background"></a>
</h2>
<hr class="half-width">
<p>Job efficiency, as defined by Oxford’s English Dictionaries, is
<em>the ratio of the useful work performed by a machine […] to the total
energy expended or heat taken in</em>. In a high-performance-computing
(HPC) context, the useful work is the entirety of all calculations to be
performed by our (heat-generating) computers. Doing this efficiently
thus translates to maximizing the calculations completed in some limited
time span while minimizing the heat output. In more extreme words, we
want to avoid running big computers for <em>nothing but hot
air</em>.</p>
<p>One may object that a single user’s job may hardly have an effect on
an HPC system’s power usage since such systems are in power-on state
24/7 anyway. The same may be argued about air travel. The plane will
take off anyway, whether I board the plane or not. However, we indeed
have some leverage in contributing to efficiency, defined by fuel
consumption in air travel: traveling lightly, i.e., avoiding excessive
baggage will improve the airplane’s ratio <span class="math inline">\(\frac{useful\;work}{total\;energy\;expended}\)</span>.
So let’s get back to the ground and look at some inefficiencies in
computing jobs, while we will continue to use the air-travel
analogy.</p>
<div class="section level3">
<h3 id="time-to-sleep">
<code>time</code> to <code>sleep</code>
<a class="anchor" aria-label="anchor" href="#time-to-sleep"></a>
</h3>
<p>Let’s look at the command<code>sleep</code></p>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="fu">sleep</span> 2</span></code></pre>
</div>
<p>This command triggers a “computer nap”. It actually delays whatever
would come next for the specified time, here 2 seconds. You can verify
that nap time using a stopwatch, the latter given by
the<code>time</code>command:</p>
<div class="codewrapper sourceCode" id="cb2">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="bu">time</span> sleep 2</span></code></pre>
</div>
<p>which will report something like</p>
<pre><code>real	0m2.002s
user	0m0.001s
sys	0m0.000s</code></pre>
<p>The <code>time</code> command shall be our first
performance-measuring tool. <code>time</code>has become a bit of a
<em>hello-world</em> equivalent in HPC contexts. This command gives you
a breakdown of how your program uses CPU (Central Processing Unit) and
wall-clock time. The standard output of <code>time</code> reports three
fields, <em>real</em>, <em>user</em> and <em>sys</em>:</p>
<table class="table">
<colgroup>
<col width="8%">
<col width="91%">
</colgroup>
<tbody>
<tr class="odd">
<td>Time</td>
<td>Meaning</td>
</tr>
<tr class="even">
<td>real</td>
<td>Wall-clock time = total runtime as seen on a stopwatch</td>
</tr>
<tr class="odd">
<td>user</td>
<td>Time spent in <em>user</em>-mode: actual computations like math,
loops, logic</td>
</tr>
<tr class="even">
<td>sys</td>
<td>Time spent in OS’s <em>kernel</em>-mode (system calls): I/O =
reading/writing files, handling memory, talking to other devices</td>
</tr>
</tbody>
</table>
<p>The above<code>sleep</code>command abstains from any kind of math,
I/O, or other work that would show up in <em>user</em> or <em>sys</em>
time, hence these entries show (almost) zero.</p>
<div id="accordionSpoiler1" class="accordion spoiler-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button spoiler-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSpoiler1" aria-expanded="false" aria-controls="collapseSpoiler1">
  <h3 class="accordion-header" id="headingSpoiler1">  <div class="note-square"><i aria-hidden="true" class="callout-icon" data-feather="eye"></i></div> time or /usr/bin/time? that’s the question </h3>
</button>
<div id="collapseSpoiler1" class="accordion-collapse collapse" aria-labelledby="headingSpoiler1" data-bs-parent="#accordionSpoiler1">
<div class="accordion-body">
<p>The<code>time</code>command is both a keyword directly built into the
Bash shell as well as an executable file, usually residing
under<code>/usr/bin/time</code>. While very similar, they are not
exactly the same. Shell/Bash keywords take precedence, so preceding a
command with<code>time</code>invokes the shell keyword. Therefore, if
you want to force the usage of<code>/usr/bin/time</code>, you would
do</p>
<div class="codewrapper sourceCode" id="cb4">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a><span class="co"># Explicitly calling the `time` binary</span></span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a><span class="ex">$</span> /usr/bin/time sleep 2</span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a><span class="ex">0.00user</span> 0.00system 0:02.00elapsed 0%CPU <span class="er">(</span><span class="ex">0avgtext+0avgdata</span> 2176maxresident<span class="kw">)</span><span class="ex">k</span></span>
<span id="cb4-4"><a href="#cb4-4" tabindex="-1"></a><span class="ex">0inputs+0outputs</span> <span class="er">(</span><span class="ex">0major+90minor</span><span class="kw">)</span><span class="ex">pagefaults</span> 0swaps</span>
<span id="cb4-5"><a href="#cb4-5" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" tabindex="-1"></a><span class="co"># Compare the output to the Bash built-in:</span></span>
<span id="cb4-7"><a href="#cb4-7" tabindex="-1"></a><span class="ex">$</span> time sleep 2</span>
<span id="cb4-8"><a href="#cb4-8" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" tabindex="-1"></a><span class="ex">real</span>	0m2,003s</span>
<span id="cb4-10"><a href="#cb4-10" tabindex="-1"></a><span class="ex">user</span>	0m0,001s</span>
<span id="cb4-11"><a href="#cb4-11" tabindex="-1"></a><span class="ex">sys</span>	0m0,003s</span>
<span id="cb4-12"><a href="#cb4-12" tabindex="-1"></a></span>
<span id="cb4-13"><a href="#cb4-13" tabindex="-1"></a><span class="co"># Yet another output of `time` in zsh, an alternative shell implementation to bash</span></span>
<span id="cb4-14"><a href="#cb4-14" tabindex="-1"></a><span class="ex">$</span> time sleep 2</span>
<span id="cb4-15"><a href="#cb4-15" tabindex="-1"></a><span class="fu">sleep</span> 2  0,00s user 0,00s system 0% cpu 2,003 total</span></code></pre>
</div>
<p>Notice the different output formatting. All tools provide similar
insight, but the formatting and exact information may differ. So, if you
saw something that looks different from the bash built-in command, this
may be why!</p>
<p>Further note, that shell keyword documentation is invoked
via<code>help &lt;KEYWORD&gt;</code>, for example
<code>help time</code>, while most executables have manual pages,
e.g.,<code>man time</code>. At last, you can prefix the shell keyword
with a backslash in order to stop Bash from evaluating it,
so<code>\time sleep 2</code>will revert
to<code>/usr/bin/time</code>.</p>
</div>
</div>
</div>
</div>
</div>
<div class="section level3">
<h3 id="time-for-a-date">Time for a <code>date</code>
<a class="anchor" aria-label="anchor" href="#time-for-a-date"></a>
</h3>
<p>The<code>date</code>command, as its manpage (<code>man date</code>)
says, prints or sets the system date and time. In fact, this gives us a
super accurate stopwatch when used like this:</p>
<div class="codewrapper sourceCode" id="cb5">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a><span class="fu">date</span> +%s.%N</span></code></pre>
</div>
<p>reports a point in time as a number of seconds elapsed since a fixed
reference point.</p>
<div id="accordionSpoiler2" class="accordion spoiler-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button spoiler-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSpoiler2" aria-expanded="false" aria-controls="collapseSpoiler2">
  <h3 class="accordion-header" id="headingSpoiler2">  <div class="note-square"><i aria-hidden="true" class="callout-icon" data-feather="eye"></i></div> Epoch time </h3>
</button>
<div id="collapseSpoiler2" class="accordion-collapse collapse" aria-labelledby="headingSpoiler2" data-bs-parent="#accordionSpoiler2">
<div class="accordion-body">
<p>A referenced time point is also referred to as Epoch time, where,
according to the manpage of<code>date</code>, the (default) reference
point is the beginning of the year 1970, given as “1970-01-01 00:00
UTC”.</p>
</div>
</div>
</div>
</div>
<p>While<code>%s</code>invokes output of a referenced time, the
additional specifier<code>%N</code>enforces an accuracy down to
nanoseconds. Give it a try and you will see a large number (of seconds)
followed by 9 digits after the decimal point.</p>
<div id="an-accurate-stopwatch-date" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<span class="callout-header">Challenge</span>
<div id="an-accurate-stopwatch-date" class="callout-inner">
<h3 class="callout-title">An accurate stopwatch: <code>date</code>
</h3>
<div class="callout-content">
<p>You can use the construct<code>date +%s.%N</code>on the command line
or in a Bash script to save start and end time points as a variable:</p>
<div class="codewrapper sourceCode" id="cb6">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="va">start</span><span class="op">=</span><span class="va">$(</span><span class="fu">date</span> +%s.%N<span class="va">)</span></span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a><span class="co"># ... run some command(s)</span></span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a><span class="va">end</span><span class="op">=</span><span class="va">$(</span><span class="fu">date</span> +%s.%N<span class="va">)</span></span></code></pre>
</div>
<p>This gives you a stopwatch by setting a start time, running some
<strong>command(s)</strong>, and then storing the end time after
<strong>command(s)</strong> into a second variable. Differencing the two
times produces the elapsed time. Give this a try with
the<code>sleep</code>command in between.</p>
</div>
</div>
</div>
<div id="accordionHint1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button hint-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseHint1" aria-expanded="false" aria-controls="collapseHint1">
  <h4 class="accordion-header" id="headingHint1"> Give me a hint </h4>
</button>
<div id="collapseHint1" class="accordion-collapse collapse" aria-labelledby="headingHint1" data-bs-parent="#accordionHint1">
<div class="accordion-body">
<p>Differencing two numbers can be done, among other ways, using
the<code>bc</code>calculator tool:</p>
<div class="codewrapper sourceCode" id="cb7">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="bu">echo</span> <span class="st">"</span><span class="va">$end</span><span class="st"> - </span><span class="va">$start</span><span class="st">"</span> <span class="kw">|</span> <span class="fu">bc</span> <span class="at">-l</span></span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1"> Show me the solution </h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" aria-labelledby="headingSolution1" data-bs-parent="#accordionSolution1">
<div class="accordion-body">
<div class="codewrapper sourceCode" id="cb8">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a><span class="co">#!/usr/bin/env bash</span></span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a><span class="va">start</span><span class="op">=</span><span class="va">$(</span><span class="fu">date</span> +%s.%N<span class="va">)</span></span>
<span id="cb8-4"><a href="#cb8-4" tabindex="-1"></a><span class="fu">sleep</span> 2</span>
<span id="cb8-5"><a href="#cb8-5" tabindex="-1"></a><span class="va">end</span><span class="op">=</span><span class="va">$(</span><span class="fu">date</span> +%s.%N<span class="va">)</span></span>
<span id="cb8-6"><a href="#cb8-6" tabindex="-1"></a></span>
<span id="cb8-7"><a href="#cb8-7" tabindex="-1"></a><span class="bu">echo</span> <span class="st">"</span><span class="va">$end</span><span class="st"> - </span><span class="va">$start</span><span class="st">"</span> <span class="kw">|</span> <span class="fu">bc</span> <span class="at">-l</span></span></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</section><section><h2 class="section-heading" id="part-1-example-for-an-inefficient-job">Part 1: Example for an inefficient job<a class="anchor" aria-label="anchor" href="#part-1-example-for-an-inefficient-job"></a>
</h2>
<hr class="half-width">
<p>After warming up with some timing methods, let’s analyze the
efficiency of a small script that makes our computer sweat a bit more
than the<code>sleep</code>command. Have a look at the following Bash
shell 7-liner.</p>
<div class="codewrapper sourceCode" id="cb9">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a><span class="co">#!/bin/bash</span></span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a><span class="va">sum</span><span class="op">=</span>0</span>
<span id="cb9-3"><a href="#cb9-3" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="va">$(</span><span class="fu">seq</span> 1 1000<span class="va">)</span><span class="kw">;</span> <span class="cf">do</span></span>
<span id="cb9-4"><a href="#cb9-4" tabindex="-1"></a>  <span class="va">val</span><span class="op">=</span><span class="kw">`</span><span class="bu">echo</span> <span class="st">"e(2 * l(</span><span class="va">${i}</span><span class="st">))"</span> <span class="kw">|</span> <span class="fu">bc</span> <span class="at">-l</span><span class="kw">`</span></span>
<span id="cb9-5"><a href="#cb9-5" tabindex="-1"></a>  <span class="va">sum</span><span class="op">=</span><span class="va">$(</span><span class="bu">echo</span> <span class="st">"</span><span class="va">$sum</span><span class="st"> + </span><span class="va">$val</span><span class="st">"</span> <span class="kw">|</span> <span class="fu">bc</span> <span class="at">-l</span><span class="va">)</span></span>
<span id="cb9-6"><a href="#cb9-6" tabindex="-1"></a><span class="cf">done</span></span>
<span id="cb9-7"><a href="#cb9-7" tabindex="-1"></a><span class="bu">echo</span> Sum=<span class="va">$sum</span></span></code></pre>
</div>
<p>Copy-paste this to a file, say<code>sum.bash</code>, and make it
executable via</p>
<div class="codewrapper sourceCode" id="cb10">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a><span class="fu">chmod</span> u+x sum.bash</span></code></pre>
</div>
<p>The main part of this shell script consists of
a<code>for</code>statement which is calculating the sum of all squares
<span class="math inline">\(i^2\)</span> for 1000 iterations; note
that<code>seq 1 1000</code>creates the number sequence (<span class="math inline">\(i=1,2,3,...,1000\)</span>). Inside the
<code>for</code>loop the<code>bc</code>calculator tool is employed. The
first statement inside the loop (<code>val=...</code>) prints the
expression <code>e(2 * l(${i}))</code>, which is <code>bc</code>-talk
for the expression <span class="math inline">\(i^2\)</span> because of
the relation <span class="math inline">\(i^x=e^{x\cdot \ln(i)}\)</span>,
for example <span class="math inline">\(e^{2\cdot\ln(3)}=3^2\)</span>,
where ln is the natural logarithm. The second statement inside the loop
(<code>sum=...</code>) accumulates the expressions
<code>val=</code><span class="math inline">\(i^2\)</span>
into<code>sum</code>, so the output of the final<code>echo</code>line is
the total, <span class="math inline">\(\sum_{i=1}^{1000}i^2\)</span>.</p>
<div id="accordionInstructor3" class="accordion instructor-note accordion-flush">
<div class="accordion-item">
<button class="accordion-button instructor-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseInstructor3" aria-expanded="false" aria-controls="collapseInstructor3">
  <h3 class="accordion-header" id="headingInstructor3">  <div class="note-square"><i aria-hidden="true" class="callout-icon" data-feather="edit-2"></i></div> Instructor Note </h3>
</button>
<div id="collapseInstructor3" class="accordion-collapse collapse" aria-labelledby="headingInstructor3" data-bs-parent="#accordionInstructor3">
<div class="accordion-body">
<p>#TODO: Can we use <code>time</code> and <code>date</code> to find the
issue with the subshells?</p>
<p>Better to teach a way to find the issue, than staring at the script
and thinking about it</p>
</div>
</div>
</div>
</div>
<div id="identify-the-inefficient-pieces" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<span class="callout-header">Challenge</span>
<div id="identify-the-inefficient-pieces" class="callout-inner">
<h3 class="callout-title">Identify the inefficient pieces</h3>
<div class="callout-content">
<p>In the above Bash script, the<code>for</code>loop invokes the
<code>bc</code>calculator twice during every loop iteration. Compared to
another method to be investigated below, this method is rather slow. Any
idea why that is the case?</p>
</div>
</div>
</div>
<div id="accordionHint2" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button hint-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseHint2" aria-expanded="false" aria-controls="collapseHint2">
  <h4 class="accordion-header" id="headingHint2"> Give me a hint </h4>
</button>
<div id="collapseHint2" class="accordion-collapse collapse" aria-labelledby="headingHint2" data-bs-parent="#accordionHint2">
<div class="accordion-body">
<p>Each statement<code>echo … | bc -l</code>spawns a
new<code>bc</code>process via a subshell.</p>
</div>
</div>
</div>
</div>
<div id="accordionSolution2" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution2" aria-expanded="false" aria-controls="collapseSolution2">
  <h4 class="accordion-header" id="headingSolution2"> Show me the solution </h4>
</button>
<div id="collapseSolution2" class="accordion-collapse collapse" aria-labelledby="headingSolution2" data-bs-parent="#accordionSolution2">
<div class="accordion-body">
<p>The statement<code>echo … | bc -l</code>spawns a
new<code>bc</code>process via a subshell. Here, each loop iteration
invokes two of those. Each subshell is essentially a separate process
and involves a certain startup cost, parsing overhead, and OS-internal
inter‑process communication. Such overhead will account for most of the
total runtime of<code>sum.bash</code>.</p>
</div>
</div>
</div>
</div>
<p>The overhead in this shell script is dominated by process creation
and context switching, that is, calling the<code>bc</code>tool so many
times. Going back to our air-travel analogy, the summation of 1000
numbers shall be equivalent to having a total of 1000 passengers board a
large plane. When total boarding time counts, an inefficient boarding
procedure would involve every passenger loading two carryon pieces. Many
of you may have experienced, how stuffing an excessive number of baggage
pieces into the overhead compartments can slow things down in the
plane’s aisles, similar to the overhead due to the 2000 (two for each
loop iteration)<code>bc</code>sub-processes that hinder the data stream
inside the CPU’s “aisles”.</p>
<div id="lets-pull-out-our-stopwatches" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<span class="callout-header">Challenge</span>
<div id="lets-pull-out-our-stopwatches" class="callout-inner">
<h3 class="callout-title">Let’s pull out our stopwatches</h3>
<div class="callout-content">
<p>Using either<code>time</code>or<code>date</code>, can you get a
runtime measurement for<code>sum.bash</code>?</p>
</div>
</div>
</div>
<div id="accordionHint3" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button hint-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseHint3" aria-expanded="false" aria-controls="collapseHint3">
  <h4 class="accordion-header" id="headingHint3"> Give me a hint </h4>
</button>
<div id="collapseHint3" class="accordion-collapse collapse" aria-labelledby="headingHint3" data-bs-parent="#accordionHint3">
<div class="accordion-body">
<p>You can precede any command with<code>time</code>. If you want to
use<code>date</code>, remember that<code>now=$(date +%s.%N)</code>lets
you store the current time point and<code>&amp;&amp;</code>lets you join
commands together.</p>
</div>
</div>
</div>
</div>
<div id="accordionSolution3" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution3" aria-expanded="false" aria-controls="collapseSolution3">
  <h4 class="accordion-header" id="headingSolution3"> Show me the solution </h4>
</button>
<div id="collapseSolution3" class="accordion-collapse collapse" aria-labelledby="headingSolution3" data-bs-parent="#accordionSolution3">
<div class="accordion-body">
<p>A straightforward way is</p>
<div class="codewrapper sourceCode" id="cb11">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a><span class="bu">time</span> ./sum.bash</span></code></pre>
</div>
<p>Alternatively,<code>date</code>and<code>&amp;&amp;</code>can be
combined to a wrapper in order to
time<code>sum.bash</code>externally,</p>
<div class="codewrapper sourceCode" id="cb12">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a><span class="va">start</span><span class="op">=</span><span class="va">$(</span><span class="fu">date</span> +%s.%N<span class="va">)</span> <span class="kw">&amp;&amp;</span> <span class="ex">./sum.bash</span> <span class="kw">&amp;&amp;</span> <span class="va">end</span><span class="op">=</span><span class="va">$(</span><span class="fu">date</span> +%s.%N<span class="va">)</span> <span class="kw">&amp;&amp;</span> <span class="bu">echo</span> <span class="st">"</span><span class="va">$end</span><span class="st"> - </span><span class="va">$start</span><span class="st">"</span> <span class="kw">|</span> <span class="fu">bc</span> <span class="at">-l</span></span></code></pre>
</div>
<p>Another option is to place<code>date</code>inside the
script<code>sum.bash</code>,</p>
<div class="codewrapper sourceCode" id="cb13">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a><span class="co">#!/bin/bash</span></span>
<span id="cb13-2"><a href="#cb13-2" tabindex="-1"></a><span class="va">start</span><span class="op">=</span><span class="va">$(</span><span class="fu">date</span> +%s.%N<span class="va">)</span> <span class="co"># set start time</span></span>
<span id="cb13-3"><a href="#cb13-3" tabindex="-1"></a><span class="va">sum</span><span class="op">=</span>0</span>
<span id="cb13-4"><a href="#cb13-4" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="va">$(</span><span class="fu">seq</span> 1 1000<span class="va">)</span><span class="kw">;</span> <span class="cf">do</span></span>
<span id="cb13-5"><a href="#cb13-5" tabindex="-1"></a>  <span class="va">val</span><span class="op">=</span><span class="kw">`</span><span class="bu">echo</span> <span class="st">"e(2 * l(</span><span class="va">${i}</span><span class="st">))"</span> <span class="kw">|</span> <span class="fu">bc</span> <span class="at">-l</span><span class="kw">`</span></span>
<span id="cb13-6"><a href="#cb13-6" tabindex="-1"></a>  <span class="va">sum</span><span class="op">=</span><span class="va">$(</span><span class="bu">echo</span> <span class="st">"</span><span class="va">$sum</span><span class="st"> + </span><span class="va">$val</span><span class="st">"</span> <span class="kw">|</span> <span class="fu">bc</span> <span class="at">-l</span><span class="va">)</span></span>
<span id="cb13-7"><a href="#cb13-7" tabindex="-1"></a><span class="cf">done</span></span>
<span id="cb13-8"><a href="#cb13-8" tabindex="-1"></a><span class="va">end</span><span class="op">=</span><span class="va">$(</span><span class="fu">date</span> +%s.%N<span class="va">)</span> <span class="co"># set end time</span></span>
<span id="cb13-9"><a href="#cb13-9" tabindex="-1"></a><span class="bu">echo</span> Sum=<span class="va">$sum</span> runtime=<span class="kw">`</span><span class="bu">echo</span> <span class="st">"</span><span class="va">$end</span><span class="st"> - </span><span class="va">$start</span><span class="st">"</span> <span class="kw">|</span> <span class="fu">bc</span> <span class="at">-l</span><span class="kw">`</span></span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="section level3">
<h3 id="speeding-things-up">Speeding things up<a class="anchor" aria-label="anchor" href="#speeding-things-up"></a>
</h3>
<p>A remedy to the inefficiencies we found inside
the<code>for</code>loop of<code>sum.bash</code>is to avoid the spawning
of many sub-processes that are caused by repetitively
calling<code>bc</code>. In other words, ideally, the many sub-processes
conflate into one. In terms of the airplane analogy, we want people to
store all their carryon pieces in a big container, where its subsequent
loading onto the plane is a single process, as opposed to every
passenger running a proprietary sub-process. Collapsing things into one
sub-processes can be achieved by replacing the external loop by
a<code>bc</code>-internal one:</p>
<div class="codewrapper sourceCode" id="cb14">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a><span class="bu">echo</span> <span class="st">"s=0; for(i=1; i&lt;=1000; i++)s+=i^2; s"</span> <span class="kw">|</span> <span class="fu">bc</span> <span class="at">-l</span></span></code></pre>
</div>
<p>In this method, to be called the <em>one-liner</em>, the loop,
arithmetic, and accumulation are free of the overhead. This example
shall be a placeholder for a common scenario, where potentially large
efficiency gains can be achieved by replacing inefficient math
implementations by numerically optimized software
<em>libraries</em>.</p>
<div id="evaluate-the-runtime-improvement" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<span class="callout-header">Challenge</span>
<div id="evaluate-the-runtime-improvement" class="callout-inner">
<h3 class="callout-title">Evaluate the runtime improvement</h3>
<div class="callout-content">
<p>Compare the runtimes of the summation
script<code>sum.bash</code>versus the one-liner.</p>
</div>
</div>
</div>
<div id="accordionHint4" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button hint-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseHint4" aria-expanded="false" aria-controls="collapseHint4">
  <h4 class="accordion-header" id="headingHint4"> Give me a hint </h4>
</button>
<div id="collapseHint4" class="accordion-collapse collapse" aria-labelledby="headingHint4" data-bs-parent="#accordionHint4">
<div class="accordion-body">
<p>The Bash keyword<code>time</code>is sufficient to see the runtime
difference.</p>
</div>
</div>
</div>
</div>
<div id="accordionSolution4" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution4" aria-expanded="false" aria-controls="collapseSolution4">
  <h4 class="accordion-header" id="headingSolution4"> Show me the solution </h4>
</button>
<div id="collapseSolution4" class="accordion-collapse collapse" aria-labelledby="headingSolution4" data-bs-parent="#accordionSolution4">
<div class="accordion-body">
<p>You can use<code>time</code>for both summation methods,</p>
<div class="codewrapper sourceCode" id="cb15">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a><span class="bu">time</span> ./sum.bash</span>
<span id="cb15-2"><a href="#cb15-2" tabindex="-1"></a><span class="bu">time</span> echo <span class="st">"s=0; for(i=1; i&lt;=1000; i++)s+=i^2; s"</span> <span class="kw">|</span> <span class="fu">bc</span> <span class="at">-l</span></span></code></pre>
</div>
</div>
</div>
</div>
</div>
<p>While it depends a bit on the employed hardware, one will notice that
the one-liner runs roughly 1000 times faster than<code>sum.bash</code>.
Of course, one could live with this inefficiency when it is just needed
once in a while and the script’s overall runtime amounts to just a few
seconds. However, imagine some large-scale computing job that is
supposed to finish within an hour on a supercomputer for which one has
to pay a usage fee on a per-hour basis. If implemented poorly, an
already small overhead increase, say by a factor of 2, would render this
computing job expensive, both in terms of time and money.</p>
<div id="accordionSpoiler3" class="accordion spoiler-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button spoiler-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSpoiler3" aria-expanded="false" aria-controls="collapseSpoiler3">
  <h3 class="accordion-header" id="headingSpoiler3">  <div class="note-square"><i aria-hidden="true" class="callout-icon" data-feather="eye"></i></div> CPU-bound versus memory-bound </h3>
</button>
<div id="collapseSpoiler3" class="accordion-collapse collapse" aria-labelledby="headingSpoiler3" data-bs-parent="#accordionSpoiler3">
<div class="accordion-body">
<p>The above runtime comparisons merely look at calculation speed, which
depends on CPU processing speed. Such a task is thus called
<em>CPU-bound</em>. On the other hand, the performance of a
<em>memory-bound</em> process is limited by the speed of memory access.
This happens when the CPU spends most of its time waiting for data to be
fetched from memory (RAM), cache, or storage, causing its execution
pipeline to stall. Optimization of memory-bound tasks addresses
performance bottlenecks due to data transfer speeds rather than
calculation speeds. Finally, when data transfer involves a high
percentage of disk or network access, disk/networking speed becomes a
limiting factor, rendering a process <em>I/O-bound</em>.</p>
</div>
</div>
</div>
</div>
</div>
<div class="section level3">
<h3 id="to-be-precise-numerical-efficiency">To be precise: Numerical efficiency<a class="anchor" aria-label="anchor" href="#to-be-precise-numerical-efficiency"></a>
</h3>
<div id="accordionInstructor4" class="accordion instructor-note accordion-flush">
<div class="accordion-item">
<button class="accordion-button instructor-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseInstructor4" aria-expanded="false" aria-controls="collapseInstructor4">
  <h3 class="accordion-header" id="headingInstructor4">  <div class="note-square"><i aria-hidden="true" class="callout-icon" data-feather="edit-2"></i></div> TODO: Maybe move discussion eleswere? </h3>
</button>
<div id="collapseInstructor4" class="accordion-collapse collapse" aria-labelledby="headingInstructor4" data-bs-parent="#accordionInstructor4">
<div class="accordion-body">
<p>Quality and necessity of calculations are important factors in
efficiency. Redundant calculations are inefficient, for example. This
section may be still too much of a detour from the introduction, at
least in its current form. May be a chance to shorten the episode as
well</p>
</div>
</div>
</div>
</div>
<p>Inefficient computing is not only limited to being unnecessarily
slow. It can also entail the scenario where an excessive accuracy can
lead to unnecessary runtime increases. Without going into details, let’s
just keep in mind that in computing, accuracy depends on the
<em>precision</em> of the numbers that are being processed by the CPU.
Precision essentially governs how many digits after the decimal point
are accounted for in mathematical operations. The higher the precision,
the fewer calculations can be processed within a fixed time. On the
other hand, within that same time, the CPU can crank through more
low-precision numbers; however, an insufficient precision can render
lengthy calculations useless. The optimal degree of precision, in terms
of computing efficiency, is application dependent.</p>
<!---
The internal accuracy of`bc`is defined by an adjustable parameter`scale`which
defines how some operations use digits after the decimal point. The default value of`scale`is 0.
During each`bc`call within the summation loop of`sum.bash`, the intermediate result is rounded
according to the current setting of`scale`. An insufficiently low precision setting
leads to an accumulation of rounding errors over many loop iterations,
rendering the final result (like a sum or product) erroneous.--->
<div id="compare-numerical-results" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<span class="callout-header">Challenge</span>
<div id="compare-numerical-results" class="callout-inner">
<h3 class="callout-title">Compare numerical results</h3>
<div class="callout-content">
<p>Our summation implementation via<code>sum.bash</code>exemplifies the
case of an inaccurate calculation. When running the two summation
methods in the previous challenge, have a look at the actual summation
results. Which of the two end results do you think is more accurate and
why? Is the erroneous result smaller or larger and why?</p>
</div>
</div>
</div>
<div id="accordionHint5" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button hint-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseHint5" aria-expanded="false" aria-controls="collapseHint5">
  <h4 class="accordion-header" id="headingHint5"> Give me a hint </h4>
</button>
<div id="collapseHint5" class="accordion-collapse collapse" aria-labelledby="headingHint5" data-bs-parent="#accordionHint5">
<div class="accordion-body">
<p>Think of another airplane example. Which scenario is more prone to
things getting lost or forgotten? 1) Passengers bring and take their own
baggage pieces to the cabin, or 2) Baggage pieces are stored and
retrieved collectively.</p>
</div>
</div>
</div>
</div>
<div id="accordionSolution5" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution5" aria-expanded="false" aria-controls="collapseSolution5">
  <h4 class="accordion-header" id="headingSolution5"> Show me the solution </h4>
</button>
<div id="collapseSolution5" class="accordion-collapse collapse" aria-labelledby="headingSolution5" data-bs-parent="#accordionSolution5">
<div class="accordion-body">
<p>The method<code>sum.bash</code>, using the
external<code>for</code>loop, and the one-liner return the final sums,
respectively,</p>
<pre><code><span><span class="fl">103075329</span>  <span class="co"># bc, external loop (sum.bash)</span></span>
<span><span class="fl">333833500</span>  <span class="co"># bc, internal loop (one-liner)</span></span></code></pre>
<p>where the first result may vary on your machine. The
method<code>sum.bash</code>is affected by the setting of the
<code>bc</code>-internal parameter<code>scale</code>which defines how
some operations, here the exponential function <strong>e(…)</strong> and
logarithm <strong>ln(…)</strong> use digits after the decimal point. The
default value of<code>scale</code>is 0, which basically leads to
truncations after the decimal point, so rounding errors accumulate at
every loop iteration. Hence, the final sum drifts downward (by a lot)
compared to the second (true) value. Of course,<code>scale</code>can be
increased. The manpage of<code>bc</code>actually says that it is “an
arbitrary precision calculator language”.</p>
</div>
</div>
</div>
</div>
</div>
</section><section><h2 class="section-heading" id="part-2-about-hpc-power-consumption">Part 2: About HPC power consumption<a class="anchor" aria-label="anchor" href="#part-2-about-hpc-power-consumption"></a>
</h2>
<hr class="half-width">
<p>The <em>HP</em> (high performace) in HPC refers to the fact that the
employed computer hardware is able to do a lot of multitasking, also
called parallel computing. Parallel programming essentially exploits the
CPU’s multitasking ability. Therefore, a lot of HPC-efficiency aspects
revolve around keeping everyone in a CPU’s multitasking team equally
busy. We will look at some of those aspects during the course of later
episodes.</p>
<div id="accordionInstructor5" class="accordion instructor-note accordion-flush">
<div class="accordion-item">
<button class="accordion-button instructor-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseInstructor5" aria-expanded="false" aria-controls="collapseInstructor5">
  <h3 class="accordion-header" id="headingInstructor5">  <div class="note-square"><i aria-hidden="true" class="callout-icon" data-feather="edit-2"></i></div> TODO: Add actions / live-coding to sections below? </h3>
</button>
<div id="collapseInstructor5" class="accordion-collapse collapse" aria-labelledby="headingInstructor5" data-bs-parent="#accordionInstructor5">
<div class="accordion-body">
<p>Maybe too much info vs. too little activity, currently?</p>
</div>
</div>
</div>
</div>
<div class="section level3">
<h3 id="the-more-the-merrier-cpugpu-cores">The more the merrier: CPU/GPU cores<a class="anchor" aria-label="anchor" href="#the-more-the-merrier-cpugpu-cores"></a>
</h3>
<p>Common parallel-computing jobs employ multiple cores of a CPU, or
even multiple CPUs, simultaneously. A core is a processing unit within a
CPU that independently executes instructions. These days (as of 2025),
typical CPUs are quad-core (4 cores), octa-core (8 cores), and so on.
High-end gaming CPUs often have 16+ cores, HPC cluster nodes feature
multiple CPUs, oftentimes with 64+ cores each; and all these numbers
keep going up.</p>
<p>Nowadays, almost all HPC centers are also equipped with GPU (Graphics
Processing Unit) hardware. Such hardware is optimal for jobs where
<em>many cores</em> is more important than fewer powerful cores.<br>
The number of GPU cores varies greatly depending on the model, ranging
from a few hundred in low-end GPU cards to over 16,000 in high-end
ones.</p>
</div>
<div class="section level3">
<h3 id="measuring-parallel-runtime-core-hours">Measuring parallel runtime: core hours<a class="anchor" aria-label="anchor" href="#measuring-parallel-runtime-core-hours"></a>
</h3>
<p>Owing to the inherent parallelism in the HPC world, people came up
with some measure which takes the <em>granularity</em> into account when
allocating not only runtime but also the number of requested cores. The
unit <strong>core hour</strong> (<strong>core-h</strong>) represents the
usage of one CPU core for one hour and scales with core count. For
example, assume you have a monthly allocation of 500 core-h, with a fee
incurred when exceeding that quota. So with 500 core-h, you could run a
one-hour parallel job utilizing 500 CPU cores for free. Or, in the other
extreme, if your program does not or cannot multitask, you could run a
single-core job for 500 hours, provided you won’t forget at the end what
this job was about.</p>
<div id="accordionSpoiler4" class="accordion spoiler-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button spoiler-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSpoiler4" aria-expanded="false" aria-controls="collapseSpoiler4">
  <h3 class="accordion-header" id="headingSpoiler4">  <div class="note-square"><i aria-hidden="true" class="callout-icon" data-feather="eye"></i></div> Other HPC resource types </h3>
</button>
<div id="collapseSpoiler4" class="accordion-collapse collapse" aria-labelledby="headingSpoiler4" data-bs-parent="#accordionSpoiler4">
<div class="accordion-body">
<p>So far, the focus has been on core number and hours for HPC resource
allocation. Keep in mind, however, that the HPC resource portfolio
involves other hardware components as well:</p>
<ul>
<li>Memory: There are (whether parallel or not) jobs, that request a
large amount of memory (RAM). For example, some mathematical solution
methods for large equation systems do not allow the compartmentalization
of the total required memory across CPU cores, that is, many-core
processes need to know each other’s memory chunks. HPC centers usually
have large-memory nodes assigned for such applications.</li>
<li>Storage: Other applications process huge amounts of data, think of
genomics or climate modelling, which can involve terabytes or even
petabytes of data to be stored and analyzed.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="section level3">
<h3 id="a-typical-hpc-computing-job">A typical HPC computing job<a class="anchor" aria-label="anchor" href="#a-typical-hpc-computing-job"></a>
</h3>
<p>Like in the automotive world, high performance means high power,
which in turn involves a high energy demand. Let’s consider a typical
parallel scientific-computing job to be run in some HPC center. Our
example job shall be deemed too large for one CPU, so it employs
multiple CPUs, which in turn are distributed across nodes. Node power
usage is measured in W=Watt, which is the SI unit of power and
corresponds to the rate of consumption of energy in an electric circuit.
One compute node with a 64-core CPU can consume between 300 W in idle
state, and 900 W (maximum load) for air-cooled systems, whereas this
range is roughly 250-850 W for the slightly more efficient liquid-cooled
systems. For comparison, an average coffee maker consumes between 800 W
(drip coffee maker) and 1500 W (espresso machine). Our computing job
shall then use these resources:</p>
<ul>
<li>12 nodes are crunching numbers in parallel</li>
<li>64 cores/node (e.g., Intel® Xeon® 6774P, or AMD® EPYC® 9534)</li>
<li>12 hours of full load (realistic for many scientific
simulations)</li>
<li>Power per node: (idle vs. full load):
<ul>
<li>Idle: ~300 W</li>
<li>Full load: ~900 W</li>
<li>Extra power per node: 600 W</li>
</ul>
</li>
<li>Total extra power: 12 nodes × 600 W × 12 hours = 86,400 Wh = 86.4
kWh</li>
</ul>
<div id="how-many-core-hours-does-this-job-involve" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<span class="callout-header">Challenge</span>
<div id="how-many-core-hours-does-this-job-involve" class="callout-inner">
<h3 class="callout-title">How many core hours does this job
involve?</h3>
<div class="callout-content">
<p>HPC centers have different job <em>queues</em> for different kinds of
computing jobs. For example, a queue named <em>big-jobs</em> may be
reserved for jobs exceeding a total of 1024 parallel processes =
<em>tasks</em>. Another queue named <em>big-mem</em> may accomodate
tasks with high memory demands by giving access to high-memory nodes
(e.g., 512 GB, 1 TB, or more RAM per compute node).</p>
<p>Let’s assume, you have three job queues available, all with identical
memory layout:</p>
<ul>
<li>
<code>small-jobs</code>: Total task count of up to 511.</li>
<li>
<code>medium-jobs</code>: Total task count 512-1023.</li>
<li>
<code>big-jobs</code>: Total task count of 1024 or more.</li>
</ul>
<p>When submitting the above computing job, in which queue would it end
up? And, if there would be a charge of 1 Cent per core-h, what is the
total cost in € (1€ = 100 Cents)?</p>
</div>
</div>
</div>
<div id="accordionHint6" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button hint-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseHint6" aria-expanded="false" aria-controls="collapseHint6">
  <h4 class="accordion-header" id="headingHint6"> Give me a hint </h4>
</button>
<div id="collapseHint6" class="accordion-collapse collapse" aria-labelledby="headingHint6" data-bs-parent="#accordionHint6">
<div class="accordion-body">
<p>The total number of tasks results from the product
<em>cores-per-node</em> <span class="math inline">\(\times\)</span>
<em>nodes</em>. Total core hours is the task count multiplied by the
job’s requested time in hours.</p>
</div>
</div>
</div>
</div>
<div id="accordionSolution6" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution6" aria-expanded="false" aria-controls="collapseSolution6">
  <h4 class="accordion-header" id="headingSolution6"> Show me the solution </h4>
</button>
<div id="collapseSolution6" class="accordion-collapse collapse" aria-labelledby="headingSolution6" data-bs-parent="#accordionSolution6">
<div class="accordion-body">
<p>The total number of tasks is <em>cores-per-node</em> <span class="math inline">\(\times\)</span> <em>nodes</em> = <span class="math inline">\(64\times 12 = 768\)</span>, which would put the
job into the<code>medium-jobs</code>queue. The HPC center would bill us
for <span class="math inline">\(64\times 12\times 12 = 9216\)</span>
core hours, hence €92.16.</p>
</div>
</div>
</div>
</div>
</div>
<div class="section level3">
<h3 id="what-are-watt-hours">What are Watt hours?<a class="anchor" aria-label="anchor" href="#what-are-watt-hours"></a>
</h3>
<p>The unit Wh (Watt-hours) measures energy, so 86,400 Wh is the energy
that a 86,400 W (or 86.4 kW, k=kilo) powerful machine consumes in one
hour. Back to coffee, brewing one cup needs 50-100 Wh, depending on
preparation time and method. So, running your 12-node HPC job for 12
hours is equivalent to brewing between 864 and 1,728 cups of coffee. For
those of us who don’t drink coffee, assuming 100% conversion efficiency
from our compute job’s heat to mechanical energy, which is unrealistic,
we could lift an average African elephant (~6 tons) about 5,285 meters
straight up, not quite to the top but in sight of Mount Kilimanjaro’s
(5,895 m) summit.</p>
<div id="accordionSpoiler5" class="accordion spoiler-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button spoiler-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSpoiler5" aria-expanded="false" aria-controls="collapseSpoiler5">
  <h3 class="accordion-header" id="headingSpoiler5">  <div class="note-square"><i aria-hidden="true" class="callout-icon" data-feather="eye"></i></div> Power-consuming hardware pieces </h3>
</button>
<div id="collapseSpoiler5" class="accordion-collapse collapse" aria-labelledby="headingSpoiler5" data-bs-parent="#accordionSpoiler5">
<div class="accordion-body">
<p>Note that the focus is on <strong>extra</strong> power, that is,
beyond the CPU’s idle state. Attributing our job’s extra power only to
CPU usage underestimates its footprint. In practice, the actual delta
from idle to full load will vary based on the load posed on other
hardware components. Therefore, it is interesting to shed some light
onto those other hardware components that start gearing up after hitting
that Enter key which submits the above kind of HPC job.</p>
<ul>
<li>
<p>CPUs consume power through two main processes:</p>
<ol style="list-style-type: decimal">
<li>Dynamic power consumption: It is caused by the constant switching of
transistors and is influenced by the CPU’s clock frequency and
voltage.</li>
<li>Static power consumption: It is caused by small leakage currents
even when the CPU is idle. This is a function of the total number of
transistors.</li>
</ol>
<p>Both processes convert electrical energy into heat, which makes CPU
cooling so important.</p>
</li>
<li><p>Memory (DRAM) consumes power primarily through its refresh
cycles. These are required to counteract the charge leakage in the
data-storing capacitors. Periodic refreshing is necessary to maintain
data integrity, which is the main reason why DRAM draws power even when
idle. Other power consumption factors include the static power drawn by
the memory’s circuitry and the active power used during read/write
operations.</p></li>
<li><p>Network interface cards (NICs) consume power by converting
digital data into electrical signals for transmission and reception.
Power draw increases with data throughput, physical-media complexity,
like fiber optics, and also depends on the specific interconnect
technology used.</p></li>
<li><p>Storage components: Hard drives (HDDs) require constant energy
due to moving mechanical parts, like the disc-spinning motors. SSDs
store data electronically via flash memory chips and are thus more
power-efficient, especially when idle. However, when performing heavy
read/write tasks, SSD power consumption can also be significant, though
they complete these tasks faster than HDDs and return to their idle
state sooner.</p></li>
<li>
<p>Cooling is one of the biggest contributors to total energy use in
HPC:</p>
<ul>
<li>Idle: Cooling uses ~10–20% of total system power.</li>
<li>Max load: Cooling can consume ~50–70% of total power (depends on
liquid- or air-cooled systems).</li>
</ul>
<p>Cooling is essential because all electrical circuits generate heat
during operation. Under heavy computational loads, insufficiently cooled
CPUs and GPUs exceed their safe temperature limits.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<p>These considerations hopefully highlight why there is benefit in
identifying potential efficiency bottlenecks before submitting an
energy-intense HPC job. If all passengers care about efficient job
design, i.e., the total baggage load, more can simultaneously jump onto
the HPC plane.</p>
<!---
 Use timing commands provided by `time`and`date`.
- Understand the benefits of efficient jobs in terms of runtime and numerical accuracy.
- Have developed some awareness about the overall high energy consumption of HPC.
--->
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<span class="callout-header">Key Points</span>
<div class="callout-inner">
<div class="callout-content">
<ul>
<li>Using a <em>stopwatch</em> like<code>time</code>gives you a first
tool to log actual versus expected runtimes; it is also useful for
carrying out runtime comparisons.</li>
<li>Which hardware piece (CPU, memory/RAM, disk, network, etc.) poses a
limiting factor, depends on the nature of a particular application.</li>
<li>Large-scale computing is power hungry, so we want to use the energy
wisely. As shown in the next episodes, you have more <em>power</em> than
it may be expected over controlling job efficiency and thus overall
energy footprint.</li>
<li>Computing job efficiency goes beyond individual gain in runtime as
shared resources are used more effectively, that is, the ratio <span class="math inline">\(\frac{useful\;work}{total\;energy\;expended}\sim\frac{number\;of\;users}{total\;energy\;expended}\)</span>
improves.</li>
</ul>
</div>
</div>
</div>
</div>
</section><section><h2 class="section-heading" id="so-whats-next">So what’s next?<a class="anchor" aria-label="anchor" href="#so-whats-next"></a>
</h2>
<hr class="half-width">
<p>The following episodes will put a number of these introductory
thoughts into concrete action by looking at efficiency aspects around a
compute-intense graphical program. While it is not directly an
action-loaded video game, it does contain essential pieces thereof,
because it uses the technique of ray tracing.</p>
<p>Ray tracing is a technique that simulates how light travels in a 3D
scene to create realistic images. It simulates the behaviour of light in
terms of optical effects like reflection, refraction, shadows,
absorption, etc. The underlying calculations involve real-world physics,
which makes them computationally expensive - a perfect HPC case.</p>
<p>Here is a basic run script:</p>
<pre><code>#!/usr/bin/bash
#SBATCH --time=01:00:00
#SBATCH --nodes=1
#SBATCH --tasks-per-node=4

# Put in the same "module load ..." command when building the raytracer program

time mpirun -np 4 raytracer -width=800 -height=800 -spp=128</code></pre>
<p>Check the<code>time</code>output at the end of the job’s output file
(named something like <code>slurm-&lt;NUMBER&gt;.out</code>). You will
notice that <em>user</em> time is by a certain factor larger than
<em>real</em> time.</p>
<div id="discussion1" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<span class="callout-header">Discussion</span>
<div class="callout-inner">
<div class="callout-content">
<p>Why is the <code>user</code> timer larger than the <code>real</code>
time, and what does it mean?</p>
<p>Any guess which number in the <code>mpirun</code>line corresponds
roughly to that factor?</p>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</section></section><section id="aio-02_resourcerequirements"><p>Content from <a href="02_resourcerequirements.html">Resource Requirements</a></p>
<hr>
<p>Last updated on 2025-12-15 |

        <a href="https://github.com/stderr-enst/jobefficiency/edit/main/episodes/02_resourcerequirements.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 10 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>How many resources should I request initially?</li>
<li>What scheduler options exist to request resources?</li>
<li>How do I know if they are used well?</li>
<li>How large is my HPC cluster?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<p>After completing this episode, participants should be able to …</p>
<ul>
<li>Identify the size of their jobs in relation to the HPC system.</li>
<li>Request a good amount of resources from the scheduler.</li>
<li>Change the parameters to see how the execution time changes.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<p>When you run a program on your local workstation or laptop, you
typically don’t plan out the usage of computing resources like memory or
core-hours. Your applications simply take as much as they need and if
your computer runs out of resources, you can just a few. However, unless
you are very rich, you probably don’t have a dedicated HPC cluster just
to yourself and instead you have to share one with your colleagues. In
such a scenario greedily consuming as many resources as possible is very
impolite, so we need to restrain ourselves and carefully allocate just
as many resources as needed. These resource constraints are then
enforced by the cluster’s scheduling system so that you cannot
accidentally use more resources than you think.</p>
<section><h2 class="section-heading" id="getting-a-feel-for-the-size-of-your-cluster">Getting a feel for the size of your cluster<a class="anchor" aria-label="anchor" href="#getting-a-feel-for-the-size-of-your-cluster"></a>
</h2>
<hr class="half-width">
<p>To start with your resource planning, it is always a good idea to
first get a feeling for the size of the cluster available to you. For
example, if your cluster has tens of thousands of CPU cores and you use
only 10 of them, you are far away from what would be considered
excessive usage of resources. However, if your calculation utilizes GPUs
and your cluster has only a handful of them, you should really make sure
to use only the minimum amount necessary to get your work done.</p>
<p>Let’s start by getting an overview of the partitions of your
cluster:</p>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="ex">sinfo</span> <span class="at">-O</span> PartitionName,Nodes,CPUs,Memory,Gres,Time</span></code></pre>
</div>
<div id="accordionSpoiler1" class="accordion spoiler-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button spoiler-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSpoiler1" aria-expanded="false" aria-controls="collapseSpoiler1">
  <h3 class="accordion-header" id="headingSpoiler1">  <div class="note-square"><i aria-hidden="true" class="callout-icon" data-feather="eye"></i></div> Show details </h3>
</button>
<div id="collapseSpoiler1" class="accordion-collapse collapse" data-bs-parent="#accordionSpoiler1" aria-labelledby="headingSpoiler1">
<div class="accordion-body">
<p>Here is a (simplified) example output for the command above:</p>
<pre><code>PARTITION           NODES               CPUS                MEMORY              GRES                TIMELIMIT
normal              223                 36                  95000+              (null)              1-00:00:00
long                90                  36                  192000              (null)              7-00:00:00
express             6                   36                  95000+              (null)              2:00:00
zen4                46                  192                 763758+             (null)              2-00:00:00
gpuexpress          1                   32                  240000              gpu:rtx2080:7       12:00:00
gpu4090             8                   32                  360448              gpu:rtx4090:6       7-00:00:00
gpuh200             4                   128                 1547843             gpu:h200:8          7-00:00:00</code></pre>
</div>
</div>
</div>
</div>
<p>In the output, we see the name of each partition, the number of nodes
in this partition, the number of CPU cores per node, the amount of
memory per node (in Megabytes <span style="color: red">(or
Mebibytes?)</span>), the number of <em>generic resources</em> (typically
GPUs) per node and finally the maximum amount of time any job is allowed
to take.</p>
<div id="discussion1" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<span class="callout-header">Discussion</span>
<div class="callout-inner">
<div class="callout-content">
<p>Compare the resources available in the different partitions of your
local cluster. Can you draw conclusions on what the purpose of each
partition is based on the resources it contains?</p>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1"> Show me the solution </h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" data-bs-parent="#accordionSolution1" aria-labelledby="headingSolution1">
<div class="accordion-body">
<p>For our example output above we can make some educated guesses on
what the partitions are supposed to be used for:</p>
<ul>
<li>The <code>normal</code> partition has a (relatively) small amount of
memory and limits jobs to at most one day, but has by far the most
nodes. This partition is probably designed for small- to medium-sized
jobs. Since there are no <code>GRES</code> in this partition, only CPU
computations can be performed here. Also, as the number of cores per
node is (relatively) small, this partition only allowd multithreading up
to 36 threads and requires MPI for a higher degree of parallelism.</li>
<li>The <code>long</code> partition has double the memory compared to
the <code>normal</code> partition, but less than half the number of
nodes. It also allows for much longer running jobs. This partition is
likely intended for jobs that are too big for the <code>normal</code>
partition.</li>
<li>
<code>express</code> is a very small partition with a similar
configuration to <code>normal</code>, but a very short time limit of
only 2 hours. The purpose of this partition is likely testing and very
short running jobs like software compilation.</li>
<li>Unlike the former partitions, <code>zen4</code> has a lot more cores
and memory per node. The intent of this partition is probably to run
jobs using large-scale multithreading. The name of the partitions
implies a certain CPU generation (AMD Zen 4), which appears to be newer
than the CPU model used in the <code>normal</code>, <code>long</code>
and <code>express</code> partitions (typically core counts increase in
newer CPU generations).</li>
<li>
<code>gpuexpress</code> is the first partition that features GPU
resources. However, with only a single node and a maximum job duration
of 12 hours, this partition seems to be intended again for testing
purposes rather than large-scale computations. This also matches the
relatively old GPU model.</li>
<li>In contrast, <code>gpu4090</code> has more nodes and a much longer
walltime of seven days and is thus suitable for actual HPC workloads.
Given the low number of CPU cores, this partition is intended for GPU
workloads only. More details can be gleamed from the GPU model used in
this partition (RTX 4090). This GPU type is typically used for Workloads
using <em>single-precision</em> floating point calculations.</li>
<li>Finally, the <code>gpuh200</code> partition combines a large number
of very powerful H200 GPUs with a high core count and a very large
amount of memory. This partition seems to be intended for the heaviest
workloads that can make use of both CPU and GPU resources. The drawback
is the low number of nodes in this partition.</li>
</ul>
</div>
</div>
</div>
</div>
<div id="accordionInstructor1" class="accordion instructor-note accordion-flush">
<div class="accordion-item">
<button class="accordion-button instructor-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseInstructor1" aria-expanded="false" aria-controls="collapseInstructor1">
  <h3 class="accordion-header" id="headingInstructor1">  <div class="note-square"><i aria-hidden="true" class="callout-icon" data-feather="edit-2"></i></div> Instructor Note </h3>
</button>
<div id="collapseInstructor1" class="accordion-collapse collapse" data-bs-parent="#accordionInstructor1" aria-labelledby="headingInstructor1">
<div class="accordion-body">
<p>This discussion highly depends on the management philosophy of the
cluster available to the learners. Some examples:</p>
<ul>
<li>A partition with a high number of cores large amounts of memory per
node is probably intended for SMP calculations.</li>
<li>A partition with a lot of nodes that each have only a (relatively)
small number of cores and memory is probably intended for MPI
calculations.</li>
<li>A partition with powerful GPUs, but only a small amount of CPU cores
is likely intended for jobs where the majority of the work is offloaded
to the GPUs.</li>
<li>A partition with less powerful GPUs but more CPU cores and memory is
likely intended for hybrid workloads.</li>
</ul>
</div>
</div>
</div>
</div>
<p>To get a point of reference, you can also compare the total number of
cores in the entire cluster to the number of CPU cores on the login node
or on your local machine.</p>
<div class="codewrapper sourceCode" id="cb3">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="ex">lscpu</span> <span class="kw">|</span> <span class="fu">grep</span> <span class="st">"CPU(s):"</span></span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a><span class="co"># If lscpu is not available on your machine, you can also use this command</span></span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a><span class="fu">cat</span> /proc/cpuinfo <span class="kw">|</span> <span class="fu">grep</span> <span class="st">"core id"</span> <span class="kw">|</span> <span class="fu">wc</span> <span class="at">-l</span></span></code></pre>
</div>
<div id="accordionSpoiler2" class="accordion spoiler-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button spoiler-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSpoiler2" aria-expanded="false" aria-controls="collapseSpoiler2">
  <h3 class="accordion-header" id="headingSpoiler2">  <div class="note-square"><i aria-hidden="true" class="callout-icon" data-feather="eye"></i></div> Show details </h3>
</button>
<div id="collapseSpoiler2" class="accordion-collapse collapse" data-bs-parent="#accordionSpoiler2" aria-labelledby="headingSpoiler2">
<div class="accordion-body">
<div class="codewrapper sourceCode" id="cb4">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a><span class="ex">$</span> lscpu <span class="kw">|</span> <span class="fu">grep</span> <span class="st">"CPU(s):"</span></span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a><span class="ex">CPU</span><span class="er">(</span><span class="ex">s</span><span class="kw">)</span><span class="bu">:</span>                               192</span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a><span class="ex">NUMA</span> node0 CPU<span class="er">(</span><span class="ex">s</span><span class="kw">)</span><span class="bu">:</span>                    0-191</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb5">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a><span class="ex">$</span> cat /proc/cpuinfo <span class="kw">|</span> <span class="fu">grep</span> <span class="st">"core id"</span> <span class="kw">|</span> <span class="fu">wc</span> <span class="at">-l</span></span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a><span class="ex">192</span></span></code></pre>
</div>
</div>
</div>
</div>
</div>
<p>As you can see, your cluster likely has <em>multiple orders of
magnitude</em> more cores in total than the login node or your local
machine. To see the amount of memory on the machine you are logged into
you can use</p>
<div class="codewrapper sourceCode" id="cb6">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="fu">cat</span> /proc/meminfo <span class="kw">|</span> <span class="fu">grep</span> <span class="st">"MemTotal"</span></span></code></pre>
</div>
<div id="accordionSpoiler3" class="accordion spoiler-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button spoiler-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSpoiler3" aria-expanded="false" aria-controls="collapseSpoiler3">
  <h3 class="accordion-header" id="headingSpoiler3">  <div class="note-square"><i aria-hidden="true" class="callout-icon" data-feather="eye"></i></div> Show details </h3>
</button>
<div id="collapseSpoiler3" class="accordion-collapse collapse" data-bs-parent="#accordionSpoiler3" aria-labelledby="headingSpoiler3">
<div class="accordion-body">
<div class="codewrapper sourceCode" id="cb7">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="ex">$</span> cat /proc/meminfo <span class="kw">|</span> <span class="fu">grep</span> <span class="st">"MemTotal"</span></span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a><span class="ex">MemTotal:</span>       395695636 kB</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<p>Again, the total memory of the cluster is going to be much, much
larger than the memory of any individual machine.</p>
<p>All of these cores and all of that memory are shared between you and
all the other users of your cluster. To get a feeling for the amount of
resources per user, let’s try to get an estimate for how many users
there are by counting the number of home directories.</p>
<div class="codewrapper sourceCode" id="cb8">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a><span class="fu">find</span> /home <span class="at">-maxdepth</span> 1 <span class="at">-mindepth</span> 1 <span class="at">-type</span> d <span class="kw">|</span> <span class="fu">wc</span> <span class="at">-l</span></span></code></pre>
</div>
<div id="caution1" class="callout caution">
<div class="callout-square">
<i class="callout-icon" data-feather="alert-triangle"></i>
</div>
<span class="callout-header">Caution</span>
<div class="callout-inner">
<div class="callout-content">
<p>On some clusters, home directories are not placed directly in
<code>/home</code>, but are split up into subdirectories first (e.g., by
first letter of the username like <code>/home/s/someuser</code>). In
this case, you have to use <code>-maxdepth 2 -mindepth 2</code> to count
the contents of these subdirectories. If your cluster does not use
<code>/home</code> for the users’ home directories, you might have to
use a different path (check <code>dirname "$HOME"</code> for a clue).
Also, this command only gives an upper limit to the number of real
cluster users as there might be home directories for service users as
well.</p>
</div>
</div>
</div>
<p>By dividing the total number of cores / the total memory by the
amount of users, you get an estimate of how many resources each user has
available in a perfectly fair world.</p>
<div id="discussion2" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<span class="callout-header">Discussion</span>
<div class="callout-inner">
<div class="callout-content">
<p>Does this mean you can never use more than this amount of
resources?</p>
</div>
</div>
</div>
<div id="accordionInstructor2" class="accordion instructor-note accordion-flush">
<div class="accordion-item">
<button class="accordion-button instructor-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseInstructor2" aria-expanded="false" aria-controls="collapseInstructor2">
  <h3 class="accordion-header" id="headingInstructor2">  <div class="note-square"><i aria-hidden="true" class="callout-icon" data-feather="edit-2"></i></div> Instructor Note </h3>
</button>
<div id="collapseInstructor2" class="accordion-collapse collapse" data-bs-parent="#accordionInstructor2" aria-labelledby="headingInstructor2">
<div class="accordion-body">
<p>The learners should realize that the per-user average they calculate
here is very synthetic:</p>
<ul>
<li>Many users do not use their full share of resources, which leaves
room for others to use more.</li>
<li>The average we calculate is only an average over long periods of
time. Short term you can usually use much more.</li>
<li>Not all users are equal. For example, if some research groups have
contributed to the funding of the cluster, they should also get more
resources than those who did not.</li>
<li>The world is not perfectly fair. Especially on larger clusters, HPC
resources have to be requested via project proposals. Those who write
more / better proposals can use more resources.</li>
</ul>
</div>
</div>
</div>
</div>
<p>Now that you have an idea of how big your cluster is, you can start
to make informed decisions on how many resources are reasonable to ask
for.</p>
<div id="discussion3" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<span class="callout-header">Discussion</span>
<div class="callout-inner">
<h3 class="callout-title">Challenge</h3>
<div class="callout-content">
<p><code>sinfo</code> can show a lot more information on the nodes and
partitions of your cluster. Check out the <a href="https://slurm.schedmd.com/sinfo.html#OPT_Format" class="external-link">documentation</a>
and experiment with additional output options. Try to find a single
command that will shows for each command the number of allocated and
idle nodes and CPU cores.</p>
</div>
</div>
</div>
<div id="accordionSolution2" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution2" aria-expanded="false" aria-controls="collapseSolution2">
  <h4 class="accordion-header" id="headingSolution2"> Show me the solution </h4>
</button>
<div id="collapseSolution2" class="accordion-collapse collapse" data-bs-parent="#accordionSolution2" aria-labelledby="headingSolution2">
<div class="accordion-body">
<div class="codewrapper sourceCode" id="cb9">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a><span class="ex">$</span> sinfo <span class="at">-O</span> Partition,CPUsState,NodeAIOT</span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a><span class="ex">PARTITION</span>           CPUS<span class="er">(</span><span class="ex">A/I/O/T</span><span class="kw">)</span>       <span class="ex">NODES</span><span class="er">(</span><span class="ex">A/I/O/T</span><span class="kw">)</span></span>
<span id="cb9-3"><a href="#cb9-3" tabindex="-1"></a><span class="ex">normal*</span>             6336/720/972/8028   196/0/27/223</span>
<span id="cb9-4"><a href="#cb9-4" tabindex="-1"></a><span class="ex">long</span>                2205/351/684/3240   71/0/19/90</span>
<span id="cb9-5"><a href="#cb9-5" tabindex="-1"></a><span class="ex">express</span>             44/172/0/216        3/3/0/6</span>
<span id="cb9-6"><a href="#cb9-6" tabindex="-1"></a><span class="ex">zen4</span>                7532/1108/192/8832  44/1/1/46</span>
<span id="cb9-7"><a href="#cb9-7" tabindex="-1"></a><span class="ex">gpuexpress</span>          0/32/0/32           0/1/0/1</span>
<span id="cb9-8"><a href="#cb9-8" tabindex="-1"></a><span class="ex">gpu4090</span>             177/35/44/256       7/0/1/8</span>
<span id="cb9-9"><a href="#cb9-9" tabindex="-1"></a><span class="ex">gpuh200</span>             90/166/256/512      2/0/2/4</span></code></pre>
</div>
</div>
</div>
</div>
</div>
</section><section><h2 class="section-heading" id="sizing-your-jobs">Sizing your jobs<a class="anchor" aria-label="anchor" href="#sizing-your-jobs"></a>
</h2>
<hr class="half-width">
<p>The resources required by your jobs primarily depend on the
application you want to run and are thus very specific to your
particular HPC use case. While it is tempting to just wildly
overestimate the resource requirements of your application to make sure
it cannot possibly run out, this is not a good strategy. Not only would
you have to face the wrath of your cluster administrators (and the other
users!) for being inefficient, but you would also be punished by the
scheduler itself: In most cluster configurations, your scheduling
priority decreases faster if you request more resources and larger jobs
often need to wait longer until a suitable slot becomes free. Thus, if
you want to get your calculations done faster, you should request just
enough resources for your application to work.</p>
<p>Finding this amount of resources is often a matter of trial and error
as many applications do not have precisely predictable resource
requirements. Let’s try this for our snowman renderer. Put the following
in a file named <code>snowman.job</code>:</p>
<div class="codewrapper sourceCode" id="cb10">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a><span class="co">#!/bin/bash</span></span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a><span class="co">#SBATCH --nodes=1</span></span>
<span id="cb10-3"><a href="#cb10-3" tabindex="-1"></a><span class="co">#SBATCH --partition=&lt;put your partition here&gt;</span></span>
<span id="cb10-4"><a href="#cb10-4" tabindex="-1"></a><span class="co">#SBATCH --ntasks=4</span></span>
<span id="cb10-5"><a href="#cb10-5" tabindex="-1"></a><span class="co">#SBATCH --cpus-per-task=1</span></span>
<span id="cb10-6"><a href="#cb10-6" tabindex="-1"></a><span class="co">#SBATCH --mem=1G</span></span>
<span id="cb10-7"><a href="#cb10-7" tabindex="-1"></a><span class="co">#SBATCH --time=00:01:00</span></span>
<span id="cb10-8"><a href="#cb10-8" tabindex="-1"></a><span class="co">#SBATCH --output=snowman-stdout.log</span></span>
<span id="cb10-9"><a href="#cb10-9" tabindex="-1"></a><span class="co">#SBATCH --job-name=snowman</span></span>
<span id="cb10-10"><a href="#cb10-10" tabindex="-1"></a></span>
<span id="cb10-11"><a href="#cb10-11" tabindex="-1"></a><span class="co"># Always a good idea to purge modules first to start with a clean module environment</span></span>
<span id="cb10-12"><a href="#cb10-12" tabindex="-1"></a><span class="ex">module</span> purge</span>
<span id="cb10-13"><a href="#cb10-13" tabindex="-1"></a><span class="co"># &lt;put the module load commands for your cluster here&gt;</span></span>
<span id="cb10-14"><a href="#cb10-14" tabindex="-1"></a></span>
<span id="cb10-15"><a href="#cb10-15" tabindex="-1"></a><span class="co"># Start the raytracer</span></span>
<span id="cb10-16"><a href="#cb10-16" tabindex="-1"></a><span class="ex">mpirun</span> <span class="at">-n</span> 4 ./SnowmanRaytracer/build/raytracer <span class="at">-width</span><span class="op">=</span>1024 <span class="at">-height</span><span class="op">=</span>1024 <span class="at">-spp</span><span class="op">=</span>256 <span class="at">-threads</span><span class="op">=</span>1 <span class="at">-alloc_mode</span><span class="op">=</span>3 <span class="at">-png</span><span class="op">=</span>snowman.png</span></code></pre>
</div>
<p>The <code>#SBATCH</code> directives assign our job the following
resources (line-by-line):</p>
<ul>
<li>1 node…</li>
<li>… from the partition
<code>&lt;put your partition here&gt;</code>
</li>
<li>4 MPI tasks…</li>
<li>… each of which uses one CPU core (so 4 cores in total)</li>
<li>1 GB of memory</li>
<li>A timelimit of 1 minute</li>
</ul>
<p>The last two <code>#SBATCH</code> directives specifiy that we want
the output of our job to be captures in the file
<code>snowman-stdout.log</code> and that the job should appear under the
name <code>snowman</code>.</p>
<div id="callout1" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<span class="callout-header">Callout</span>
<div class="callout-inner">
<div class="callout-content">
<p>The <code>--mem</code> directive is somewhat unfortunately named as
it does not define the total amount of memory of your job, but the total
amount of memory <em>per node</em>. Here, this distinction does not
matter as we only use one node, but you should keep in mind that
changing the number of nodes often implies that you need to adapt the
<code>--mem</code> value as well. Alternatively, you can also use the
<code>--mem-per-cpu</code> directive such that the memory allocation
automatically scales with the number of cores. However, even in this
case you need to verify that your memory consumption actually scales
linearly with the number of cores for your application!</p>
</div>
</div>
</div>
<p>To test if our estimate works, you have to submit the job to the
scheduler:</p>
<div class="codewrapper sourceCode" id="cb11">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a><span class="ex">sbatch</span> snowman.job</span></code></pre>
</div>
<p>This command will also print the ID of the job, so we can observe
what is happening with it. Wait a bit and have a look at how your job is
doing:</p>
<div class="codewrapper sourceCode" id="cb12">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a><span class="ex">sacct</span> <span class="at">-X</span> <span class="at">-j</span> <span class="op">&lt;</span>jobid of your job<span class="op">&gt;</span></span></code></pre>
</div>
<p>After a while, you will see that the status of your job is given as
<code>TIMEOUT</code>.</p>
<div id="callout2" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<span class="callout-header">Callout</span>
<div class="callout-inner">
<div class="callout-content">
<p>You might wonder what the <code>-X</code> flag does in the the
<code>sacct</code> call above. This option instructs Slurm to not output
information on the “job steps” associated with your job. Since we don’t
care about these right now, we set this flag to make the output more
concise.</p>
</div>
</div>
</div>
<p>Check the file <code>snowman-stdout.log</code> as well. Near the
bottom you will see a line like this:</p>
<pre class="text"><code>slurmstepd: error: *** JOB 1234567 ON somenode CANCELLED AT 2025-04-01T13:37:00 DUE TO TIME LIMIT ***</code></pre>
<p>Evidently our job was aborted because it did not finish within the
time limit of one minute that we set above. Let’s try giving our job a
time limit of 10 minutes instead.</p>
<div class="codewrapper sourceCode" id="cb14">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a><span class="co">#SBATCH --time=00:10:00</span></span></code></pre>
</div>
<p>This time the job should succeed and show a status of “COMPLETED” in
<code>sacct</code>. We can check the resources actually needed by our
job with the help of <code>seff</code>:</p>
<div class="codewrapper sourceCode" id="cb15">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a><span class="ex">seff</span> <span class="op">&lt;</span>jobid of your job<span class="op">&gt;</span></span></code></pre>
</div>
<p>The output of <code>seff</code> contains many useful bits of
information for sizing our job. In particular, let’s look at these
lines:</p>
<pre class="text"><code>[...]
CPU Utilized: 00:21:34
CPU Efficiency: 98.93% of 00:21:48 core-walltime
Job Wall-clock time: 00:05:27
Memory Utilized: 367.28 MB
Memory Efficiency: 35.87% of 1.00 GB</code></pre>
<div id="callout3" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<span class="callout-header">Callout</span>
<div class="callout-inner">
<div class="callout-content">
<p>The exact numbers here depend a lot on the hardware and software of
your local cluster.</p>
</div>
</div>
</div>
<p>The <code>Job Wall-clock time</code> is the time our job took. As we
can see, our job takes much longer than one minute to complete which is
why our first attempt with a time limit of one minute has failed.</p>
<p>The <code>CPU Utilized</code> line shows us how much CPU time our job
has used. This is calculated by determining the busy time for each core
and then summing these times for all cores. In an ideal world, the CPU
cores should be busy for the entire time of our job, so the CPU time
should be equal to the time the job took times the number of CPU cores.
The ratio between the real CPU time and the ideal CPU time is shown in
the <code>CPU Efficiency</code> line.</p>
<p>Finally, <code>Memory utilized</code> line shows the peak memory
consumption that your job had at any point during its runtime, while
<code>Memory Efficiency</code> is the ratio between this peak value and
the requested amount of memory for the allocation. As we will see later,
this value has to be taken with a grain of salt.</p>
<p>Starting from the set of parameters that successfully run our
program, we can now try to reduce the amout of requested resources. As
is good scientific practice, we should only vary one parameter at a time
and observe the result. Let’s start by reducing the time limit. There is
often a bit of jitter in the time needed to run a job since not all
nodes are perfectly identical, so you should add a safety margin of 10
to 20 percent <span style="color:red">(completely arbitrary choice of
numbers here; does everyone agree on the order of magnitude?)</span>
According to the time reported by <code>seff</code>, seven minutes
should therefore be a good time limit. If your cluster is faster, you
might reduce this even further.</p>
<div class="codewrapper sourceCode" id="cb17">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a><span class="co">#SBATCH --time=00:07:00</span></span></code></pre>
</div>
<p>As you can see, your job will still complete successfully.</p>
<div id="accordionInstructor3" class="accordion instructor-note accordion-flush">
<div class="accordion-item">
<button class="accordion-button instructor-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseInstructor3" aria-expanded="false" aria-controls="collapseInstructor3">
  <h3 class="accordion-header" id="headingInstructor3">  <div class="note-square"><i aria-hidden="true" class="callout-icon" data-feather="edit-2"></i></div> Instructor Note </h3>
</button>
<div id="collapseInstructor3" class="accordion-collapse collapse" data-bs-parent="#accordionInstructor3" aria-labelledby="headingInstructor3">
<div class="accordion-body">
<p>For the next section, the exact memory requirements depend on the
cluster configuration (e.g., the MPI backends used). You might have to
adapt these numbers for your local cluster to see the out-of-memory
behavior.</p>
</div>
</div>
</div>
</div>
<p>Next, we can optimize our memory allocation. According to SLURM, we
used 367.28 MB of memory in our last run, so let’s set the memory limit
to 500 MB.</p>
<div class="codewrapper sourceCode" id="cb18">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb18-1"><a href="#cb18-1" tabindex="-1"></a><span class="co">#SBATCH --mem=500M</span></span></code></pre>
</div>
<p>After submitting the job with the lowered memory allocation
everything seems fine for a while. But then, right at the end of the
computation, our job will crash. Checking the job status with
<code>sacct</code> will reveal that the job status is
<code>OUT_OF_MEMORY</code> meaning that our job exceeded its memory
limit and was terminated by the scheduler.</p>
<p>This behavior seems contradictory at first: SLURM reported previously
that our job only used around 367 MB of memory at most, which is well
below the 500 MB limit we set. The explanation for this discrepancy lies
in the fact that SLURM measures the peak memory consumption of jobs by
<em>polling</em>, i.e., by periodically sampling how much memory the job
currently uses. Unfortunately, if the program has spikes in memory
consumption that are small enough to fit between two samples, SLURM will
miss them and report an incorrect peak memory value. Spikes in memory
usage are quite common, for example if your application uses short-lived
subprocesses. Most annoyingly, many programs allocate a large chunk of
memory right at the end of the computation to write out the results. In
the case of the snowman raytracer, we encode the raw pixel data into a
PNG at the end, which means we temporarily keep both the raw image and
the PNG data in memory.</p>
<figure><img src="../fig/slurm-memory-sampling.svg" class="figure mx-auto d-block"></figure><div id="caution2" class="callout caution">
<div class="callout-square">
<i class="callout-icon" data-feather="alert-triangle"></i>
</div>
<span class="callout-header">Caution</span>
<div class="callout-inner">
<div class="callout-content">
<p>SLURM determines memory consuption by <em>polling</em>, i.e.,
periodically checking on the memory consumption of your job. If you job
has a memory allocation profile with short spikes in memory usage, the
value reported by <code>seff</code> can be incorrect. In particular, if
the job gets cancelled due to memory exhaustion, you should not rely on
the value reported by <code>seff</code> as it is likely significantly
too low.</p>
</div>
</div>
</div>
<p>So how big is the peak memory consumption of our process
<em>really</em>? Luckily, the Linux kernel keeps track of this for us,
if SLURM is configured to use the so-called “cgroups v2” mechanism to
enforce resource limits (which many HPC systems are). Let’s use this
system to find out how much memory the raytracer actually needs. First,
we set the memory limit back to 1 GB, i.e., to a configuration that is
known to work.</p>
<div class="codewrapper sourceCode" id="cb19">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb19-1"><a href="#cb19-1" tabindex="-1"></a><span class="co">#SBATCH --mem=1G</span></span></code></pre>
</div>
<p>Next, add these lines at the end of your job script:</p>
<div class="codewrapper sourceCode" id="cb20">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb20-1"><a href="#cb20-1" tabindex="-1"></a><span class="bu">echo</span> <span class="at">-n</span> <span class="st">"Total amount of memory used (in bytes): "</span></span>
<span id="cb20-2"><a href="#cb20-2" tabindex="-1"></a><span class="fu">cat</span> /sys/fs/cgroup/<span class="va">$(</span><span class="fu">cat</span> /proc/self/cgroup <span class="kw">|</span> <span class="fu">awk</span> <span class="at">-F</span> <span class="st">':'</span> <span class="st">'{print $3}'</span><span class="va">)</span>/memory.peak</span></code></pre>
</div>
<div id="callout4" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<span class="callout-header">Callout</span>
<div class="callout-inner">
<div class="callout-content">
<p>Let’s break down what these lines do:</p>
<ul>
<li>The first line prints out a nice label for our peak memory output.
We use <code>-n</code> to omit the usual newline that <code>echo</code>
adds at the end of its output.</li>
<li>The second line outputs the contents of a file (<code>cat</code>).
The path of this file starts with <code>/sys/fs/cgroup</code>, which is
a location where the Linux kernel exports all the cgroups v2 information
as files.</li>
<li>For the next part of the path we need the so-called “cgroup path” of
our job. To find out this path, we can use the
<code>/proc/self/cgroup</code> file, which contains this path as the
third entry of a colon-separated list. Therefore, we read the contents
of this file (<code>cat</code>) and extract the third entry of the colon
separated list (<code>awk -F ':' '{print $3}'</code>). Since we do this
in <code>$(...)</code>, Bash will place the output of these commands
(i.e., the cgroup path) at this point.</li>
<li>The final part of the path is the information we actually want from
the cgroup. In out case, we are interested in <code>memory.peak</code>,
which contains the peak memory consumption of the cgroup.</li>
</ul>
</div>
</div>
</div>
<p>When you submit your job and look at the output once it finishes, you
will find a line like this:</p>
<pre class="text"><code>[...]
Total amount of memory used (in bytes): 579346432
[...]</code></pre>
<p>So even though SLURM reported our job to only use 367.28 MB of
memory, we actually used nearly 600 MB! With this measurement we can
make an informed decision on how to set the memory limit for our
job:</p>
<div class="codewrapper sourceCode" id="cb22">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb22-1"><a href="#cb22-1" tabindex="-1"></a><span class="co">#SBATCH --mem=700M</span></span></code></pre>
</div>
<p>Run your job again with this limit to verify that it completes
successfully.</p>
<div id="accordionInstructor4" class="accordion instructor-note accordion-flush">
<div class="accordion-item">
<button class="accordion-button instructor-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseInstructor4" aria-expanded="false" aria-controls="collapseInstructor4">
  <h3 class="accordion-header" id="headingInstructor4">  <div class="note-square"><i aria-hidden="true" class="callout-icon" data-feather="edit-2"></i></div> Instructor Note </h3>
</button>
<div id="collapseInstructor4" class="accordion-collapse collapse" data-bs-parent="#accordionInstructor4" aria-labelledby="headingInstructor4">
<div class="accordion-body">
<p>At this point you might want to point out to your audience that for
certain applications it can be disastrous for performance to set the
memory constraint too tightly. The reason is that the memory limit
enforced by Slurm does not only affect the resident set size of all the
processes in the job allocation, but also the memory used for caching
(e.g., file pages). If the allocation runs out of memory for the cache,
it will have to evict memory pages to disk, which can cause I/O
operations and new memory allocations to block for longer than usual. If
the application makes heavy use of this cache (e.g., repeated read
and/or write operations on the same file) and the memory pressure in the
allocation is high, you can even run into a <em>cache thrashing</em>
situation, where the job spends the majority of its time swapping data
in and out of system memory and thus slows down to a crawl.</p>
</div>
</div>
</div>
</div>
<p>So far we have tuned the time and memory limits of our job. Now let
us have a look at the CPU core limit. This limit works slightly
differently than the ones we looked at so far in the sense that your job
is not getting terminated if you try to use more cores than you have
allocated. Instead, the scheduler exploits the fact that multitasking
operating systems can switch out the process a given CPU core is working
on. If you have more active processes in your job than you have CPU
cores (i.e., <em>CPU oversubscription</em>), the operating system will
simply switch processes in and out while trying to ensure that each
process gets an equal amount of CPU time. This happens very fast, so you
can’t see the switching directly, but tools like <code>htop</code> will
show your processes running at less than 100% CPU utilization. Below you
can see a situation of four processes running on three CPU cores, which
results in each process running only 75% of the time.</p>
<figure><img src="../fig/cpu-oversubscription.svg" class="figure mx-auto d-block"></figure><div id="caution3" class="callout caution">
<div class="callout-square">
<i class="callout-icon" data-feather="alert-triangle"></i>
</div>
<span class="callout-header">Caution</span>
<div class="callout-inner">
<div class="callout-content">
<p>CPU oversubscription can even be harmful to performance as all the
switching between processes by the operating system can cost a
non-trivial amount of CPU time itself.</p>
</div>
</div>
</div>
<p>Let’s try reducing the number of cores we allocate by reducing the
number of MPI tasks we request in our job script:</p>
<div class="codewrapper sourceCode" id="cb23">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb23-1"><a href="#cb23-1" tabindex="-1"></a><span class="co">#SBATCH --ntasks=2</span></span></code></pre>
</div>
<p>Now we have a mismatch between the number of tasks we request and the
number of tasks we use in <code>mpirun</code>. However, MPI catches our
folly and prevents us from accidentally oversubscribing our CPU cores.
In the output file you see the full explanation</p>
<pre class="text"><code>There are not enough slots available in the system to satisfy the 4
slots that were requested by the application:

  ./SnowmanRaytracer/build/raytracer

Either request fewer procs for your application, or make more slots
available for use.

A "slot" is the PRRTE term for an allocatable unit where we can
launch a process.  The number of slots available are defined by the
environment in which PRRTE processes are run:

  1. Hostfile, via "slots=N" clauses (N defaults to number of
     processor cores if not provided)
  2. The --host command line parameter, via a ":N" suffix on the
     hostname (N defaults to 1 if not provided)
  3. Resource manager (e.g., SLURM, PBS/Torque, LSF, etc.)
  4. If none of a hostfile, the --host command line parameter, or an
     RM is present, PRRTE defaults to the number of processor cores

In all the above cases, if you want PRRTE to default to the number
of hardware threads instead of the number of processor cores, use the
--use-hwthread-cpus option.

Alternatively, you can use the --map-by :OVERSUBSCRIBE option to ignore the
number of available slots when deciding the number of processes to
launch.</code></pre>
<div id="accordionInstructor5" class="accordion instructor-note accordion-flush">
<div class="accordion-item">
<button class="accordion-button instructor-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseInstructor5" aria-expanded="false" aria-controls="collapseInstructor5">
  <h3 class="accordion-header" id="headingInstructor5">  <div class="note-square"><i aria-hidden="true" class="callout-icon" data-feather="edit-2"></i></div> Instructor Note </h3>
</button>
<div id="collapseInstructor5" class="accordion-collapse collapse" data-bs-parent="#accordionInstructor5" aria-labelledby="headingInstructor5">
<div class="accordion-body">
<p>This error message was generated with OpenMPI. Other MPI
implementations might produce different messages.</p>
</div>
</div>
</div>
</div>
<p>If we actually want to see oversubscription in action, we need to
switch from MPI to multithreading. First, let us try without
oversubscribing the CPU cores:</p>
<div class="codewrapper sourceCode" id="cb25">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb25-1"><a href="#cb25-1" tabindex="-1"></a><span class="co">#SBATCH --ntasks=1</span></span>
<span id="cb25-2"><a href="#cb25-2" tabindex="-1"></a><span class="co">#SBATCH --cpus-per-task=4</span></span>
<span id="cb25-3"><a href="#cb25-3" tabindex="-1"></a></span>
<span id="cb25-4"><a href="#cb25-4" tabindex="-1"></a><span class="co"># [...]</span></span>
<span id="cb25-5"><a href="#cb25-5" tabindex="-1"></a></span>
<span id="cb25-6"><a href="#cb25-6" tabindex="-1"></a><span class="ex">./SnowmanRaytracer/build/raytracer</span> <span class="at">-width</span><span class="op">=</span>1024 <span class="at">-height</span><span class="op">=</span>1024 <span class="at">-spp</span><span class="op">=</span>256 <span class="at">-threads</span><span class="op">=</span>4 <span class="at">-alloc_mode</span><span class="op">=</span>3 <span class="at">-png</span><span class="op">=</span>snowman.png</span></code></pre>
</div>
<p>This works and if we look at the output of <code>seff</code> again we
get a baseline for our multithreaded job</p>
<pre class="text"><code>[...]
CPU Utilized: 00:21:32
CPU Efficiency: 99.08% of 00:21:44 core-walltime
Job Wall-clock time: 00:05:26
Memory Utilized: 90.85 MB
Memory Efficiency: 12.11% of 750.00 MB</code></pre>
<div id="discussion4" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<span class="callout-header">Discussion</span>
<div class="callout-inner">
<h3 class="callout-title">Challenge</h3>
<div class="callout-content">
<p>Compare our measurements for 4 threads here to the measurements we
made for doing the computation with 4 MPI tasks earlier. What metrics
are similar and which ones are different? Do you have an explanation for
this?</p>
</div>
</div>
</div>
<div id="accordionSolution3" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution3" aria-expanded="false" aria-controls="collapseSolution3">
  <h4 class="accordion-header" id="headingSolution3"> Show me the solution </h4>
</button>
<div id="collapseSolution3" class="accordion-collapse collapse" data-bs-parent="#accordionSolution3" aria-labelledby="headingSolution3">
<div class="accordion-body">
<p>We can see that the CPU utilization time and the walltime are
virtually identical to the MPI version of our job, while the memory
utilization is much lower. The exact reasons for this will be discussed
in the following episodes, but here is the gist of it:</p>
<ul>
<li>Our job is strongly <em>compute-bound</em>, i.e., the time our job
takes is mostly determined by how fast the CPU can do its calculations.
This is why it does not matter much for CPU utilization whether we use
MPI or threads as long as both can keep the same number of CPU cores
busy.</li>
<li>MPI typically incurs an overhead in CPU usage and memory due to the
need to communicate between the tasks (in comparison, threads can just
share a block of memory without communication). In our raytracer, this
overhead for CPU usage is negligible (hence the same CPU utilization
time metrics), but there is a significant memory overhead.</li>
</ul>
</div>
</div>
</div>
</div>
<p>Now let’s see what happens when we oversubscribe our CPU by doubling
the number of threads without increasing the number of allocated cores
in our job script:</p>
<div class="codewrapper sourceCode" id="cb27">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb27-1"><a href="#cb27-1" tabindex="-1"></a><span class="ex">./SnowmanRaytracer/build/raytracer</span> <span class="at">-width</span><span class="op">=</span>1024 <span class="at">-height</span><span class="op">=</span>1024 <span class="at">-spp</span><span class="op">=</span>256 <span class="at">-threads</span><span class="op">=</span>8 <span class="at">-alloc_mode</span><span class="op">=</span>3 <span class="at">-png</span><span class="op">=</span>snowman.png</span></code></pre>
</div>
<div id="discussion5" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<span class="callout-header">Discussion</span>
<div class="callout-inner">
<h3 class="callout-title">Challenge</h3>
<div class="callout-content">
<p>If you cluster allows direct access to the compute nodes, try logging
into the node your job is running on and watch the CPU utilization live
using</p>
<div class="codewrapper sourceCode" id="cb28">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb28-1"><a href="#cb28-1" tabindex="-1"></a><span class="ex">htop</span> <span class="at">-u</span> <span class="op">&lt;</span>your username<span class="op">&gt;</span></span></code></pre>
</div>
<p>(Note: Sometimes <code>htop</code> hides threads to make the process
list easier to read. This option can be changed by pressing F2, using
the arrow keys to navigate to the “Hide userlang process threads”,
toggling with the return key and then applying the change with F10.)</p>
<p>Compare the CPU utilization of the <code>raytracter</code> threads
with different total numbers of threads.</p>
<p>In the top right of <code>htop</code> you can also see a metric
called <em>load average</em>. Simplified, this is the number of
processes / threads that are currently either running or could run if a
CPU core was free. Compare the amount of load you generate with your job
depending on the number of threads.</p>
</div>
</div>
</div>
<div id="accordionSolution4" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution4" aria-expanded="false" aria-controls="collapseSolution4">
  <h4 class="accordion-header" id="headingSolution4"> Show me the solution </h4>
</button>
<div id="collapseSolution4" class="accordion-collapse collapse" data-bs-parent="#accordionSolution4" aria-labelledby="headingSolution4">
<div class="accordion-body">
<p>You can see that the CPU utilization of each <code>raytracer</code>
thread goes down as the number of threads increases. This means, each
process is only active for a fraction of the total compute time as the
operating system switches between threads.</p>
<p>For the load metric, you can see that the load increases linearly
with the number of threads <strong>regardless if they are actually
running or waiting for a CPU core</strong>. Load is a fairly common
metric to be monitored by cluster administrators, so if you cause
excessive load by CPU oversubscription you will probably hear from your
local admin.</p>
</div>
</div>
</div>
</div>
<p>Despite using twice the amount of threads, we barely see any
difference in the output of <code>seff</code>:</p>
<pre class="text"><code>CPU Utilized: 00:21:29
CPU Efficiency: 98.85% of 00:21:44 core-walltime
Job Wall-clock time: 00:05:26
Memory Utilized: 93.32 MB
Memory Efficiency: 12.44% of 750.00 MB</code></pre>
<p>This shows that despite having more threads, the CPU cores are not
performing more work. Instead, the operating system periodically rotates
the threads running on each allocated core, making sure every thread
gets a time slice to make progress.</p>
<p>Let’s see what happens when we increase the thread count to extreme
levels:</p>
<div class="codewrapper sourceCode" id="cb30">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb30-1"><a href="#cb30-1" tabindex="-1"></a><span class="ex">./SnowmanRaytracer/build/raytracer</span> <span class="at">-width</span><span class="op">=</span>1024 <span class="at">-height</span><span class="op">=</span>1024 <span class="at">-spp</span><span class="op">=</span>256 <span class="at">-threads</span><span class="op">=</span>1024 <span class="at">-alloc_mode</span><span class="op">=</span>3 <span class="at">-png</span><span class="op">=</span>snowman.png</span></code></pre>
</div>
<p>With this setting, <code>seff</code> yields</p>
<pre class="text"><code>CPU Utilized: 00:26:45
CPU Efficiency: 99.07% of 00:27:00 core-walltime
Job Wall-clock time: 00:06:45
Memory Utilized: 113.29 MB
Memory Efficiency: 15.11% of 750.00 MB</code></pre>
<p>As we can see, our job is actually getting slowed down from all the
switching between threads. This means, that for our raytracer
application CPU oversubscription is either pointless or actively harmful
regarding performance.</p>
<div id="discussion6" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<span class="callout-header">Discussion</span>
<div class="callout-inner">
<div class="callout-content">
<p>If CPU oversubscription is so bad, then why do most operating systems
default to this behavior?</p>
</div>
</div>
</div>
<div id="accordionSolution5" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution5" aria-expanded="false" aria-controls="collapseSolution5">
  <h4 class="accordion-header" id="headingSolution5"> Show me the solution </h4>
</button>
<div id="collapseSolution5" class="accordion-collapse collapse" data-bs-parent="#accordionSolution5" aria-labelledby="headingSolution5">
<div class="accordion-body">
<p>In this case we have a <em>CPU bound</em> application, i.e., the work
done by the CPU is the limiting factor and thus dividing this work into
smaller chunks does not help with performance. However, there are also
applications bound by other resources. For these applications it makes
sense to assign the CPU core elsewhere while the process is waiting,
e.g., on a storage medium. Also, in most systems it is desireable to
have more programs running than your computer has CPU cores since often
only a few of them are active at the same time.</p>
</div>
</div>
</div>
</div>
</section><section><h2 class="section-heading" id="multi-node-jobs">Multi-node jobs<a class="anchor" aria-label="anchor" href="#multi-node-jobs"></a>
</h2>
<hr class="half-width">
<p>So far, we have only used a single node for our job. The big
advantage of MPI as a parallelism scheme is the fact that not all MPI
tasks need to run on the same node. Let’s try this with our Snowman
raytracer example:</p>
<div class="codewrapper sourceCode" id="cb32">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb32-1"><a href="#cb32-1" tabindex="-1"></a><span class="co">#!/bin/bash</span></span>
<span id="cb32-2"><a href="#cb32-2" tabindex="-1"></a><span class="co">#SBATCH --nodes=2</span></span>
<span id="cb32-3"><a href="#cb32-3" tabindex="-1"></a><span class="co">#SBATCH --partition=&lt;put your partition here&gt;</span></span>
<span id="cb32-4"><a href="#cb32-4" tabindex="-1"></a><span class="co">#SBATCH --ntasks=4</span></span>
<span id="cb32-5"><a href="#cb32-5" tabindex="-1"></a><span class="co">#SBATCH --cpus-per-task=1</span></span>
<span id="cb32-6"><a href="#cb32-6" tabindex="-1"></a><span class="co">#SBATCH --mem=700M</span></span>
<span id="cb32-7"><a href="#cb32-7" tabindex="-1"></a><span class="co">#SBATCH --time=00:07:00</span></span>
<span id="cb32-8"><a href="#cb32-8" tabindex="-1"></a><span class="co">#SBATCH --output=snowman-stdout.log</span></span>
<span id="cb32-9"><a href="#cb32-9" tabindex="-1"></a><span class="co">#SBATCH --job-name=snowman</span></span>
<span id="cb32-10"><a href="#cb32-10" tabindex="-1"></a></span>
<span id="cb32-11"><a href="#cb32-11" tabindex="-1"></a><span class="co"># Always a good idea to purge modules first to start with a clean module environment</span></span>
<span id="cb32-12"><a href="#cb32-12" tabindex="-1"></a><span class="ex">module</span> purge</span>
<span id="cb32-13"><a href="#cb32-13" tabindex="-1"></a><span class="co"># &lt;put the module load commands for your cluster here&gt;</span></span>
<span id="cb32-14"><a href="#cb32-14" tabindex="-1"></a></span>
<span id="cb32-15"><a href="#cb32-15" tabindex="-1"></a><span class="ex">mpirun</span> <span class="at">--</span> ./SnowmanRaytracer/build/raytracer <span class="at">-width</span><span class="op">=</span>1024 <span class="at">-height</span><span class="op">=</span>1024 <span class="at">-spp</span><span class="op">=</span>256 <span class="at">-threads</span><span class="op">=</span>1 <span class="at">-alloc_mode</span><span class="op">=</span>3 <span class="at">-png</span><span class="op">=</span>snowman.png</span>
<span id="cb32-16"><a href="#cb32-16" tabindex="-1"></a></span>
<span id="cb32-17"><a href="#cb32-17" tabindex="-1"></a><span class="bu">echo</span> <span class="at">-n</span> <span class="st">"Total amount of memory used (in bytes): "</span></span>
<span id="cb32-18"><a href="#cb32-18" tabindex="-1"></a><span class="fu">cat</span> /sys/fs/cgroup<span class="va">$(</span><span class="fu">cat</span> /proc/self/cgroup <span class="kw">|</span> <span class="fu">awk</span> <span class="at">-F</span> <span class="st">':'</span> <span class="st">'{print $3}'</span><span class="va">)</span>/memory.peak</span></code></pre>
</div>
<p>The important change here compared to the MPI jobs before is the
<code>--nodes=2</code> directive, which instructs Slurm to distribute
the 4 tasks across exactly two nodes.</p>
<div id="callout5" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<span class="callout-header">Callout</span>
<div class="callout-inner">
<div class="callout-content">
<p>You can also leave the decision of how many nodes to use up to Slurm
by specifying a minimum and a maximum number of nodes, e.g.,</p>
<pre><code><span><span class="op">-</span><span class="op">-</span><span class="va">nodes</span><span class="op">=</span><span class="fl">1</span><span class="op">-</span><span class="fl">3</span></span></code></pre>
<p>would mean that Slurn can assign your job either one, two or three
nodes.</p>
</div>
</div>
</div>
<p>Let’s look at the <code>seff</code> report of our job once again:</p>
<pre class="text"><code>[...]
Nodes: 2
Cores per node: 2
CPU Utilized: 00:21:32
CPU Efficiency: 98.78% of 00:21:48 core-walltime
Job Wall-clock time: 00:05:27
Memory Utilized: 280.80 MB
Memory Efficiency: 20.06% of 1.37 GB</code></pre>
<p>We can see that Slurm did indeed split up the job such that each of
the two nodes is running two tasks. We can also see that the walltime
and CPU time of our job are basically the same as before. Considering
the fact that communication between nodes is usually much slower than
communication within a node, this result is surprising at first.
However, we can find an explanation in the way our raytracer works. Most
of the compute time is spent on tracing light rays through the scene for
each pixel. Since these light rays are independent from one another,
there is no need to communicate between the MPI tasks. Only at the very
end, when the final image is assembled from the samples calculated by
each task, there is some MPI communication happening. The overall
communication overhead is therefore vanishingly small.</p>
<div id="callout6" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<span class="callout-header">Callout</span>
<div class="callout-inner">
<div class="callout-content">
<p>How well your program scales as you increase the number of nodes
depends strongly on the amount of communication in your program.</p>
</div>
</div>
</div>
<p>We can also look at the memory consumption:</p>
<pre class="text"><code>[...]
Total amount of memory used (in bytes): 464834560
[...]</code></pre>
<p>As we can see, there was indeed less memory consumed on the node
running our submit script compared to before (470 MB vs 580 MB).
However, our method of measuring peak memory consumption does not tell
us about the memory consumption of the second node and we have to use
slightly more sophisticated tooling to find out how much memory we
actually use.</p>
<p>In the course material is a directory
<code>mpi-cgroups-memory-report</code> that can help us out here, but we
need to compile it first:</p>
<div class="codewrapper sourceCode" id="cb36">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb36-1"><a href="#cb36-1" tabindex="-1"></a><span class="bu">cd</span> mpi-cgroups-memory-report</span>
<span id="cb36-2"><a href="#cb36-2" tabindex="-1"></a><span class="fu">make</span> mpi-mem-report.so</span>
<span id="cb36-3"><a href="#cb36-3" tabindex="-1"></a><span class="bu">cd</span> ..</span></code></pre>
</div>
<div class="warning">
<p>Make sure you have a working MPI C Compiler (check with
<code>which mpicc</code>). It is part of the same modules that you need
to run the example raytracer application.</p>
</div>
<p>The memory reporting tool works by hooking itself into the
<code>MPI_Finalize</code> function that needs to be called at the very
end of every MPI program. Then, it does basically the same thing as we
did in the script before and checks the <code>memory.peak</code> value
from cgroups v2. To apply the hook to a program, you need to add the
path to the <code>mpi-mem-report.so</code> file we just created to the
environment variable <code>LD_PRELOAD</code>:</p>
<div class="codewrapper sourceCode" id="cb37">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb37-1"><a href="#cb37-1" tabindex="-1"></a><span class="va">LD_PRELOAD</span><span class="op">=</span><span class="va">$(</span><span class="bu">pwd</span><span class="va">)</span>/mpi-cgroups-memory-report/mpi-mem-report.so <span class="ex">mpirun</span> <span class="at">--</span> ./SnowmanRaytracer/build/raytracer <span class="at">-width</span><span class="op">=</span>1024 <span class="at">-height</span><span class="op">=</span>1024 <span class="at">-spp</span><span class="op">=</span>256 <span class="at">-threads</span><span class="op">=</span>1 <span class="at">-alloc_mode</span><span class="op">=</span>3 <span class="at">-png</span><span class="op">=</span>snowman.png</span></code></pre>
</div>
<p>After submitting this job and waiting for it to complete, we can
check the output log:</p>
<pre><code>[...]
[MPI Memory Reporting Hook]: Node r05n10 has used 464564224 bytes of memory (peak value)
[MPI Memory Reporting Hook]: Node r07n04 has used 151105536 bytes of memory (peak value)
[...]</code></pre>
<p>The memory consumption of the first node matches our previous result,
but we can now also see the memory consumption of the second node.
Compared to the first node the second node uses much less memory,
however in total both nodes use slightly more memory than running all
four tasks on a single node (610 MB vs 580 MB). This memory imbalance
between the nodes is an interesting observation that we should keep in
mind when it comes to estimating how much memory we need per node.</p>
</section><section><h2 class="section-heading" id="tips-for-job-submission">Tips for job submission<a class="anchor" aria-label="anchor" href="#tips-for-job-submission"></a>
</h2>
<hr class="half-width">
<p>To end this lesson, we discuss some tips for choosing resource
allocations such that your jobs get scheduled more quickly.</p>
<ul>
<li>Many clusters have activated the so-called <em>backfill
scheduler</em> option in Slurm. This mechanism tries to squeeze low
priority jobs in the gaps between jobs of higher priority (as long as
the larger jobs are not delayed by this). In this case, smaller jobs are
generally advantageous as they can “skip ahead” in the queue and start
early.</li>
<li>Using <code>sinfo -t idle</code> you can specifically search for
partitions that have idle nodes. Consider using these partitions for
your job if possible as an idle node will typically start your job
immediately.</li>
<li>Different partitions might have different <em>billing weights</em>,
i.e., they might use different factors to determine the “cost” of your
calculation, which is subtracted from your compute budget or fairshare
score. You can check these weights using
<code>scontrol show partition &lt;partitionname&gt; | grep TRESBillingWeights</code>.
The idea behind different billing weights is to even out the cost of the
different resources (i.e., how many hours of memory use correspond to
one hour of CPU use) and to ensure that using more expensive hardware
carries an appropriate cost for the users.</li>
<li>Typically, it takes longer for a large slot to free up than it takes
for several small slots to open. Splitting your job across multiple
nodes might not be the most computationally efficient way to run it due
to the possible communication overhead, but it can be more efficient in
terms of scheduling.</li>
<li>Slurm produces an estimate on when your job will be started which
you can check with
<code>scontrol show job 35749406 | grep StartTime</code>.</li>
</ul>
<div id="accordionInstructor6" class="accordion instructor-note accordion-flush">
<div class="accordion-item">
<button class="accordion-button instructor-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseInstructor6" aria-expanded="false" aria-controls="collapseInstructor6">
  <h3 class="accordion-header" id="headingInstructor6">  <div class="note-square"><i aria-hidden="true" class="callout-icon" data-feather="edit-2"></i></div> Instructor Note </h3>
</button>
<div id="collapseInstructor6" class="accordion-collapse collapse" data-bs-parent="#accordionInstructor6" aria-labelledby="headingInstructor6">
<div class="accordion-body">
<p>At this point you can present some scheduling strategies specific to
your cluster. For the sake of time, you have likely reserved some
resources for the course participants such that their jobs start
instantly. Now would be a good time to show them the harsh reality of
HPC scheduling on a contested partition and demonstrate that a major
part of using an HPC cluster is waiting for your jobs to start.</p>
</div>
</div>
</div>
</div>
<p><span style="color:red">I’m not sure if this is the right section to
discuss this…</span></p>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<span class="callout-header">Key Points</span>
<div class="callout-inner">
<div class="callout-content">
<ul>
<li>Your cluster might seem to have an enormous amout of computing
resources, but these resources are a shared good. You should only use as
much as you need.</li>
<li>Resource requests are a promise to the scheduler to not use more
than a specific amount of resources. If you break your promise to the
scheduler and try to use more resources, terrible things will happen.
<ul>
<li>Overstepping memory or time allocations will result in your job
being terminated.</li>
<li>Oversubscribing CPU cores will at best do nothing and at worst
diminish performance.</li>
</ul>
</li>
<li>Finding the minimal resource requirements takes a bit of trial and
error. Slurm collects a lot of useful metrics to aid you in this.</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</section></section><section id="aio-03_schedulertools"><p>Content from <a href="03_schedulertools.html">Scheduler Tools</a></p>
<hr>
<p>Last updated on 2025-11-11 |

        <a href="https://github.com/stderr-enst/jobefficiency/edit/main/episodes/03_schedulertools.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 10 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>What can the scheduler tell about job performance?</li>
<li>What’s the meaning of collected metrics?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<p>After completing this episode, participants should be able to …</p>
<ul>
<li>Explain basic performance metrics.</li>
<li>Use tools provided by the scheduler to collect basic performance
metrics of their jobs.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="accordionInstructor1" class="accordion instructor-note accordion-flush">
<div class="accordion-item">
<button class="accordion-button instructor-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseInstructor1" aria-expanded="false" aria-controls="collapseInstructor1">
  <h3 class="accordion-header" id="headingInstructor1">  <div class="note-square"><i aria-hidden="true" class="callout-icon" data-feather="edit-2"></i></div> Intention: Introduce more basic performance metrics </h3>
</button>
<div id="collapseInstructor1" class="accordion-collapse collapse" aria-labelledby="headingInstructor1" data-bs-parent="#accordionInstructor1">
<div class="accordion-body">
<p>Narrative:</p>
<ul>
<li>Okay, so first couple of jobs ran, but were they “quick
enough”?</li>
<li>How many renders could I generate per minute/hour/day according to
the current utilization</li>
<li>Our cluster uses certain hardware, maybe we didn’t use it as much as
we could have?</li>
<li>But I couldn’t see all metrics (may be cluster dependent) (Energy,
Disk I/O, Network I/O?)</li>
</ul>
<p>What we’re doing here:</p>
<ul>
<li>What <code>seff</code> and <code>sacct</code> have to offer</li>
<li>Introduce simple relation to hardware, what does RSS, CPU, Disk
read/write and their utilization mean?</li>
<li>Point out what’s missing from a complete picture</li>
</ul>
<p>Note:</p>
<ul>
<li>
<code>seff</code> is an optional SLURM tool. It does not come
standard with every SLURM installation. Therefore, make sure beforehand
that this tool is available for the students.</li>
</ul>
</div>
</div>
</div>
</div>
<section><h2 class="section-heading" id="scheduler-tools">Scheduler Tools<a class="anchor" aria-label="anchor" href="#scheduler-tools"></a>
</h2>
<hr class="half-width">
<p>A scheduler performs important tasks such as accepting and scheduling
jobs, monitoring job status, starting user applications, cleaning up
jobs that have finished or exceeded their allocated time. The scheduler
also keeps a history of jobs that have been run and how they behaved.
The information that is collected can be queried by the job owner to
learn about how the job utilized the resources it was given.</p>
<div class="section level3">
<h3 id="the-seff-tool">The <code>seff</code> tool<a class="anchor" aria-label="anchor" href="#the-seff-tool"></a>
</h3>
<p>The <code>seff</code> command can be used to learn about how
efficiently your job has run. The <code>seff</code> command takes the
job identifier as an argument to select which job it displays
information about. That means we need to run a job first to get a job
identifier we can query SLURM about. Then we can ask about the
efficiency of the job.</p>
<div id="seff-may-not-be-available" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<span class="callout-header">Callout</span>
<div id="seff-may-not-be-available" class="callout-inner">
<h3 class="callout-title">
<code>seff</code> may not be available</h3>
<div class="callout-content">
<p><code>seff</code> is an optional SLURM tool for more convenient
access to <code>saact</code>. It does not come standard with every SLURM
installation. Your particular HPC system may or may not provide it.
Check for it’s availability on your login nodes, or consult your cluster
documentation or support staff.</p>
<p>Other third party alternatives, e.g. <a href="https://github.com/troycomi/reportseff/" class="external-link">reportseff</a>, can be
installed with default user permissions.</p>
</div>
</div>
</div>
<p>The <code>sbatch</code> command is used to submit a job. It takes a
job script as an argument. The job script contains the resource
requests, such as the amount of time needed for the calculation, the
number of nodes, the number of tasks per node, and so on. It also
contains the commands to execute the calculations.</p>
<p>Using your favorite editor, create the job script
<code>render_snowman.sbatch</code> with the contents below.</p>
<pre class="input"><code>#!/usr/bin/bash
#SBATCH --time=01:00:00
#SBATCH --nodes=1
#SBATCH --tasks-per-node=4

# Possibly a "module load ..." command to load required libraries
# Depends on your particular HPC system

mpirun -np 4 raytracer -width=800 -height=800 -spp=128 -alloc_mode=3</code></pre>
<p>Next submit the job with <code>sbatch</code>, and see what
<code>seff</code> says about the job with the following commands.</p>
<div class="codewrapper sourceCode" id="cb2">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="va">jobid</span><span class="op">=</span><span class="va">$(</span><span class="ex">sbatch</span> <span class="at">--parsable</span> render_snowman.sbatch<span class="va">)</span></span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a><span class="ex">seff</span> <span class="va">$jobid</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>Job ID: 309489
Cluster: bigiron
User/Group: usr123/grp123
State: COMPLETED (exit code 0)
Nodes: 1
Cores per node: 4
CPU Utilized: 00:07:43
CPU Efficiency: 98.93% of 00:07:48 core-walltime
Job Wall-clock time: 00:01:57
Memory Utilized: 35.75 MB
Memory Efficiency: 0.20% of 17.58 GB (4.39 GB/core)</code></pre>
</div>
<p>The job script we created asks for 4 CPUs for an hour. After
submitting the job script we need to wait until the job has finished as
<code>seff</code> can only report sensible statistics after the job is
completed. The report from <code>seff</code> shows basic statistics
about the job, such as</p>
<ul>
<li>The resources the job was given
<ul>
<li>the number of nodes</li>
<li>the number of cores per node</li>
<li>the amount of memory per core</li>
</ul>
</li>
<li>The amount of resources used
<ul>
<li>
<code>CPU Utilized</code> the aggregate CPU time (the time the job
took times the number of CPUs allocated)</li>
<li>
<code>CPU Efficiency</code> the actual CPU usage as a percentage of
the total available CPU capacity</li>
<li>
<code>Job Wall-clock time</code> the time the job took from start to
finish</li>
<li>
<code>Memory Utilized</code> the aggregate memory usage</li>
<li>
<code>Memory Efficiency</code> the actual memory usage as a
percentage of the total avaialable memory</li>
</ul>
</li>
</ul>
<div id="accordionInstructor2" class="accordion instructor-note accordion-flush">
<div class="accordion-item">
<button class="accordion-button instructor-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseInstructor2" aria-expanded="false" aria-controls="collapseInstructor2">
  <h3 class="accordion-header" id="headingInstructor2">  <div class="note-square"><i aria-hidden="true" class="callout-icon" data-feather="edit-2"></i></div> Todo: give clear recommendation of what to aim for? </h3>
</button>
<div id="collapseInstructor2" class="accordion-collapse collapse" aria-labelledby="headingInstructor2" data-bs-parent="#accordionInstructor2">
<div class="accordion-body">
<p>Maybe 80% of job time?</p>
</div>
</div>
</div>
</div>
<p>Looking at the <code>Job Wall-clock time</code> it shows that the job
took just under 2 minutes. Therefore this job took a lot less time than
the one hour we asked for. This can be problematic as the scheduler
looks for time windows when it can fit a job in. Long running jobs
cannot be squeezed in as easily as short running jobs. As a result, jobs
that request a long time to complete typically have to wait longer
before they can be started. Therefore asking for more than 10 times as
much time as the job really needs, simply means that you will have to
wait longer for the job to start. On the other hand you do not want to
ask for too little time. Few things are more annoying than waiting for a
long running calculation to finish, just to see the job being killed
right before the end because it would have needed a couple of minutes
more than you asked for. So the best approach is to ask for more time
than the job needs, but not go overboard here. As the job elapse time
depends on many machine conditions, including congestion in the data
communication, disk access, operating system jitter, and so on, you
might want to ask for a substantial buffer. Nevertheless, asking for
more than twice as much time as job is expected to need, usually doesn’t
make sense.</p>
<p>Another thing is that SLURM by default reserves a certain amount of
memory per core. In this case the actual memory usage is just a fraction
of that amount. We could reduce the memory allocation by explicitly
asking for less by modifying the <code>render_snowman.sbatch</code> job
script.</p>
<div id="accordionInstructor3" class="accordion instructor-note accordion-flush">
<div class="accordion-item">
<button class="accordion-button instructor-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseInstructor3" aria-expanded="false" aria-controls="collapseInstructor3">
  <h3 class="accordion-header" id="headingInstructor3">  <div class="note-square"><i aria-hidden="true" class="callout-icon" data-feather="edit-2"></i></div> Todo: potential issue? </h3>
</button>
<div id="collapseInstructor3" class="accordion-collapse collapse" aria-labelledby="headingInstructor3" data-bs-parent="#accordionInstructor3">
<div class="accordion-body">
<p>Running this on our cluster and adding a module load command resulted
in 600MB of memory required. My guess is, this is due to cgroups_v2 and
Page caches being counted towards the job as well, so loading the
modules might spike the resource requirements as well?</p>
<p>Maybe we should play it safe and use a larger value in the following
exercise. But we also want to teach not overdoing it, so it’d be good if
we can find a useful but generic compromise here</p>
</div>
</div>
</div>
</div>
<div id="challenge1" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<span class="callout-header">Challenge</span>
<div class="callout-inner">
<h3 class="callout-title">Challenge</h3>
<div class="callout-content">
<p>Edit the batch file to reduce the amount of memory requested for the
job. Note that the amount of memory per node can be requested with the
<code>--mem=</code> argument. The amount of memory is specified by a
number followed by a unit. The units can represent kilobtytes (KB),
megabytes (MB), gigabytes (GB). For the calculations we are doing here
100 megabytes per node is more than sufficient. Submit the job, and
inspect the efficiency with <code>seff</code>. What is the memory usage
efficiency you get?</p>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1"> Show me the solution </h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" aria-labelledby="headingSolution1" data-bs-parent="#accordionSolution1">
<div class="accordion-body">
<p>The batch file after adding the memory request becomes.</p>
<pre class="input"><code>#!/usr/bin/bash
#SBATCH --time=01:00:00
#SBATCH --nodes=1
#SBATCH --tasks-per-node=4
#SBATCH --mem=100MB

# Possibly a "module load ..." command to load required libraries
# Depends on your particular HPC system

mpirun -np 4 raytracer -width=800 -height=800 -spp=128 -alloc_mode=3</code></pre>
<p>Submit this jobscript, as before, with the following command.</p>
<div class="codewrapper sourceCode" id="cb5">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a><span class="va">jobid</span><span class="op">=</span><span class="va">$(</span><span class="ex">sbatch</span> <span class="at">--parsable</span> render_snowman.sbatch<span class="va">)</span></span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a><span class="ex">seff</span> <span class="va">$jobid</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>Job ID: 310002
Cluster: bigiron
User/Group: usr123/grp123
State: COMPLETED (exit code 0)
Nodes: 1
Cores per node: 4
CPU Utilized: 00:07:43
CPU Efficiency: 98.09% of 00:07:52 core-walltime
Job Wall-clock time: 00:01:58
Memory Utilized: 50.35 MB
Memory Efficiency: 50.35% of 100.00 MB (100.00 MB/node)</code></pre>
</div>
<p>The output of <code>seff</code> shows that about 50% of requested
memory was used.</p>
</div>
</div>
</div>
</div>
<p>Now we see that a much larger fraction of the allocated memory has
been used. Normally you would not worry too much about the memory
request. Lately HPC clusters are used more for machine learning work
loads which tend to require a lot of memory. Their memory requirements
per core might actually be so large that they cannot use all the cores
in a node. So there may be spare cores available for jobs that need
little memory. In such a scenario tightening the memory allocation up
could allow the scheduler to start your job early. How much milage you
might get from this depends on the job mix at the HPC site where you run
your calculations.</p>
<p>Note that the CPU utilization is reported as almost 100%, but this
just means that the CPU was busy with your job 100% of the time. It does
not mean that this time was well spent. For example, every parallel
program has some serial parts to the code. Typically those parts are
executed redundantly on all cores, which is wasteful but not reflected
in the CPU efficiency. Also, this number does not reflect how well the
capabilities of the CPU are used. If your CPU offers vector
instructions, for example, but your code does not use them then your
code will just run slow. The CPU efficiency will still show that the CPU
was busy 100% of the time even though the program is just running at a
fraction of the speed it could achieve if it fully exploited the
hardware capabilities. It is worth keeping these limitations of
<code>seff</code> in mind.</p>
<div id="good-utilization-does-not-imply-efficiency" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<span class="callout-header">Callout</span>
<div id="good-utilization-does-not-imply-efficiency" class="callout-inner">
<h3 class="callout-title">Good utilization does not imply
efficiency</h3>
<div class="callout-content">
<p>Measuring close to 100% CPU utilization does not say anything about
how useful the calculations are. It’s merely stating, that the CPU was
mostly busy with calculations, instead of waiting for data or running
idle, waiting for other conditions to occur.</p>
<p>Good CPU utilization is only efficient, if it runs only “useful”
calculations that contribute with new results towards an intended
goal.</p>
</div>
</div>
</div>
<p>The <code>seff</code> command cannot give you any information about
the I/O performance of your job. You have to use other approaches for
that, and <code>sacct</code> may be one of them.</p>
</div>
<div class="section level3">
<h3 id="the-sacct-tool">The <code>sacct</code> tool<a class="anchor" aria-label="anchor" href="#the-sacct-tool"></a>
</h3>
<div id="accordionInstructor4" class="accordion instructor-note accordion-flush">
<div class="accordion-item">
<button class="accordion-button instructor-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseInstructor4" aria-expanded="false" aria-controls="collapseInstructor4">
  <h3 class="accordion-header" id="headingInstructor4">  <div class="note-square"><i aria-hidden="true" class="callout-icon" data-feather="edit-2"></i></div> Instructor Note </h3>
</button>
<div id="collapseInstructor4" class="accordion-collapse collapse" aria-labelledby="headingInstructor4" data-bs-parent="#accordionInstructor4">
<div class="accordion-body">
<p>Note that the information <code>sacct</code> can provide depends on
the information that SLURM stores on a given machine. By default this
includes Billing, CPU, Energy, Memory, Node, FS/Disk, Pages and VMem.
Additional information is available only when SLURM is configured to
collect it. These additional trackable resources are listed in
<code>AccountingStorageTRES</code>. For I/O <code>fs/lustre</code> is
commonly useful, and for the interconnect communication
<code>ic/ofed</code> is required. The setting
<code>AccountingStorageTRES</code> is found in <code>slurm.conf</code>.
Unfortunately there doesn’t seem to be a way to get <code>sacct</code>
to print the optional trackable resources.</p>
</div>
</div>
</div>
</div>
<p>The <code>sacct</code> command shows data stored in the job
accounting database. You can query the data of any of your previously
run jobs. Just like with <code>seff</code> you will need to provide the
job ID to query the accounting database. Rather than keeping track of
all your jobs yourself you can ask <code>sacct</code> to provide you
with an overview of the jobs you have run.</p>
<div class="codewrapper sourceCode" id="cb7">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="ex">sacct</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>JobID           JobName  Partition    Account  AllocCPUS      State ExitCode
------------ ---------- ---------- ---------- ---------- ---------- --------
309902       render_sn+  STD-s-96h  project_a          4  COMPLETED      0:0
309902.batch      batch             project_a          4  COMPLETED      0:0
309902.exte+     extern             project_a          4  COMPLETED      0:0
309903       render_sn+  STD-s-96h  project_a          4  COMPLETED      0:0
309903.batch      batch             project_a          4  COMPLETED      0:0
309903.exte+     extern             project_a          4  COMPLETED      0:0
310002       render_sn+  STD-s-96h  project_a          4  COMPLETED      0:0
310002.batch      batch             project_a          4  COMPLETED      0:0
310002.exte+     extern             project_a          4  COMPLETED      0:0</code></pre>
</div>
<p>In the output every job is shown three times here. This is because
<code>sacct</code> lists one line for the primary job entry, followed by
a line for every job step. A job step corresponds to an
<code>mpirun</code> or <code>srun</code> command. The
<code>extern</code> line corresponds to all work that is done outside of
SLURM’s control, for example an <code>ssh</code> command that runs
something somewhere else.</p>
<p>Note that by default <code>sacct</code> only lists the jobs that have
been run today. You can use the <code>--starttime</code> option to list
all jobs that have been run since the given start date. For example, try
running</p>
<div class="codewrapper sourceCode" id="cb9">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a><span class="ex">sacct</span> <span class="at">--starttime</span><span class="op">=</span>2025-09-25</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>JobID           JobName  Partition    Account  AllocCPUS      State ExitCode
------------ ---------- ---------- ---------- ---------- ---------- --------
308755       snowman.s+  STD-s-96h  project_a         16  COMPLETED      0:0
308755.batch      batch             project_a         16  COMPLETED      0:0
308755.exte+     extern             project_a         16  COMPLETED      0:0
308756       snowman.s+  STD-s-96h  project_a          4  COMPLETED      0:0
308756.batch      batch             project_a          4  COMPLETED      0:0
308756.exte+     extern             project_a          4  COMPLETED      0:0
309486       interacti+  STD-s-96h  project_a          4     FAILED      1:0
309486.exte+     extern             project_a          4  COMPLETED      0:0
309486.0          prted             project_a          4  COMPLETED      0:0
309489       render_sn+  STD-s-96h  project_a          4  COMPLETED      0:0
309489.batch      batch             project_a          4  COMPLETED      0:0
309489.exte+     extern             project_a          4  COMPLETED      0:0
309902       render_sn+  STD-s-96h  project_a          4  COMPLETED      0:0
309902.batch      batch             project_a          4  COMPLETED      0:0
309902.exte+     extern             project_a          4  COMPLETED      0:0
309903       render_sn+  STD-s-96h  project_a          4  COMPLETED      0:0
309903.batch      batch             project_a          4  COMPLETED      0:0
309903.exte+     extern             project_a          4  COMPLETED      0:0
310002       render_sn+  STD-s-96h  project_a          4  COMPLETED      0:0
310002.batch      batch             project_a          4  COMPLETED      0:0
310002.exte+     extern             project_a          4  COMPLETED      0:0</code></pre>
</div>
<p>You may want to change the date of <code>2025-09-25</code> to
something more sensible when you work through this tutorial. Note that
some HPC systems may limit the range of such a request to a maximum of,
for example, 30 days to avoid overloading the slurm database with too
large requests.</p>
<p>With the job ID you can ask <code>sacct</code> for information about
a specific job as in</p>
<div class="codewrapper sourceCode" id="cb11">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a><span class="ex">sacct</span> <span class="at">--jobs</span><span class="op">=</span>310002</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>JobID           JobName  Partition    Account  AllocCPUS      State ExitCode
------------ ---------- ---------- ---------- ---------- ---------- --------
310002       render_sn+  STD-s-96h  project_a          4  COMPLETED      0:0
310002.batch      batch             project_a          4  COMPLETED      0:0
310002.exte+     extern             project_a          4  COMPLETED      0:0</code></pre>
</div>
<p>Using <code>sacct</code> with the <code>--jobs</code> flag is just
another way to select which jobs we want more information about. In
itself it does not provide any additional information. To get more
specific data we need to explicitly ask for the information we want. As
SLURM collects a broad range of data about every job it is worth to
evaluate what the most relevant items are.</p>
<div id="accordionInstructor5" class="accordion instructor-note accordion-flush">
<div class="accordion-item">
<button class="accordion-button instructor-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseInstructor5" aria-expanded="false" aria-controls="collapseInstructor5">
  <h3 class="accordion-header" id="headingInstructor5">  <div class="note-square"><i aria-hidden="true" class="callout-icon" data-feather="edit-2"></i></div> Todo: extend the following list and examples to include CPU </h3>
</button>
<div id="collapseInstructor5" class="accordion-collapse collapse" aria-labelledby="headingInstructor5" data-bs-parent="#accordionInstructor5">
<div class="accordion-body">
<p>To reconstruct the CPU utilization reported by <code>seff</code>: -
<code>TotalCPU</code>/<code>CPUTime</code> should give the percentage -
Could also mention <code>UserCPU</code> and <code>SystemCPU</code> and
discuss the difference? Both result in <code>TotalCPU</code></p>
<p>Maybe remove <code>AveCPUFreq</code> instead, or do we try to teach
something specific about it?</p>
<p>Don’t forget to change the example output of all <code>sacct</code>s
in the following examples/challenges!</p>
</div>
</div>
</div>
</div>
<ul>
<li>
<code>MaxRSS</code>, <code>AveRSS</code>, or the Maximum or Average
Resident Size Set (RSS). The RSS is the memory allocated by a program
that is actually resident in the main memory of the computer. If the
computer gets low on memory then the virtual memory manager can extend
the apparently available memory by moving some of the data from memory
to disk. This is done entirely transparently to the application, but the
data that has been moved to disk is no longer resident in main memory.
As a result accessing it will be slower because it needs to retrieved
from disk first. Therefore if the RSS is small compared to the total
amount of memory the program uses this might affect the performance of
the program.</li>
<li>
<code>MaxPages</code>, <code>AvePages</code>, or the Maximum or
Average number of Page Faults. These quantities are related to the
Resident Size Sets. When the program tries to access data that is not
resident in main memory this triggers a page fault. The virtual memory
manager responds to a page fault by retrieving the accessed data from
disk (and potentially migrating other data to disk to make space). These
operations are typically costly. Therefore high numbers of page faults
typically correspond to a significant reduction in the program’s
performance. For example, the CPU utilization might drop from as high as
98% to as low as 2% due to page faults. For that reason some HPC
machines are configured to kill your job if the application generates a
high rate of page faults.</li>
<li>
<code>AllocCPUS</code> is the number of CPUs allocated for the
job.</li>
<li>
<code>Elapsed</code> is the amount of wall clock time it took to
complete the job. I.e. the amount of time that passed between the start
and finish of the job.</li>
<li>
<code>MaxDiskRead</code>, the Maximum amount of data read from
disk.</li>
<li>
<code>MaxDiskWrite</code>, the Maximum amount of data written to
disk.</li>
<li>
<code>ConsumedEnergy</code>, the amount of energy consumed by the
job if that information was collected. The data may not be collected on
your particular HPC system and is reported as 0.</li>
<li>
<code>AveCPUFreq</code>, the average CPU frequency of all tasks in a
job, given in kHz. In general the higher the clock frequency of the
processor the faster the calculation runs. The exception is if the
application is memory bandwidth limited and the data cannot be moved to
processor fast enough to keep it busy. In that case modern hardware
might throttle the frequency. This saves energy as the power consumption
scales linearly with the clock frequency, but doesn’t slow the
calculation down as the processor was having to wait for data
anyway.</li>
</ul>
<p>We can explicitly select the data elements that we are interested in.
To see how long the job took to complete run</p>
<div class="codewrapper sourceCode" id="cb13">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a><span class="ex">sacct</span> <span class="at">--jobs</span><span class="op">=</span>310002 <span class="at">--format</span><span class="op">=</span>Elapsed</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code><span>   <span class="va">Elapsed</span></span>
<span><span class="op">-</span><span class="op">-</span><span class="op">-</span><span class="op">-</span><span class="op">-</span><span class="op">-</span><span class="op">-</span><span class="op">-</span><span class="op">-</span><span class="op">-</span></span>
<span>  <span class="fl">00</span><span class="op">:</span><span class="fl">01</span><span class="op">:</span><span class="fl">58</span></span>
<span>  <span class="fl">00</span><span class="op">:</span><span class="fl">01</span><span class="op">:</span><span class="fl">58</span></span>
<span>  <span class="fl">00</span><span class="op">:</span><span class="fl">01</span><span class="op">:</span><span class="fl">58</span></span></code></pre>
</div>
<div id="challenge2" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<span class="callout-header">Challenge</span>
<div class="callout-inner">
<h3 class="callout-title">Challenge</h3>
<div class="callout-content">
<p>Request information regarding all of the above variables from
<code>sacct</code>, including <code>JobID</code>. Note that the
<code>--format</code> flag takes a comma separated list. Also note that
the result shows that more data is read than written, even though the
program generates and write an image, and reads no data at all. Why
would that be?</p>
</div>
</div>
</div>
<div id="accordionSolution2" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution2" aria-expanded="false" aria-controls="collapseSolution2">
  <h4 class="accordion-header" id="headingSolution2"> Show me the solution </h4>
</button>
<div id="collapseSolution2" class="accordion-collapse collapse" aria-labelledby="headingSolution2" data-bs-parent="#accordionSolution2">
<div class="accordion-body">
<p>To query all of the above variable run</p>
<div class="codewrapper sourceCode" id="cb15">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a><span class="ex">sacct</span> <span class="at">--jobs</span><span class="op">=</span>310002 <span class="at">--format</span><span class="op">=</span>MaxRSS,AveRSS,MaxPages,AvePages,AllocCPUS,Elapsed,MaxDiskRead,MaxDiskWrite,ConsumedEnergy,AveCPUFreq</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>    MaxRSS     AveRSS MaxPages   AvePages  AllocCPUS    Elapsed  MaxDiskRead MaxDiskWrite ConsumedEnergy AveCPUFreq
---------- ---------- -------- ---------- ---------- ---------- ------------ ------------ -------------- ----------
                                                   4   00:01:58                                        0
    51556K     51556K      132        132          4   00:01:58        6.91M        0.72M              0         3M
         0          0        0          0          4   00:01:58        0.01M        0.00M              0         3M</code></pre>
</div>
<p>Although the program we have run generates an image and writes that
to a file, there is also a none zero amount of data read. The writing
part is associated with the image file the program writes. The reading
part is not associated with anything that the program does, as it
doesn’t read anything from disk. It is instead associated with the fact
that the operating system has to read the program itself and it’s
dependencies to execute it.</p>
</div>
</div>
</div>
</div>
<div id="accordionInstructor6" class="accordion instructor-note accordion-flush">
<div class="accordion-item">
<button class="accordion-button instructor-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseInstructor6" aria-expanded="false" aria-controls="collapseInstructor6">
  <h3 class="accordion-header" id="headingInstructor6">  <div class="note-square"><i aria-hidden="true" class="callout-icon" data-feather="edit-2"></i></div> Give more insight in the collected sacct metrics </h3>
</button>
<div id="collapseInstructor6" class="accordion-collapse collapse" aria-labelledby="headingInstructor6" data-bs-parent="#accordionInstructor6">
<div class="accordion-body">
<ul>
<li>
<code>AllocCPUS</code>: number of CPU cores we requested for the
job</li>
<li>
<code>MaxRSS</code> = <code>AveRSS</code>: low fluctuation in
memory, data is held throughout the whole job</li>
<li>
<code>MaxPages</code> &amp; <code>AvePages</code>: number of pages
loaded into memory</li>
<li>
<code>MaxDiskRead</code>: Data read from disk by the application,
but also to start the application.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</section><section><h2 class="section-heading" id="shortcomings">Shortcomings<a class="anchor" aria-label="anchor" href="#shortcomings"></a>
</h2>
<hr class="half-width">
<p>While <code>seff</code> and <code>sacct</code> provide a lot of
information it is still incomplete. For example, the information is
accumulated for the entire calculation. Variations in the metrics as a
function of time throughout the job are not available. Communication
between different MPI processes is not recorded. The collection of the
energy consumption depends on the hardware and system configuration at
the HPC center and might not be available. We are also often missing
reliable measurements for I/O via the interconnect between nodes and the
parallel file system.</p>
<p>So while we might be able to glean some indications for different
types of performance problems, for a proper analysis more detailed
information is needed.</p>
</section><section><h2 class="section-heading" id="summary">Summary<a class="anchor" aria-label="anchor" href="#summary"></a>
</h2>
<hr class="half-width">
<p>This episode introduced the SLURM tools <code>seff</code> and
<code>sacct</code> to get a high level perspective on a job’s
performance. As these tools just use the statistics that SLURM collected
on a job as it ran, they can always be used without any special
preparation.</p>
<div id="challenge3" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<span class="callout-header">Challenge</span>
<div class="callout-inner">
<h3 class="callout-title">Challenge</h3>
<div class="callout-content">
<p>So far we have considered our initial calculation using 4 cores. To
run the calculation faster we could consider using more cores. Run the
same calculation on 8, 16, and 32 cores as well. Collect and compare the
results from <code>sacct</code> and see how the job performance
changes.</p>
</div>
</div>
</div>
<div id="accordionSolution3" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution3" aria-expanded="false" aria-controls="collapseSolution3">
  <h4 class="accordion-header" id="headingSolution3"> Show me the solution </h4>
</button>
<div id="collapseSolution3" class="accordion-collapse collapse" aria-labelledby="headingSolution3" data-bs-parent="#accordionSolution3">
<div class="accordion-body">
<p>The machine these calculations have been run on has 112 core per
node. So we can double the number of cores from 4 until 64 and stay
within one node. If we go to two nodes then some of the communication
between tasks will have to go across the interconnect. At that point the
performance characteristics might change in a discontinuous manner.
Hence we try to avoid doing that.</p>
<p>Alternatively you might scale the calculation across multiple nodes,
for example 2, 4, 8, 16 nodes. With 112 cores per node you would have to
make sure that the calculation is large enough for such a large number
of cores to make sense.</p>
<p>Create <code>running_snowmen.sh</code> with</p>
<pre class="input"><code>#!/usr/bin/bash
for nn in 4 8 16 32; do
    id=`sbatch --parsable --time=00:12:00 --nodes=1 --tasks-per-node=$nn --ntasks-per-core=1 render_snowman.sh`
    echo "ntasks $nn jobid $id"
done</code></pre>
<p>Create <code>render_snowman.sh</code> with</p>
<pre class="input"><code>#!/usr/bin/bash

# Possibly a "module load ..." command to load required libraries
# Depends on your particular HPC system

export START=`pwd`
# Create a sub-directory for this job if it doesn't exist already
mkdir -p $START/test.$SLURM_NTASKS
cd $START/test.$SLURM_NTASKS
# The -spp flag ensures we have enough samples per ray such that the job
# on 32 cores takes longer than 30s. Slurm by default is configured such
# that job data is collected every 30s. If the job finishes in less than
# that Slurm might fail to collect some of the data about the job.
mpirun -np $SLURM_NTASKS raytracer -width=800 -height=800 -spp 1024 -threads=1 -alloc_mode=3 -png=rendered_snowman.png</code></pre>
<p>Next we submit this whole set of calculations</p>
<div class="codewrapper sourceCode" id="cb19">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb19-1"><a href="#cb19-1" tabindex="-1"></a><span class="ex">./running_snowmen.sh</span></span></code></pre>
</div>
<p>producing</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>ntasks 4 jobid 349291
ntasks 8 jobid 349292
ntasks 16 jobid 349293
ntasks 32 jobid 349294</code></pre>
</div>
<p>After the jobs are completed we can run</p>
<div class="codewrapper sourceCode" id="cb21">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb21-1"><a href="#cb21-1" tabindex="-1"></a><span class="ex">sacct</span> <span class="at">--jobs</span><span class="op">=</span>349291,349292,349293,349294 <span class="dt">\</span></span>
<span id="cb21-2"><a href="#cb21-2" tabindex="-1"></a>      <span class="at">--format</span><span class="op">=</span>MaxRSS,AveRSS,MaxPages,AvePages,AllocCPUS,Elapsed,MaxDiskRead,MaxDiskWrite,ConsumedEnergy,AveCPUFreq</span></code></pre>
</div>
<p>to produce</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>    MaxRSS     AveRSS MaxPages   AvePages  AllocCPUS    Elapsed  MaxDiskRead MaxDiskWrite ConsumedEnergy AveCPUFreq
---------- ---------- -------- ---------- ---------- ---------- ------------ ------------ -------------- ----------
                                                   4   00:09:35                                        0
   142676K    142676K        1          1          4   00:09:35        7.75M        0.72M              0       743K
         0          0        0          0          4   00:09:35        0.01M        0.00M              0      2.61M
                                                   8   00:05:01                                        0
   289024K    289024K        0          0          8   00:05:01       10.15M        1.45M              0       960K
         0          0        0          0          8   00:05:02        0.01M        0.00M              0      2.42M
                                                  16   00:02:21                                        0
   563972K    563972K       93         93         16   00:02:21       15.00M        2.94M              0      1.03M
         0          0        0          0         16   00:02:21        0.01M        0.00M              0      2.99M
                                                  32   00:01:14                                        0
  1082540K   1082540K      260        260         32   00:01:14       24.83M        6.07M              0      1.08M
         0          0        0          0         32   00:01:14        0.01M        0.00M              0         3M</code></pre>
</div>
<p>Note that the elapse time goes down as the number of cores increases,
which is reasonable as more cores normally can get the job done quicker.
The amount of data read also increases as every MPI rank has to read the
executable and all associated shared libraries. The volume of data
written is harder to understand. Every run produces an image file
<code>rendered_snowman.png</code> that is about 100KB in size. This file
is written just by the root MPI rank. This cannot explain the increase
in data written with increasing numbers of cores. The increasing number
of page faults with increasing numbers of cores suggests that paging
memory to disk is responsible for the majority of data written.</p>
</div>
</div>
</div>
</div>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<span class="callout-header">Key Points</span>
<div class="callout-inner">
<div class="callout-content">
<ul>
<li>Schedulers provide tools for a high level view on our jobs,
e.g. <code>sacct</code> and <code>seff</code>
</li>
<li>Important basic performance metrics we can gather this way are:
<ul>
<li>
<strong>CPU Utilization</strong>, often as fraction of
<code>time where CPU was active</code>/<code>elapsed time of the job</code>
</li>
<li>
<strong>Memory utilization</strong>, often measured as <em>Resident
Set Size</em> (RSS) and number of <em>Pages</em>
</li>
</ul>
</li>
<li>
<code>sacct</code> can also provide metrics about disk I/O and
energy consumption</li>
<li>Metrics through <code>sacct</code> are accumulated for the whole job
runtime and may be too broad for more specific insight</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</section></section><section id="aio-04_scalingstudy"><p>Content from <a href="04_scalingstudy.html">Scaling Study</a></p>
<hr>
<p>Last updated on 2025-12-12 |

        <a href="https://github.com/stderr-enst/jobefficiency/edit/main/episodes/04_scalingstudy.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 70 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>How many resources should be requested for a given job?</li>
<li>How does our application behave at different scales?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<p>After completing this episode, participants should be able to …</p>
<ul>
<li>Perform a scaling study for a given application.</li>
<li>Notice different perspectives on scaling parameters.</li>
<li>Identify good working points for the job configuration.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="accordionInstructor1" class="accordion instructor-note accordion-flush">
<div class="accordion-item">
<button class="accordion-button instructor-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseInstructor1" aria-expanded="false" aria-controls="collapseInstructor1">
  <h3 class="accordion-header" id="headingInstructor1">  <div class="note-square"><i aria-hidden="true" class="callout-icon" data-feather="edit-2"></i></div> Intention: Introduce/Recollect concept of Speedup and do a simple scaling study </h3>
</button>
<div id="collapseInstructor1" class="accordion-collapse collapse" data-bs-parent="#accordionInstructor1" aria-labelledby="headingInstructor1">
<div class="accordion-body">
<p>Narrative:</p>
<ul>
<li>We panic, maybe we need more resources to meet the deadline with our
title picture!</li>
<li>Requesting resources with bigger systems requires a project proposal
with an estimate of the resource demand</li>
</ul>
</div>
</div>
</div>
</div>
<p>The deadline is approaching way too fast and we may not finish our
project in time. Maybe requesting more resources from our clusters
scheduler does the trick? How could we know if it helps and by how
much?</p>
<section><h2 class="section-heading" id="what-is-scaling">What is Scaling?<a class="anchor" aria-label="anchor" href="#what-is-scaling"></a>
</h2>
<hr class="half-width">
<p>The execution time of parallel applications changes with the number
of parallel processes or threads. In a <em>scaling study</em> we measure
how much the execution time changes by scanning a reasonable range of
number of processes. In a common phrasing, this approach answers how the
execution time <em>scales</em> with the number of parallel
processors.</p>
<p>Starting from the job script <code>render_snowman.sbatch</code>:</p>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="co">#!/usr/bin/bash</span></span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="co">#SBATCH --time=01:00:00</span></span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a><span class="co">#SBATCH --nodes=1</span></span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a><span class="co">#SBATCH --mem-per-cpu=200MB</span></span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a><span class="co"># The `module load` command you had to load for building the raytracer</span></span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a><span class="ex">module</span> load 2025 GCC/13.2.0 OpenMPI/4.1.6 buildenv/default Boost/1.83.0 CMake/3.27.6 libpng/1.6.40</span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" tabindex="-1"></a><span class="bu">time</span> mpirun <span class="at">--</span> ./raytracer <span class="at">-width</span><span class="op">=</span>800 <span class="at">-height</span><span class="op">=</span>800 <span class="at">-spp</span><span class="op">=</span>128 <span class="at">-png</span> <span class="st">"</span><span class="va">$(</span><span class="fu">date</span> +%Y-%m-%d_%H%M%S<span class="va">)</span><span class="st">.png"</span></span></code></pre>
</div>
<p>we can manually run such a scaling study by submitting multiple jobs.
In OpenMPI versions 4 and 5 the number of Slurm tasks is automatically
picked up, so we do not set <code>-n</code> or <code>-np</code> of
<code>mpirun</code>. We use <code>--</code> to separate the arguments of
<code>mpirun</code> – none in this case – from the MPI application
<code>raytracer</code> and its arguments. Otherwise you may experience
errors in some versions of OpenMPI 5, where <code>mpirun</code>
misinterprets the arguments of <code>raytracer</code> as its own.</p>
<div id="scaling-other-resources-with-number-of-cpu-cores" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<span class="callout-header">Callout</span>
<div id="scaling-other-resources-with-number-of-cpu-cores" class="callout-inner">
<h3 class="callout-title">Scaling other resources with number of CPU
cores</h3>
<div class="callout-content">
<p>When scaling the resources outside of the job script, e.g. with
<code>sbatch --ntasks=X ...</code>, as done above, we make sure to scale
other resource requirements with the number of parallel processors. In
this case, <code>--mem-per-cpu=200MB</code> is necessary, since
<code>--mem</code> results in a fixed memory limit, independent of the
number of processes.</p>
<p>For example, if each MPI process needs <span class="math inline">\(100\,\)</span>MB, requesting <span class="math inline">\(2\,\)</span>GB would only be enough for up to 20
MPI processes.</p>
<p>Forgetting a limit like this is a common pitfall in this
situation.</p>
</div>
</div>
</div>
<p>Let’s start some measurements with <span class="math inline">\(1\)</span>, <span class="math inline">\(2\)</span>, <span class="math inline">\(4\)</span>, and <span class="math inline">\(8\)</span> tasks:</p>
<div id="accordionInstructor2" class="accordion instructor-note accordion-flush">
<div class="accordion-item">
<button class="accordion-button instructor-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseInstructor2" aria-expanded="false" aria-controls="collapseInstructor2">
  <h3 class="accordion-header" id="headingInstructor2">  <div class="note-square"><i aria-hidden="true" class="callout-icon" data-feather="edit-2"></i></div> Slurm Reservation and specific Hardware? </h3>
</button>
<div id="collapseInstructor2" class="accordion-collapse collapse" data-bs-parent="#accordionInstructor2" aria-labelledby="headingInstructor2">
<div class="accordion-body">
<p>You may need to reserve a set of resources for the course, such that
enough resources for the following exercises are available. This is
especially important for <code>--exclusive</code> access.</p>
<p>In that case, show how to use
<code>--reservation=reservationname</code> to submit jobs.</p>
<p>It may be a good idea to point out the particular hardware of your
cluster / partition to emphasize how many cores are available on a
single node and when the scaling study goes beyond a single node.</p>
</div>
</div>
</div>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>$ sbatch --ntasks 1 render_snowman.sbatch
Submitted batch job 16142767
$ sbatch --ntasks 2 render_snowman.sbatch
Submitted batch job 16142768
$ sbatch --ntasks 4 render_snowman.sbatch
Submitted batch job 16142769
$ sbatch --ntasks 8 render_snowman.sbatch
Submitted batch job 16142770</code></pre>
</div>
<p>Now we have to wait until all four jobs are finished.</p>
<div id="regular-update-of-squeue" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<span class="callout-header">Callout</span>
<div id="regular-update-of-squeue" class="callout-inner">
<h3 class="callout-title">Regular update of <code>squeue</code>
</h3>
<div class="callout-content">
<p>You can use <code>squeue --me -i 30</code> to get an update of all of
your jobs every 30 seconds.</p>
<p>If you don’t need a more regular update, it is good practice to keep
the interval on the order of 30s to a couple of minutes, just to be nice
to Slurms server resources.</p>
</div>
</div>
</div>
<p>Once the jobs are finished, we can use <code>grep</code> to get the
wall clock time of all four jobs:</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>slurm-16142767.out:real       2m7.218s
slurm-16142768.out:real       1m7.443s
slurm-16142769.out:real       0m32.584s
slurm-16142770.out:real       0m17.480s</code></pre>
</div>
<p>The real-time is decreasing significantly each time we double the
number of Slurm tasks. From this, we feel that doubling the number of
CPU cores really is a winning strategy!</p>
<div id="exercise-continue-scaling-study-to-larger-values" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<span class="callout-header">Challenge</span>
<div id="exercise-continue-scaling-study-to-larger-values" class="callout-inner">
<h3 class="callout-title">Exercise: Continue scaling study to larger
values</h3>
<div class="callout-content">
<p>Run the same scaling study and continue it for even larger number of
<code>--ntasks</code>, e.g. 16, 32, 64, 128. So far, we have been using
<code>--nodes=1</code> to stay on a single node. At which point are your
MPI processes distributed across more than one node? Use Slurm command
line tools to find out the how many CPU cores (MPI processes) are
available on a single node. You may have to increase the number of nodes
with <code>--nodes</code>, if you want to go beyond that limit.</p>
<p>Gather your <code>real</code> time results and place them in a
<code>.csv</code> file. Here is an example for our previous
measurements:</p>
<pre class="csv"><code>ntasks,time
1,127.218
2,67.443
4,32.584
8,17.480
...</code></pre>
<p>How much does each doubling of the CPU resources help with running
the parallel raytracer?</p>
</div>
</div>
</div>
<div id="accordionHint1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button hint-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseHint1" aria-expanded="false" aria-controls="collapseHint1">
  <h4 class="accordion-header" id="headingHint1"> Give me a hint </h4>
</button>
<div id="collapseHint1" class="accordion-collapse collapse" data-bs-parent="#accordionHint1" aria-labelledby="headingHint1">
<div class="accordion-body">
<p>You can use <code>sinfo</code> to find out the node names of your
particular Slurm partition. Then use <code>scontrol</code> to show all
details about a single node from that partition. It will show you the
number of CPU (cores) available on that node.</p>
</div>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1"> Show me the solution </h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" data-bs-parent="#accordionSolution1" aria-labelledby="headingSolution1">
<div class="accordion-body">
<pre class="csv"><code>ntasks,time
1,127.218
2,67.443
4,32.584
8,17.480
16,10.251
32,7.257
64,8.044
128,8.575</code></pre>
<p>Using <code>grep "real" slurm-*.out</code>, we can see the execution
time is halved in the beginning, with each doubling of the CPU cores.
However, somewhere between <span class="math inline">\(8\)</span> and
<span class="math inline">\(16\)</span> cores, we start to see less and
less improvement.</p>
<p>Adding more resources does not help indefinitely. At some point the
overhead of managing the calculation in separate tasks outweighs the
benefit of parallel calculation. There is too little to do in each tasks
and the overhead starts to dominate.</p>
<p>At some point adding more CPU cores does not help us anymore.</p>
</div>
</div>
</div>
</div>
<div id="accordionInstructor3" class="accordion instructor-note accordion-flush">
<div class="accordion-item">
<button class="accordion-button instructor-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseInstructor3" aria-expanded="false" aria-controls="collapseInstructor3">
  <h3 class="accordion-header" id="headingInstructor3">  <div class="note-square"><i aria-hidden="true" class="callout-icon" data-feather="edit-2"></i></div> Todo: show, don’t tell </h3>
</button>
<div id="collapseInstructor3" class="accordion-collapse collapse" data-bs-parent="#accordionInstructor3" aria-labelledby="headingInstructor3">
<div class="accordion-body">
<p>info dump below in this section</p>
<p>Maybe be more specific about which overheads and how we can see
them?</p>
</div>
</div>
</div>
</div>
<p>Adding more CPU cores can actively slow down the calculation after a
certain point. The optimal point is different for each application and
each configuration. It depends on the ratio between calculations,
communications and various management overheads in the whole process of
running everything.</p>
<div id="overheads-and-reliable-measurements" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<span class="callout-header">Callout</span>
<div id="overheads-and-reliable-measurements" class="callout-inner">
<h3 class="callout-title">Overheads and Reliable Measurements</h3>
<div class="callout-content">
<p>Many overheads and when they show also depend on the underlying
hardware. So the sweet spot may very well be different for different
clusters, even if the application and configuration stays the same!</p>
<p>Another common issue lies within our measurements themself. We
perform a single time measurement on a worker node that is possibly
shared with other jobs at the same time. What if another user runs an
application that hogs shared resources like the local disk or network
interface card? In this case our measurements become somewhat
non-deterministic. Running the same measurement twice may result in
significantly different values. If you need reliable results, e.g. for a
publication, requesting exclusive access to Slurms resources through the
<code>sbatch</code> flag <code>--exclusive</code> is the best approach.
As a drawback, this typically results in longer waiting times, since
whole nodes have to be reserved for the measurement jobs, even if not
all resources are used.</p>
<p>Even on exclusive resources, the measurements cannot be 100%
reliable. For example, the scheduling behavior of the Linux kernel, or
access to remote resources like the parallel file system or data from
the web, are still affecting your measurements in unpredictable ways.
Therefore, the best results are achieved by taking the mean and standard
deviations of repeated measurements for the same configuration. The
measured minimum also has strong informative value, since it proofs the
best observed behavior.</p>
<p>Keep in mind, <code>--exclusive</code> will always request all
resources of a given node, even if only few cores are used. In these
cases, tools like <code>seff</code> show worse resource utilization
results, since measurements are done with respect to all booked
resources.</p>
</div>
</div>
</div>
<p>Scaling studies can be done with respect to different application and
job parameters. For example, what is the execution time when we change
the <em>workload</em>, e.g. a larger number of pixels, samples per
pixels, or a more complex scene? How much does a communication overhead
change, if we change the number of involved nodes while keeping the
workload and number of tasks fixed, i.e. changing the <em>network
communication surface</em>? Scaling studies like these can help identify
pressure points that affect the applications performance.</p>
<p>Scaling studies typically occur in a <em>preparation phase</em> where
the application is evaluated with a representative example workload.
Once a good configuration is found, we know the application is running
close to an optimal performance and larger number of calculations can
start, often called the <em>production phase</em>.</p>
<p>In a similar vein, scaling studies can be a formal requirement for
compute time applications on larger HPC systems. On these systems and
for larger calculation campaigns it is more crucial to run efficient
calculations, since the resources are typically more contested and the
potential energy- and carbon footprint becomes much larger.</p>
</section><section><h2 class="section-heading" id="speedup-efficiency-and-strong-scaling">Speedup, Efficiency, and Strong Scaling<a class="anchor" aria-label="anchor" href="#speedup-efficiency-and-strong-scaling"></a>
</h2>
<hr class="half-width">
<p>To quantitatively and empirically study the scaling behavior of a
given application, it is common to look at the <em>speedup</em> and
<em>efficiency</em> with respect to adding more parallel processors.</p>
<p><em>Speedup</em> is a metric to compare the execution times with
different amounts of resources. It answers the question</p>
<blockquote>
<p>How much faster is the application with <span class="math inline">\(N\)</span> parallel processes/threads, compared to
the serial execution with <span class="math inline">\(1\)</span>
process/thread)?</p>
</blockquote>
<p>It is defined by the comparison of wall times <span class="math inline">\(T(N)\)</span> of the application with <span class="math inline">\(N\)</span> parallel processes: <span class="math display">\[S(N) = \frac{T(1)}{T(N)}\]</span> Here, <span class="math inline">\(T(1)\)</span> is the wall time for a sequential
execution, and <span class="math inline">\(T(N)\)</span> is the
execution with <span class="math inline">\(N\)</span> parallel
processes. For <span class="math inline">\(2\)</span> processes, we
observe a speedup of <span class="math inline">\(S(2) =
\frac{127.218}{67.443} \approx 1.89\)</span></p>
<p><em>Efficiency</em> in this context is defined as <span class="math display">\[\eta(N) = \frac{S(N)}{N}\]</span> with speedup
<span class="math inline">\(S(N)\)</span> and describes by how much
additional parallel processes, <span class="math inline">\(N\)</span>,
deviate from the theoretical linear optimum.</p>
<div id="exercise-calculate-speedup-and-efficency" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<span class="callout-header">Challenge</span>
<div id="exercise-calculate-speedup-and-efficency" class="callout-inner">
<h3 class="callout-title">Exercise: Calculate Speedup and Efficency</h3>
<div class="callout-content">
<p>Extend the <code>.csv</code> file of your measurements from above
with a <code>speedup</code> and <code>efficiency</code> column. It may
look like this:</p>
<pre class="csv"><code>ntasks,time,speedup,efficiency
1,127.218,1.00,1.00
2,67.443,1.89,0.94
4,32.584,3.90,0.98
8,17.480,7.28,0.91
...</code></pre>
<p>You may want to use any data visualization tool, e.g. python or
spreadsheets, to visualize the data.</p>
<p>What number of processes may be a good working point for the
raytracer with <span class="math inline">\(800 \times 800\)</span> pixel
and <span class="math inline">\(128\)</span> samples per pixel?</p>
</div>
</div>
</div>
<div id="accordionSolution2" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution2" aria-expanded="false" aria-controls="collapseSolution2">
  <h4 class="accordion-header" id="headingSolution2"> Show me the solution </h4>
</button>
<div id="collapseSolution2" class="accordion-collapse collapse" data-bs-parent="#accordionSolution2" aria-labelledby="headingSolution2">
<div class="accordion-body">
<p>For all of our measurements, the speedup and efficiencies are</p>
<pre class="csv"><code>ntasks,time,speedup,efficiency
1,127.218,1.00,1.00
2,67.443,1.89,0.94
4,32.584,3.90,0.98
8,17.480,7.28,0.91
16,10.251,12.41,0.78
32,7.257,17.53,0.55
64,8.044,15.82,0.25
128,8.575,14.84,0.12</code></pre>
<p>Plotting the speedup and efficiency helps with identifying a good
working point:</p>
<figure><img src="../fig/strong_scaling.png" alt="Speedup and efficiency of strong scaling example" class="figure mx-auto d-block"><div class="figcaption">Speedup and efficiency of strong scaling
example</div>
</figure><p>The 16th processor is still close to 80% efficient. The corresponding
speedup is less than the theoretical optimum, which is visualized by a
red line of slope <span class="math inline">\(1\)</span>.</p>
<p>There is no exact optimum and the best working point is open for
discussion. However, it would be difficult to justify additional cores,
if their contribution to speedup is only 50% efficient or even less.</p>
</div>
</div>
</div>
</div>
<div id="accordionSpoiler1" class="accordion spoiler-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button spoiler-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSpoiler1" aria-expanded="false" aria-controls="collapseSpoiler1">
  <h3 class="accordion-header" id="headingSpoiler1">  <div class="note-square"><i aria-hidden="true" class="callout-icon" data-feather="eye"></i></div> (Optional) plotting our .csvs </h3>
</button>
<div id="collapseSpoiler1" class="accordion-collapse collapse" data-bs-parent="#accordionSpoiler1" aria-labelledby="headingSpoiler1">
<div class="accordion-body">
<p>If you have experience with python, you can use our <a href="../files/plot_scaling_from_csvs.py">python script</a> to create the
same plots as above, but for your own data. It depends on
<code>numpy</code>, <code>pandas</code>, and <code>matplotlib</code>, so
make sure to prepare a corresponding python environment.</p>
<p>The script expects your <code>.csv</code> files to be called
<code>strong.csv</code> and <code>weak.csv</code>, and be placed in the
same directory.</p>
</div>
</div>
</div>
</div>
<p>So far, we kept the workload size fixed to <span class="math inline">\(800 \times 800\)</span> pixels and <span class="math inline">\(128\)</span> samples per pixel for the same scene
with three snowman. The diminishing returns for adding more and more
parallel processors leads to a famous observation. The speedup of a
program through parallelization is limited by the execution time of the
serial fraction that is not parallelizable. No application is 100%
parallelizable, so adding an arbitrary amount of parallel processors can
only affect the parallelizable section. In the best case, the execution
time gets reduced to the serial fraction of the application.</p>
<p>An application is said to <em>scale strongly</em>, if adding more
cores significantly reduces the execution time.</p>
<div id="amdahls-law" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<span class="callout-header">Callout</span>
<div id="amdahls-law" class="callout-inner">
<h3 class="callout-title">Amdahls Law<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>
</h3>
<div class="callout-content">
<p>The speedup of a program through parallelization is limited by the
execution time of the serial fraction that is not parallelizable. For a
given execution time <span class="math inline">\(T(N) = s +
\frac{p}{N}\)</span>, with <span class="math inline">\(s\)</span> the
time for the serial fraction, and <span class="math inline">\(p\)</span>, the time for parallel fraction,
speedup <span class="math inline">\(S\)</span> is defined as <span class="math display">\[S(N) = \frac{s+p}{s+\frac{p}{N}} = \frac{1}{s +
\frac{p}{N}} \Rightarrow \lim_{N\rightarrow \infty}  S(N) =
\frac{1}{s}\]</span></p>
</div>
</div>
</div>
<div id="discussion-when-should-we-stop-adding-cpu-cores" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<span class="callout-header">Discussion</span>
<div id="discussion-when-should-we-stop-adding-cpu-cores" class="callout-inner">
<h3 class="callout-title">Discussion: When should we stop adding CPU
cores?</h3>
<div class="callout-content">
<p>Discuss your previous results and decide on a good working point. How
many cores are still usefully reducing the execution time.</p>
<p>What other factors could affect your decision, e.g. available
hardware and corresponding waiting times.</p>
</div>
</div>
</div>
</section><section><h2 class="section-heading" id="if-scaling-is-limited-why-are-there-larger-hpc-systems-weak-scaling-">If scaling is limited, why are there larger HPC systems? Weak
scaling.<a class="anchor" aria-label="anchor" href="#if-scaling-is-limited-why-are-there-larger-hpc-systems-weak-scaling-"></a>
</h2>
<hr class="half-width">
<p>For a fixed problem size, we observed that adding more parallel
processors can only help up to a certain point. But what if the project
benefits from increasing the workload size? Does a higher resolution,
more accuracy, or more statistics, etc., improve our insights and
results? If that is the case, the perspective on the issue changes and
adding more parallel processors can become more feasible as well. For
our raytracer example, increasing the workload corresponds to more
pixels, more samples per pixel, and/or a more complex scene.</p>
<p><em>Weak scaling</em> refers to the scaling behavior of an
application for a fixed workload per parallel processing unit,
e.g. increasing the number of pixels by the same amount as the number of
parallel processors <span class="math inline">\(N\)</span>.</p>
<div id="gustafsons-law" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<span class="callout-header">Callout</span>
<div id="gustafsons-law" class="callout-inner">
<h3 class="callout-title">Gustafsons Law<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>
</h3>
<div class="callout-content">
<p>A program scales on <span class="math inline">\(N\)</span> parallel
processors, if the problem size also scales with the number of
processors. The speedup <span class="math inline">\(S\)</span> becomes
<span class="math display">\[\text{S(N)} = \frac{s+pN}{s+p} = s+pN =
N+s(1-N)\]</span> with <span class="math inline">\(N\)</span>
processors, <span class="math inline">\(s\)</span> the time for the
serial fraction, and <span class="math inline">\(p\)</span>, the time
for parallel fraction:</p>
</div>
</div>
</div>
<p>To scale the workload of the snowman raytracer, we can increase the
number of calculated pixels with the same factor with which we increase
the number of parallel processors. For one processor we have <span class="math inline">\(800 \times 800 = 640000\)</span> pixel. That means
for two processors we need a height and a width of <span class="math inline">\(\sqrt{2 \times 640000} = 1131.371 \approx
1131\)</span>. And similarly increasing the number of pixels for <span class="math inline">\(--ntasks=4\)</span> and so on.</p>
<p>The job script could look like this:</p>
<div class="codewrapper sourceCode" id="cb8">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a><span class="co">#!/usr/bin/bash</span></span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a><span class="co">#SBATCH --time=01:00:00</span></span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a><span class="co">#SBATCH --nodes=1</span></span>
<span id="cb8-4"><a href="#cb8-4" tabindex="-1"></a><span class="co">#SBATCH --mem-per-cpu=3800MB</span></span>
<span id="cb8-5"><a href="#cb8-5" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" tabindex="-1"></a><span class="ex">module</span> load 2025 GCC/13.2.0 OpenMPI/4.1.6 buildenv/default Boost/1.83.0 CMake/3.27.6 libpng/1.6.40</span>
<span id="cb8-7"><a href="#cb8-7" tabindex="-1"></a></span>
<span id="cb8-8"><a href="#cb8-8" tabindex="-1"></a><span class="co"># Create associative array</span></span>
<span id="cb8-9"><a href="#cb8-9" tabindex="-1"></a><span class="bu">declare</span> <span class="at">-A</span> <span class="va">pixel</span></span>
<span id="cb8-10"><a href="#cb8-10" tabindex="-1"></a><span class="va">pixel</span><span class="op">[</span><span class="dv">1</span><span class="op">]=</span><span class="st">"800"</span></span>
<span id="cb8-11"><a href="#cb8-11" tabindex="-1"></a><span class="va">pixel</span><span class="op">[</span><span class="dv">2</span><span class="op">]=</span><span class="st">"1131"</span></span>
<span id="cb8-12"><a href="#cb8-12" tabindex="-1"></a><span class="va">pixel</span><span class="op">[</span><span class="dv">4</span><span class="op">]=</span><span class="st">"1600"</span></span>
<span id="cb8-13"><a href="#cb8-13" tabindex="-1"></a><span class="va">pixel</span><span class="op">[</span><span class="dv">8</span><span class="op">]=</span><span class="st">"2263"</span></span>
<span id="cb8-14"><a href="#cb8-14" tabindex="-1"></a><span class="va">pixel</span><span class="op">[</span><span class="dv">16</span><span class="op">]=</span><span class="st">"3200"</span></span>
<span id="cb8-15"><a href="#cb8-15" tabindex="-1"></a><span class="va">pixel</span><span class="op">[</span><span class="dv">32</span><span class="op">]=</span><span class="st">"4526"</span></span>
<span id="cb8-16"><a href="#cb8-16" tabindex="-1"></a><span class="va">pixel</span><span class="op">[</span><span class="dv">64</span><span class="op">]=</span><span class="st">"6400"</span></span>
<span id="cb8-17"><a href="#cb8-17" tabindex="-1"></a></span>
<span id="cb8-18"><a href="#cb8-18" tabindex="-1"></a><span class="bu">time</span> mpirun <span class="at">--</span> ./build/raytracer <span class="at">-width</span><span class="op">=</span><span class="va">${pixel</span><span class="op">[</span><span class="va">${SLURM_NTASKS}</span><span class="op">]</span><span class="va">}</span> <span class="at">-height</span><span class="op">=</span><span class="va">${pixel</span><span class="op">[</span><span class="va">${SLURM_NTASKS}</span><span class="op">]</span><span class="va">}</span> <span class="at">-spp</span><span class="op">=</span>128 <span class="at">-threads</span><span class="op">=</span>1 <span class="at">-png</span> <span class="st">"</span><span class="va">$(</span><span class="fu">date</span> +%Y-%m-%d_%H%M%S<span class="va">)</span><span class="st">.png"</span></span></code></pre>
</div>
<div id="accordionSpoiler2" class="accordion spoiler-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button spoiler-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSpoiler2" aria-expanded="false" aria-controls="collapseSpoiler2">
  <h3 class="accordion-header" id="headingSpoiler2">  <div class="note-square"><i aria-hidden="true" class="callout-icon" data-feather="eye"></i></div> Different ways of scaling workloads: spp </h3>
</button>
<div id="collapseSpoiler2" class="accordion-collapse collapse" data-bs-parent="#accordionSpoiler2" aria-labelledby="headingSpoiler2">
<div class="accordion-body">
<p>To scale the workload of the snowman raytracer, we can multiply the
number of parallel MPI processes, <code>${SLURM_NTASKS}</code>, with the
samples per pixel (starting from <code>-spp=128</code>). For a single
process, the whole <span class="math inline">\(800 \times 800\)</span>
pixel picture is calculated in a single MPI process with 128 per pixel.
Running with two MPI processes, both have to calculate half the number
of pixels, but twice the amount of samples per pixel.</p>
<div class="codewrapper sourceCode" id="cb9">
<h3 class="code-label">BASH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode bash" tabindex="0"><code class="sourceCode bash"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a><span class="co">#!/usr/bin/bash</span></span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a><span class="co">#SBATCH --time=01:00:00</span></span>
<span id="cb9-3"><a href="#cb9-3" tabindex="-1"></a><span class="co">#SBATCH --nodes=1</span></span>
<span id="cb9-4"><a href="#cb9-4" tabindex="-1"></a><span class="co">#SBATCH --mem-per-cpu=500MB</span></span>
<span id="cb9-5"><a href="#cb9-5" tabindex="-1"></a></span>
<span id="cb9-6"><a href="#cb9-6" tabindex="-1"></a><span class="ex">module</span> load 2025 GCC/13.2.0 OpenMPI/4.1.6 buildenv/default Boost/1.83.0 CMake/3.27.6 libpng/1.6.40</span>
<span id="cb9-7"><a href="#cb9-7" tabindex="-1"></a></span>
<span id="cb9-8"><a href="#cb9-8" tabindex="-1"></a><span class="va">SPP</span><span class="op">=</span><span class="st">"$[</span><span class="va">${SLURM_NTASKS}</span><span class="st">*128]"</span></span>
<span id="cb9-9"><a href="#cb9-9" tabindex="-1"></a></span>
<span id="cb9-10"><a href="#cb9-10" tabindex="-1"></a><span class="bu">time</span> mpirun <span class="at">--</span> ./build/raytracer <span class="at">-width</span><span class="op">=</span>800 <span class="at">-height</span><span class="op">=</span>800 <span class="at">-spp</span><span class="op">=</span><span class="va">${SPP}</span> <span class="at">-threads</span><span class="op">=</span>1 <span class="at">-png</span> <span class="st">"</span><span class="va">$(</span><span class="fu">date</span> +%Y-%m-%d_%H%M%S<span class="va">)</span><span class="st">.png"</span></span></code></pre>
</div>
<figure><img src="../fig/spp128.png" alt="Three snowmen in 800x800 with 128 samples per pixel" class="figure mx-auto d-block"><div class="figcaption">Three snowmen in 800x800 with 128 samples per
pixel</div>
</figure><figure><img src="../fig/spp8192.png" alt="Three snowmen in 800x800 with 8192 samples per pixel" class="figure mx-auto d-block"><div class="figcaption">Three snowmen in 800x800 with 8192 samples per
pixel</div>
</figure><p>In direct comparison, and zooming in really close, you can see more
noise in the first image, e.g. in the shadows. One could argue that we
passed the point of diminishing returns, though. Is a <span class="math inline">\(64\times\)</span> increase in computational cost
worth the observed quality improvement? For the samples per pixel, we
seem to not benefit much from weak scaling. Larger resolutions, by
increasing the number of pixels, is the more useful dimension to
increase in this case.</p>
</div>
</div>
</div>
</div>
<p>Increasing the resolution may be worth the effort, if we have a use
for a larger, more detailed picture. In practice, there is a cutoff,
beyond which no reasonable improvement is to be expected. This is a
question about accuracy, error margins, and overall quality, which can
only be answered in the specific context of each research project. If
there is no real improvement by increasing the workload, running a
weakly scaling application is really just wasting valuable computational
time and energy.</p>
<p>If we increase the workload at the rate as our number of parallel
processes (<span class="math inline">\(N\)</span>) our speedup is
defined as <span class="math display">\[S_{\text{weak}}(N) =
\frac{T(1)}{T(N)} \times N\]</span> since we do <span class="math inline">\(N\)</span> times more work with <span class="math inline">\(N\)</span> processors, compared to our reference
<span class="math inline">\(T(N=1)\)</span>. Efficiency is still defined
as <span class="math display">\[\eta_{\text{weak}}(N) =
\frac{S_{\text{weak}}(N)}{N} = \frac{T(1)}{T(N)}\]</span></p>
<div id="exercise-weak-scaling" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<span class="callout-header">Challenge</span>
<div id="exercise-weak-scaling" class="callout-inner">
<h3 class="callout-title">Exercise: Weak scaling</h3>
<div class="callout-content">
<p>Repeat the previous scaling study and increase the number of pixels
accordingly to study the raytracers weak scaling behavior.</p>
<ul>
<li>Run with 1, 2, 4, 8, 16, 32, 64 MPI processes on single node</li>
<li>Take <code>time</code> measurements and consider running with
<code>--exclusive</code> to ensure more reliable results.</li>
<li>Create a <code>.csv</code> file and run the plotting script</li>
</ul>
<pre class="csv"><code>ntasks,pixel,time,speedup,efficiency
1,800,123.162
2,1131,122.562
4,1600,124.522
8,2263,125.606
...</code></pre>
<p>How well does the application scale with an increasing workload size?
Do you see a qualitative difference in the resulting <code>.png</code>
files and is the increased sample-per-pixel size worth the computational
costs?</p>
</div>
</div>
</div>
<div id="accordionSolution3" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution3" aria-expanded="false" aria-controls="collapseSolution3">
  <h4 class="accordion-header" id="headingSolution3"> Show me the solution </h4>
</button>
<div id="collapseSolution3" class="accordion-collapse collapse" data-bs-parent="#accordionSolution3" aria-labelledby="headingSolution3">
<div class="accordion-body">
<pre class="csv"><code>ntasks,pixel,time,speedup,efficiency
1,800,123.162
2,1131,122.562
4,1600,124.522
8,2263,125.606
16,3200,125.803
32,4526,130.137
64,6400,138.636</code></pre>
<p>The scaling behavior is reaching an asymptotic limit, where each
additional processor is contributing with the same efficiency to the
increased workload.</p>
<figure><img src="../fig/weak_scaling.png" alt="Speedup and efficiency of weak scaling example" class="figure mx-auto d-block"><div class="figcaption">Speedup and efficiency of weak scaling
example</div>
</figure><p>Weakly scaling jobs can make efficient use of a huge amount of
resources.</p>
<p>The most important question is, if an increased workload is producing
useful results. Here, we have the rendered picture of <a href="../fig/pixel800.png">three snowmen in 800x800 with 128 samples per
pixel</a> and <a href="../fig/pixel6400.png">three snowmen in 6400x6400
with 128 samples per pixel</a>. The second image has a much higher
resolution. However, going way beyond <span class="math inline">\(6400
\times 6400\)</span> pixels is probably not very meaningful, unless you
are trying to print the worlds largest ad boards or similar.</p>
</div>
</div>
</div>
</div>
</section><section><h2 class="section-heading" id="summary">Summary<a class="anchor" aria-label="anchor" href="#summary"></a>
</h2>
<hr class="half-width">
<p>In this episode, we have seen that we can study the <em>scaling</em>
behavior of our application with respect to different metrics, while
varying its configuration. Most commonly, we study the execution time of
an application with an increasing number of parallel processors. In such
a scaling study, we collect comparable walltime measurements for an
increasing number of Slurm tasks of a parallelizable and representative
job. If a good working point is found, larger scale “production” jobs
can be submitted to the HPC system.</p>
<p>If the application has good <em>strong scaling</em> behavior, adding
more cores leads to an effective improvement in execution time. We
observe diminishing returns of adding more cores to a fixed-size
problem, so there is a (subjective) optimal number of parallel
processors for a given application configuration. (Amdahls Law)</p>
<p>If increasing the workload size leads to better results, maybe
because of improved accuracy and quality, we can study the <em>weak
scaling</em> behavior and increase the workload size by the same factor
of increasing parallel processors.</p>
<p>A good working point depends on the availability of resources,
specifics of the underlying hardware, the particular application, and a
particular configuration for the application. For that reason, scaling
studies are a common requirement for formal compute time applications to
prove an efficient execution of a given application.</p>
<p>We can study the impact of any parameter on metrics like, for
example, walltime, CPU utilization, FLOPS, memory utilization,
communication, output size on disk, and so on.</p>
<div id="accordionSpoiler3" class="accordion spoiler-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button spoiler-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSpoiler3" aria-expanded="false" aria-controls="collapseSpoiler3">
  <h3 class="accordion-header" id="headingSpoiler3">  <div class="note-square"><i aria-hidden="true" class="callout-icon" data-feather="eye"></i></div> Automating Scaling Studies </h3>
</button>
<div id="collapseSpoiler3" class="accordion-collapse collapse" data-bs-parent="#accordionSpoiler3" aria-labelledby="headingSpoiler3">
<div class="accordion-body">
<p>If you find yourself repeating similar measurements over and over
again, you may be interested in an automation approach. This can be done
by creating <a href="https://carpentries-incubator.github.io/hpc-workflows-jube/" class="external-link">reproducible
HPC workflows using JUBE</a>, among other things.</p>
</div>
</div>
</div>
</div>
<p>Up to now, we were still working with basic metrics like the
wall-clock time. In the next episode, we start with more in-depth
measurements of many other aspects of our job and application.</p>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<span class="callout-header">Key Points</span>
<div class="callout-inner">
<div class="callout-content">
<ul>
<li>Jobs behave differently with increasing parallel resources and fixed
or scaling workloads</li>
<li>Scaling studies can help to quantitatively grasp this changing
behavior</li>
<li>Good working points are defined by configurations where more cores
still provide sufficient speedup or improve quality through increasing
workloads</li>
<li>Amdahl’s law: speedup is limited by the serial fraction of a
program</li>
<li>Gustafson’s law: more resources for parallel processing still help,
if larger workloads can meaningfully contribute to project results</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</section><div class="footnotes footnotes-end-of-document">
<hr>
<ol>
<li id="fn1"><p>G. M. Amdahl, ‘Validity of the single processor approach
to achieving large scale computing capabilities’, in Proceedings of the
April 18-20, 1967, spring joint computer conference, in AFIPS ’67
(Spring). New York, NY, USA: Association for Computing Machinery,
Apr. 1967, pp. 483–485. doi: 10.1145/1465482.1465560.<a href="#fnref1" class="footnote-back">↩︎</a></p></li>
<li id="fn2"><p>J. L. Gustafson, ‘Reevaluating Amdahl’s law’, Commun.
ACM, vol. 31, no. 5, pp. 532–533, May 1988, doi: 10.1145/42411.42415.<a href="#fnref2" class="footnote-back">↩︎</a></p></li>
</ol>
</div></section><section id="aio-05_performancereports"><p>Content from <a href="05_performancereports.html">Performance Overview</a></p>
<hr>
<p>Last updated on 2025-11-11 |

        <a href="https://github.com/stderr-enst/jobefficiency/edit/main/episodes/05_performancereports.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 10 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>Is it enough to look at a jobs walltime?</li>
<li>What steps can I take to evaluate a jobs performance?</li>
<li>What popular types of reports exist?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<p>After completing this episode, participants should be able to …</p>
<ul>
<li>Explain different approaches to performance measurements.</li>
<li>Understand common terms and concepts in performance analyses.</li>
<li>Create a performance report through a third-party tool.</li>
<li>Describe what a performance report is meant for (establish baseline,
documentation of issues and improvements through optimization,
publication of results, finding the next thread to pull in a quest for
optimization)</li>
<li>Measure the performance of central components of underlying hardware
(CPU, Memory, I/O, …) (split episode?)</li>
<li>Identify which general areas of computer hardware may affect
performance.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="accordionInstructor1" class="accordion instructor-note accordion-flush">
<div class="accordion-item">
<button class="accordion-button instructor-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseInstructor1" aria-expanded="false" aria-controls="collapseInstructor1">
  <h3 class="accordion-header" id="headingInstructor1">  <div class="note-square"><i aria-hidden="true" class="callout-icon" data-feather="edit-2"></i></div> Intention: Introduce third party tools for performance reports </h3>
</button>
<div id="collapseInstructor1" class="accordion-collapse collapse" data-bs-parent="#accordionInstructor1" aria-labelledby="headingInstructor1">
<div class="accordion-body">
<p>Narrative:</p>
<ul>
<li>Scaling study, scheduler tools, project proposal is written and
handed in</li>
<li>Maybe I can squeeze out more from my current system by trying to
understand better how it behaves</li>
<li>Another colleague told us about performance measurement tools</li>
<li>We are learning more about our application</li>
<li>Aha, there IS room to optimize! Compile with vectorization</li>
</ul>
<p>What we’re doing here:</p>
<ul>
<li>Get a complete picture</li>
<li>Introduce missing metrics / definitions, and popular representations
of data, e.g. Roofline</li>
<li>Relate to hardware on the same level of detail</li>
</ul>
</div>
</div>
</div>
</div>
<section><h2 class="section-heading" id="workflow">Workflow<a class="anchor" aria-label="anchor" href="#workflow"></a>
</h2>
<hr class="half-width">
<ul>
<li>Previously checked scaling behavior by looking at walltime</li>
<li>what if we would count other things while our job is running? Could
be
<ul>
<li>CPU utilization</li>
<li>FLOPS</li>
<li>Memory uitilization</li>
<li>…</li>
</ul>
</li>
<li>Two possible ways to look at this data with respect to time:
<ol style="list-style-type: decimal">
<li>
<em>tracing</em>: over time</li>
<li>
<em>sampling</em>: accumulated results at the end</li>
</ol>
</li>
<li>Third-party tools to measure these things - you can use them with
your jobs</li>
</ul>
<div id="accordionInstructor2" class="accordion instructor-note accordion-flush">
<div class="accordion-item">
<button class="accordion-button instructor-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseInstructor2" aria-expanded="false" aria-controls="collapseInstructor2">
  <h3 class="accordion-header" id="headingInstructor2">  <div class="note-square"><i aria-hidden="true" class="callout-icon" data-feather="edit-2"></i></div> Pick a main tool </h3>
</button>
<div id="collapseInstructor2" class="accordion-collapse collapse" data-bs-parent="#accordionInstructor2" aria-labelledby="headingInstructor2">
<div class="accordion-body">
<p>We go with three alternatives here, pick one an stick to it
throughout your course, but highlight that there are alternatives and
learners may not have access to certain tools on any cluster.</p>
</div>
</div>
</div>
</div>
<div id="callout1" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<span class="callout-header">Callout</span>
<div class="callout-inner">
<div class="callout-content">
<p>Here you can choose between three alternative perspectives on our
job:</p>
<ol style="list-style-type: decimal">
<li>
<a href="https://clustercockpit.org/" class="external-link"><em>ClusterCockpit</em></a>: A
job monitoring service available on many of our clusters. Needs to be
centrally maintained by your HPC administration team.</li>
<li>
<a href="https://docs.linaroforge.com/25.0.4/html/forge/performance_reports/index.html" class="external-link"><em>Linaro
Forge Performance Reports</em></a>: A commercial application providing a
single page performance overview of your job. Your cluster may have
licenses available.</li>
<li>
<em>TBD</em>: A free, open source tool/set of tools, to get a
general performance overview of your job.</li>
</ol>
<p>Performance counters and permissions, may require
<code>--exclusive</code>, depends on system! Look at documentation /
talk to your administrators / support.</p>
<pre><code>cap_perfmon,cap_sys_ptrace,cap_syslog=ep
kernel.perf_event_paranoid</code></pre>
</div>
</div>
</div>
<p>Live coding:</p>
<ul>
<li>Set up the main tool. How do I access it? How can I use it with my
job?</li>
<li>Run snowman with 8 cores</li>
</ul>
<div class="tabs">
<nav><div id="nav-tab-1" class="nav nav-tabs" role="tablist">
<button class="nav-link active" id="nav-tab-1-ClusterCockpit" name="ClusterCockpit" data-bs-toggle="tab" data-bs-target="#nav-tabpanel-1-ClusterCockpit" type="button" role="tab" aria-controls="nav-tabpanel-1-ClusterCockpit" aria-selected="true">
  <h3 class="tab-header" id="nav-tab-heading-1-ClusterCockpit">
  ClusterCockpit
  </h3>
</button>
<button class="nav-link" id="nav-tab-1-PerformanceReports" name="PerformanceReports" data-bs-toggle="tab" data-bs-target="#nav-tabpanel-1-PerformanceReports" type="button" role="tab" aria-controls="nav-tabpanel-1-PerformanceReports" aria-selected="false">
  <h3 class="tab-header" id="nav-tab-heading-1-PerformanceReports">
  Performance Reports
  </h3>
</button>
<button class="nav-link" id="nav-tab-1-TBD" name="TBD" data-bs-toggle="tab" data-bs-target="#nav-tabpanel-1-TBD" type="button" role="tab" aria-controls="nav-tabpanel-1-TBD" aria-selected="false">
  <h3 class="tab-header" id="nav-tab-heading-1-TBD">
  TBD
  </h3>
</button>
</div>
</nav><div id="nav-tabContent-1" class="tab-content">
<div id="nav-tabpanel-1-ClusterCockpit" class="tab-pane show active" role="tabpanel" aria-labelledby="nav-tab-1-ClusterCockpit">
<ol style="list-style-type: decimal">
<li>Setup: webpage &amp; login. An conditions on when it is enabled in
your particular cluster?</li>
<li>If always enabled: figure out jobid of previous 8-core job from
Episode 4</li>
</ol>
</div>
<div id="nav-tabpanel-1-PerformanceReports" class="tab-pane" role="tabpanel" aria-labelledby="nav-tab-1-PerformanceReports">
<ol style="list-style-type: decimal">
<li>(Check for licenses?)</li>
<li>Setup: load software modules</li>
<li>Submit job with <code>perf-report</code>
</li>
</ol>
</div>
<div id="nav-tabpanel-1-TBD" class="tab-pane" role="tabpanel" aria-labelledby="nav-tab-1-TBD">
<p>N/A</p>
</div>
</div>
</div>
</section><section><h2 class="section-heading" id="general-report">General report<a class="anchor" aria-label="anchor" href="#general-report"></a>
</h2>
<hr class="half-width">
<div class="tabs">
<nav><div id="nav-tab-2" class="nav nav-tabs" role="tablist">
<button class="nav-link active" id="nav-tab-2-ClusterCockpit" name="ClusterCockpit" data-bs-toggle="tab" data-bs-target="#nav-tabpanel-2-ClusterCockpit" type="button" role="tab" aria-controls="nav-tabpanel-2-ClusterCockpit" aria-selected="true">
  <h3 class="tab-header" id="nav-tab-heading-2-ClusterCockpit">
  ClusterCockpit
  </h3>
</button>
<button class="nav-link" id="nav-tab-2-PerformanceReports" name="PerformanceReports" data-bs-toggle="tab" data-bs-target="#nav-tabpanel-2-PerformanceReports" type="button" role="tab" aria-controls="nav-tabpanel-2-PerformanceReports" aria-selected="false">
  <h3 class="tab-header" id="nav-tab-heading-2-PerformanceReports">
  Performance Reports
  </h3>
</button>
<button class="nav-link" id="nav-tab-2-TBD" name="TBD" data-bs-toggle="tab" data-bs-target="#nav-tabpanel-2-TBD" type="button" role="tab" aria-controls="nav-tabpanel-2-TBD" aria-selected="false">
  <h3 class="tab-header" id="nav-tab-heading-2-TBD">
  TBD
  </h3>
</button>
</div>
</nav><div id="nav-tabContent-2" class="tab-content">
<div id="nav-tabpanel-2-ClusterCockpit" class="tab-pane show active" role="tabpanel" aria-labelledby="nav-tab-2-ClusterCockpit">
<ul>
<li>Job meta data</li>
<li>Footprint</li>
<li>Roofline plot</li>
<li>Detailed plots</li>
<li>Tabled statistics</li>
</ul>
<ol style="list-style-type: decimal">
<li>Go to webpage</li>
<li>Navigate to the job</li>
<li>Discuss overall info on a broad level
<ul>
<li>Job meta data</li>
<li>Footprint</li>
<li>Roofline plot</li>
<li>Detailed plots</li>
<li>Tabled statistics</li>
</ul>
</li>
</ol>
</div>
<div id="nav-tabpanel-2-PerformanceReports" class="tab-pane" role="tabpanel" aria-labelledby="nav-tab-2-PerformanceReports">
<ul>
<li>Computing</li>
<li>Memory</li>
<li>Communication</li>
<li>…</li>
</ul>
<ol style="list-style-type: decimal">
<li>Identify result files (txt, html)</li>
<li>Look at txt with editor</li>
<li>Copy html to local computer &amp; open it with browser</li>
<li>Discuss report on a broad level
<ul>
<li>Computing</li>
<li>Memory</li>
<li>Communication</li>
<li>…</li>
</ul>
</li>
</ol>
</div>
<div id="nav-tabpanel-2-TBD" class="tab-pane" role="tabpanel" aria-labelledby="nav-tab-2-TBD">
<p>N/A</p>
</div>
</div>
</div>
</section><section><h2 class="section-heading" id="how-does-performance-relate-to-hardware">How Does Performance Relate to Hardware?<a class="anchor" aria-label="anchor" href="#how-does-performance-relate-to-hardware"></a>
</h2>
<hr class="half-width">
<div id="accordionInstructor3" class="accordion instructor-note accordion-flush">
<div class="accordion-item">
<button class="accordion-button instructor-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseInstructor3" aria-expanded="false" aria-controls="collapseInstructor3">
  <h3 class="accordion-header" id="headingInstructor3">  <div class="note-square"><i aria-hidden="true" class="callout-icon" data-feather="edit-2"></i></div> ToDo: Connect Hardware to Performance Measurements </h3>
</button>
<div id="collapseInstructor3" class="accordion-collapse collapse" data-bs-parent="#accordionInstructor3" aria-labelledby="headingInstructor3">
<div class="accordion-body">
<p>Introduce hardware on the same level of detail and with the same
terms as the performance reports by ClusterCockpit, LinaroForge, etc.,
as soon as they appear. Only introduce what we need, to avoid info dump.
But point to additional information that gives a complete overview -&gt;
hpc-wiki!</p>
</div>
</div>
</div>
</div>
<p>(Following this structure throughout the course, trying to understand
the performance in these terms)</p>
<p>Broad dimensions of performance:</p>
<ul>
<li>CPU (Front- and Backend, FLOPS)
<ul>
<li>Frontend: decoding instructions, branch prediction, pipeline</li>
<li>Backend: getting data from memory, cache hierarchy &amp;
alignment</li>
<li>Raw calculations</li>
<li>Vectorization</li>
<li>Out-of-order execution</li>
</ul>
</li>
<li>Accelerators (e.g. GPUs)
<ul>
<li>More calculations</li>
<li>Offloading</li>
<li>Memory &amp; communication models</li>
</ul>
</li>
<li>Memory (data hierarchy)
<ul>
<li>Working memory, reading data from/to disk</li>
<li>Bandwidth of data</li>
</ul>
</li>
<li>I/O (broader data hierarchy: disk, network)
<ul>
<li>Stored data</li>
<li>Local disk (caching)</li>
<li>Parallel fs (cluster-wide)</li>
<li>MPI-Communiction</li>
</ul>
</li>
<li>Parallel timeline (synchronization, etc.)
<ul>
<li>Application logic</li>
</ul>
</li>
</ul>
<div id="accordionInstructor4" class="accordion instructor-note accordion-flush">
<div class="accordion-item">
<button class="accordion-button instructor-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseInstructor4" aria-expanded="false" aria-controls="collapseInstructor4">
  <h3 class="accordion-header" id="headingInstructor4">  <div class="note-square"><i aria-hidden="true" class="callout-icon" data-feather="edit-2"></i></div> ToDo: Clarify relation to hardware in this course </h3>
</button>
<div id="collapseInstructor4" class="accordion-collapse collapse" data-bs-parent="#accordionInstructor4" aria-labelledby="headingInstructor4">
<div class="accordion-body">
<p>Maybe we should either focus on components (CPUs, memory, disk,
accelerators, network cards) or functional entities (compute, data
hierarchy, bandwidth, latency, parallel timelines)</p>
<p>We shouldn’t go into too much detail here. Define broad categories
where performance can be good or bad. (calculations, data transfers,
application logic, research objective (is the calculation
meaningful?))</p>
<p>Reuse categories in the same order and fashion throughout the course,
i.e. point out in what area a discovered inefficiency occurs.</p>
<p>Introduce detail about hardware later where it is needed, e.g. NUMA
for pinning and hints.</p>
</div>
</div>
</div>
</div>
<figure><img src="../fig/JobEfficiency.drawio.png" alt="Hardware" class="figure mx-auto d-block"><div class="figcaption">Hardware</div>
</figure><div id="exercise-match-application-behavior-to-hardware" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<span class="callout-header">Challenge</span>
<div id="exercise-match-application-behavior-to-hardware" class="callout-inner">
<h3 class="callout-title">Exercise: Match application behavior to
hardware</h3>
<div class="callout-content">
<p>Which part of the computer hardware may become an issue for the
following application patterns:</p>
<ol style="list-style-type: decimal">
<li>Calculating matrix multiplications</li>
<li>Reading data from processes on other computers</li>
<li>Calling many different functions from many equally likely if/else
branches</li>
<li>Writing very large files (TB)</li>
<li>Comparing many different strings if they match</li>
<li>Constructing a large simulation model</li>
<li>Reading thousands of small files for each iteration</li>
</ol>
<p>Maybe not the best questions, also missing something for
accelerators.</p>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1"> Show me the solution </h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" data-bs-parent="#accordionSolution1" aria-labelledby="headingSolution1">
<div class="accordion-body">
<ol style="list-style-type: decimal">
<li>CPU (FLOPS) and/or Parallel timeline</li>
<li>I/O (network)</li>
<li>CPU (Front-End)</li>
<li>I/O (disk)</li>
<li>(?) CPU-Backend, getting strings through the cache?</li>
<li>Memory (size)</li>
<li>I/O (disk)</li>
</ol>
</div>
</div>
</div>
</div>
</section><section><h2 class="section-heading" id="summary">Summary<a class="anchor" aria-label="anchor" href="#summary"></a>
</h2>
<hr class="half-width">
<ul>
<li>General reports show direction in which to continue
<ul>
<li>Specialized tools may be necessary to move on</li>
</ul>
</li>
</ul>
<p>Leading question: Connection to hardware is quite deep, why does it
matter? -&gt; Drill deeper, e.g. on NUMA &amp; pinning</p>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<span class="callout-header">Key Points</span>
<div class="callout-inner">
<div class="callout-content">
<ul>
<li>First things first, second things second, …</li>
<li>Profiling, tracing</li>
<li>Sampling, summation</li>
<li>Different HPC centers may provide different approaches to this
workflow</li>
<li>Performance reports offer more insight into the job and application
behavior</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</section></section><section id="aio-06_pinning"><p>Content from <a href="06_pinning.html">Pinning</a></p>
<hr>
<p>Last updated on 2025-10-31 |

        <a href="https://github.com/stderr-enst/jobefficiency/edit/main/episodes/06_pinning.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 10 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>What is “pinning” of job resources?</li>
<li>How can pinning improve the performance?</li>
<li>How can I see, if pinning resources would help?</li>
<li>What requirement hints can I give to the scheduler?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<p>After completing this episode, participants should be able to …</p>
<ul>
<li>Define the concept of “pinning” and how it can affect job
performance.</li>
<li>Name Slurms options for memory- and cpu- binding.</li>
<li>Use hints to tell Slurm how to optimize their job allocation.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="accordionInstructor1" class="accordion instructor-note accordion-flush">
<div class="accordion-item">
<button class="accordion-button instructor-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseInstructor1" aria-expanded="false" aria-controls="collapseInstructor1">
  <h3 class="accordion-header" id="headingInstructor1">  <div class="note-square"><i aria-hidden="true" class="callout-icon" data-feather="edit-2"></i></div> Intention: Go deeper in performance and hardware relationship </h3>
</button>
<div id="collapseInstructor1" class="accordion-collapse collapse" data-bs-parent="#accordionInstructor1" aria-labelledby="headingInstructor1">
<div class="accordion-body">
<p>Narrative:</p>
<ul>
<li>We get the feeling, that hardware has a lot to offer, but the rabbit
hole is deep!</li>
<li>What are the “dimensions” in which we can optimize the throughput of
snowman pictures per hour?</li>
<li>Can we improve how the work maps to certain CPUs / Memory
regions?</li>
</ul>
<p>What we’re doing here:</p>
<ul>
<li>Introduce pinning and slurm hint options</li>
<li>Relate to hardware effects</li>
<li>Use third party performance tools to observe effects!</li>
</ul>
</div>
</div>
</div>
</div>
<div id="accordionInstructor2" class="accordion instructor-note accordion-flush">
<div class="accordion-item">
<button class="accordion-button instructor-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseInstructor2" aria-expanded="false" aria-controls="collapseInstructor2">
  <h3 class="accordion-header" id="headingInstructor2">  <div class="note-square"><i aria-hidden="true" class="callout-icon" data-feather="edit-2"></i></div> ToDo: Extract episode about pinning </h3>
</button>
<div id="collapseInstructor2" class="accordion-collapse collapse" data-bs-parent="#accordionInstructor2" aria-labelledby="headingInstructor2">
<div class="accordion-body">
<p>Stick to simple options here. Put more complex options for pinning /
hints, etc. into its own episode somewhere later in the course</p>
<p>Pinning is an important part of job optimization, but requires some
knowledge, e.g. about the hardware hierarchies in a cluster, NUMA, etc.
So it should be done after we’ve introduced different performance
reports and their perspective on hardware</p>
<p>Maybe point to <a href="https://apps.fz-juelich.de/jsc/llview/pinning" class="external-link">JSC pinning
simulator</a> and have similar diagrams as an independent “offline”
version in this course</p>
</div>
</div>
</div>
</div>
<p>Binding / pinning:</p>
<ul>
<li><code>--mem-bind=[{quiet|verbose},]&lt;type&gt;</code></li>
<li><code>-m, --distribution={*|block|cyclic|arbitrary|plane=&lt;size&gt;}[:{*|block|cyclic|fcyclic}[:{*|block|cyclic|fcyclic}]][,{Pack|NoPack}]</code></li>
<li>
<code>--hint=</code>: Hints for CPU- (<code>compute_bound</code>)
and memory-bound (<code>memory_bound</code>), but also
<code>multithread</code>, <code>nomultithread</code>
</li>
<li>
<code>--cpu-bind=[{quiet|verbose},]&lt;type&gt;</code>
(<code>srun</code>)</li>
<li>Mapping of application &lt;-&gt; job resources</li>
</ul>
<section><h2 class="section-heading" id="motivation">Motivation<a class="anchor" aria-label="anchor" href="#motivation"></a>
</h2>
<hr class="half-width">
<div id="exercise" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<span class="callout-header">Challenge</span>
<div id="exercise" class="callout-inner">
<h3 class="callout-title">Exercise</h3>
<div class="callout-content">
<p>Case 1: 1 thread per rank
<code>mpirun -n 8 ./raytracer -width=512 -height=512 -spp=128 -threads=1 -alloc_mode=3 -png=snowman.png</code></p>
<p>Case 2: 2 thread per rank
<code>mpirun -n 8 ./raytracer -width=512 -height=512 -spp=128 -threads=2 -alloc_mode=3 -png=snowman.png</code></p>
<p>Questions: - Do you notice any difference in runtime between the two
cases? - Is the increase in threads providing a speedup as expected?</p>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1"> Show me the solution </h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" data-bs-parent="#accordionSolution1" aria-labelledby="headingSolution1">
<div class="accordion-body">
<ul>
<li>Observation: The computation times are almost the same.</li>
<li>Expected behavior: Increasing threads should ideally reduce
runtime.</li>
<li>Hypothesis: Additional threads do not contribute.</li>
</ul>
</div>
</div>
</div>
</div>
</section><section><h2 class="section-heading" id="how-to-investigate">How to investigate?<a class="anchor" aria-label="anchor" href="#how-to-investigate"></a>
</h2>
<hr class="half-width">
<p>You can verify the actual core usage in two ways: 1. Use
<code>--report-bindings</code> with <code>mpirun</code> 2. Use
<code>htop</code>command on the compute node</p>
<div id="accordionInstructor3" class="accordion instructor-note accordion-flush">
<div class="accordion-item">
<button class="accordion-button instructor-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseInstructor3" aria-expanded="false" aria-controls="collapseInstructor3">
  <h3 class="accordion-header" id="headingInstructor3">  <div class="note-square"><i aria-hidden="true" class="callout-icon" data-feather="edit-2"></i></div> Note: Login to the compute job </h3>
</button>
<div id="collapseInstructor3" class="accordion-collapse collapse" data-bs-parent="#accordionInstructor3" aria-labelledby="headingInstructor3">
<div class="accordion-body">
<p>This is cluster specific. It can possibly be done in two ways: 1.
<code>srun --pty --overlap --jobid=&lt;jobid&gt; /bin/bash</code> 2.
Check on which node job runs and login to the node via SSH</p>
</div>
</div>
</div>
</div>
<div id="exercise-1" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<span class="callout-header">Challenge</span>
<div id="exercise-1" class="callout-inner">
<h3 class="callout-title">Exercise</h3>
<div class="callout-content">
<p>Follow any one of the option above and run for 2 threads per rank
<code>mpirun -n 8 ./raytracer -width=512 -height=512 -spp=128 -threads=2 -alloc_mode=3 -png=snowman.png</code></p>
<p>Questions: - Did you find any justification for the hypothesis we
made?</p>
</div>
</div>
</div>
<div id="accordionSolution2" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution2" aria-expanded="false" aria-controls="collapseSolution2">
  <h4 class="accordion-header" id="headingSolution2"> Show me the solution </h4>
</button>
<div id="collapseSolution2" class="accordion-collapse collapse" data-bs-parent="#accordionSolution2" aria-labelledby="headingSolution2">
<div class="accordion-body">
<p>Only 8 cores are active instead of 16</p>
</div>
</div>
</div>
</div>
<p>Explanation:</p>
<ul>
<li>Eventhough we requested 2 threads per MPI rank, both threads are
pinned to the same core.</li>
<li>The second thread waits for the first thread to finish, so no actual
thread-level parallelization is achieved.</li>
</ul>
<div id="accordionInstructor4" class="accordion instructor-note accordion-flush">
<div class="accordion-item">
<button class="accordion-button instructor-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseInstructor4" aria-expanded="false" aria-controls="collapseInstructor4">
  <h3 class="accordion-header" id="headingInstructor4">  <div class="note-square"><i aria-hidden="true" class="callout-icon" data-feather="edit-2"></i></div> TODO: Show an animation </h3>
</button>
<div id="collapseInstructor4" class="accordion-collapse collapse" data-bs-parent="#accordionInstructor4" aria-labelledby="headingInstructor4">
<div class="accordion-body">
<ul>
<li>current behavior with overlapping threads on the same core.</li>
<li>Expected behavior when threads are pinned to separate cores.</li>
</ul>
</div>
</div>
</div>
</div>
</section><section><h2 class="section-heading" id="how-to-achieve">How to achieve?<a class="anchor" aria-label="anchor" href="#how-to-achieve"></a>
</h2>
<hr class="half-width"></section><section><h2 class="section-heading" id="exercise-understanding-process-and-thread-binding">Exercise: Understanding Process and Thread Binding<a class="anchor" aria-label="anchor" href="#exercise-understanding-process-and-thread-binding"></a>
</h2>
<hr class="half-width">
<p>Pinning (or binding) means locking a process or thread to a specific
hardware resource such as a CPU core, socket, or NUMA region. Without
pinning, the operating system may move tasks between cores, which can
reduce cache reuse and increase memory latency, directly diminishes
performance.</p>
<p>In this exercise we will explore how MPI process and thread binding
works. We will try binding to <strong>core</strong>,
<strong>socket</strong>, and <strong>numa</strong>, and observe timings
and bindings.</p>
<div id="accordionInstructor5" class="accordion instructor-note accordion-flush">
<div class="accordion-item">
<button class="accordion-button instructor-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseInstructor5" aria-expanded="false" aria-controls="collapseInstructor5">
  <h3 class="accordion-header" id="headingInstructor5">  <div class="note-square"><i aria-hidden="true" class="callout-icon" data-feather="edit-2"></i></div> Note </h3>
</button>
<div id="collapseInstructor5" class="accordion-collapse collapse" data-bs-parent="#accordionInstructor5" aria-labelledby="headingInstructor5">
<div class="accordion-body">
<ul>
<li>This exercise assumes the following hardware setup:
<ul>
<li>Dual-socket system (2 sockets, 48 cores per socket, 8 NUMA regions,
96 cores total).<br>
</li>
<li>Each MPI process can use multiple threads (<code>-threads</code>)
for parallel execution.</li>
</ul>
</li>
<li>The idea is to <strong>demonstrate oversubscription</strong> by
giving more MPI processes than available sockets or NUMA regions, or by
over-allocating threads per domain.<br>
</li>
<li>You are free to adjust <code>-n</code> and <code>-threads</code>
based on your cluster.</li>
</ul>
</div>
</div>
</div>
</div>
<div id="exercise-2" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<span class="callout-header">Challenge</span>
<div id="exercise-2" class="callout-inner">
<h3 class="callout-title">Exercise</h3>
<div class="callout-content">
<p>Case 1: <code>--bind-to numa</code>
<code>mpirun -n 8 --bind-to numa ./raytracer -width=512 -height=512 -spp=128 -threads=12 -alloc_mode=3 -png=snowman.png</code></p>
<p>Case 2: <code>--bind-to socket</code>
<code>mpirun -n 4 --bind-to socket /raytracer -width=512 -height=512 -spp=128 -threads=48 -alloc_mode=3 -png=snowman.png</code></p>
<p>Questions: - What is difference between Case 1 and Case 2. Any
difference in performance? How many workers? - How could you adjust
process/thread counts to better utilize the hardware in Case 2?</p>
</div>
</div>
</div>
<div id="accordionSolution3" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution3" aria-expanded="false" aria-controls="collapseSolution3">
  <h4 class="accordion-header" id="headingSolution3"> Show me the solution </h4>
</button>
<div id="collapseSolution3" class="accordion-collapse collapse" data-bs-parent="#accordionSolution3" aria-labelledby="headingSolution3">
<div class="accordion-body">
<ul>
<li>MPI and thread pinning is hardware-aware.</li>
<li>If the number of processes matches the number of domains (socket or
NUMA), then the number of threads should equal the cores per domain to
fully utilize the node.</li>
<li>No speedup in Case 2: Oversubscription occurs because we requested 4
processes on a system with only 2 sockets.</li>
<li>Threads compete for the same cores → OpenMPI queues threads and
waits until other processes finish.</li>
</ul>
</div>
</div>
</div>
</div>
</section><section><h2 class="section-heading" id="best-practices-for-mpi-process-and-thread-pinning">Best Practices for MPI Process and Thread Pinning<a class="anchor" aria-label="anchor" href="#best-practices-for-mpi-process-and-thread-pinning"></a>
</h2>
<hr class="half-width">
<div class="section level3">
<h3 id="difference-between-binding-and-mapping">Difference between Binding and Mapping<a class="anchor" aria-label="anchor" href="#difference-between-binding-and-mapping"></a>
</h3>
<p><strong>Mapping</strong> is about distributing MPI ranks across
hardware hierarchy which tells where your processes will be placed.</p>
<p>**Binding* is locking your MPI processes/threads to a specific
resource which prevents from moving it around from one to another.</p>
</div>
</section><section><h2 class="section-heading" id="mapping-vs--binding-analogy">Mapping vs. Binding Analogy<a class="anchor" aria-label="anchor" href="#mapping-vs--binding-analogy"></a>
</h2>
<hr class="half-width">
<p>Think of running MPI processes and threads like booking seats for a
group of friends:</p>
<ul>
<li>
<strong>Mapping</strong> is like planning where your group will sit
in the theatre or on a flight.
<ul>
<li>Example: You decide some friends sit in Economy, some in Premium
Economy, and some in Business.<br>
</li>
<li>Similarly, <code>--map-by</code> distributes MPI ranks across nodes,
sockets, or NUMA regions.</li>
</ul>
</li>
<li>
<strong>Binding</strong> is like reserving the exact seats for each
friend in the planned area.
<ul>
<li>Example: Once the seating area is chosen, you assign specific seat
numbers to each friend.<br>
</li>
<li>Similarly, <code>--bind-to</code> pins each MPI process or thread to
a specific core or hardware unit to avoid movement.</li>
</ul>
</li>
</ul>
<p>This analogy helps illustrate why <strong>mapping defines
placement</strong> and <strong>binding enforces it</strong>.</p>
<p>We will use <code>--bind-to core</code> (the smallest hardware unit)
and <code>--map-by</code> to distribute MPI processes across sockets or
NUMA or node regions efficiently.</p>
<div class="section level3">
<h3 id="choosing-the-smallest-hardware-unit">Choosing the Smallest Hardware Unit<a class="anchor" aria-label="anchor" href="#choosing-the-smallest-hardware-unit"></a>
</h3>
<p>Binding processes to the smallest unit (core) is recommended
because:</p>
<ol style="list-style-type: decimal">
<li><p><strong>Exclusive use of resources</strong><br>
Each process or thread is pinned to its own core, preventing multiple
threads or processes from competing for the same CPU.</p></li>
<li><p><strong>Predictable performance</strong><br>
When processes share cores, execution times can fluctuate due to
scheduling conflicts. Binding to cores ensures consistent timing across
runs.</p></li>
</ol>
<ul>
<li>Best practice: Always bind processes to the smallest unit (core) and
spread processes evenly across the available hardware using
<code>--map-by</code>.</li>
<li>Example options:
<ul>
<li>
<code>--bind-to core</code> → binds each process to a dedicated core
(avoids oversubscription).<br>
</li>
<li>
<code>--map-by socket:PE=&lt;threads&gt;</code> → spreads given
number of threads as a processing element across the socket</li>
<li>
<code>--map-by numa:PE=&lt;threads&gt;</code> → spreads processes
across NUMA domains, assigning <code>&lt;threads&gt;</code> cores per
process.</li>
<li>similarly <code>--map-by numa:PE=&lt;threads&gt;</code>
</li>
<li>
<code>--cpus-per-rank &lt;n&gt;</code>→ Assigns
<code>&lt;n&gt;</code> cores (hardware threads) to each MPI rank -
ensuring that all threads within a rank occupy separate cores.</li>
</ul>
</li>
</ul>
<div id="exercise-3" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<span class="callout-header">Challenge</span>
<div id="exercise-3" class="callout-inner">
<h3 class="callout-title">Exercise</h3>
<div class="callout-content">
<p>Use the given best practices above for case 1: <code>-n 8</code>,
<code>-threads=1</code> and case 2: <code>-n 8</code>,
<code>-threads=4</code> and answer following questions</p>
<p>Questions: - How many cores does the both jobs use? - Did you get
more workers than you requested? - Did you see the scaling when running
with 4 threads?</p>
</div>
</div>
</div>
<div id="accordionSolution4" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution4" aria-expanded="false" aria-controls="collapseSolution4">
  <h4 class="accordion-header" id="headingSolution4"> Show me the solution </h4>
</button>
<div id="collapseSolution4" class="accordion-collapse collapse" data-bs-parent="#accordionSolution4" aria-labelledby="headingSolution4">
<div class="accordion-body">
<ul>
<li>8 and 32</li>
<li>No.</li>
<li>Yes</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</section><section><h2 class="section-heading" id="summary">Summary<a class="anchor" aria-label="anchor" href="#summary"></a>
</h2>
<hr class="half-width">
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<span class="callout-header">Key Points</span>
<div class="callout-inner">
<div class="callout-content">
<ul>
<li><p><strong>Always check how pinning works</strong><br>
Use verbose reporting (e.g., <code>--report-bindings</code>) to see how
MPI processes and threads are mapped to cores and sockets.</p></li>
<li><p><strong>Documentation is your friend</strong><br>
For OpenMPI with <code>mpirun</code>, consult the manual: <a href="https://www.open-mpi.org/doc/v4.1/man1/mpirun.1.php" class="external-link">https://www.open-mpi.org/doc/v4.1/man1/mpirun.1.php</a></p></li>
<li><p><strong>Know your hardware</strong><br>
Understanding the number of sockets, cores per socket, and NUMA regions
on your cluster helps you make effective binding decisions.</p></li>
<li><p><strong>Avoid oversubscription</strong><br>
Assigning more threads or processes than available cores hurts
performance — it causes contention and idle waits.</p></li>
<li><p><strong>Recommended practice for OpenMPI</strong><br>
Use <code>--bind-to core</code> along with <code>--map-by</code> to
control placement and threads per process to maximize
throughput.</p></li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</section></section><section id="aio-07_bottlenecks"><p>Content from <a href="07_bottlenecks.html">How to identify a bottleneck?</a></p>
<hr>
<p>Last updated on 2025-09-24 |

        <a href="https://github.com/stderr-enst/jobefficiency/edit/main/episodes/07_bottlenecks.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 10 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>How can I find the bottlenecks in a given job?</li>
<li>What are common workflows to evaluate performance?</li>
<li>What are some common types of bottlenecks?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<p>After completing this episode, participants should be able to …</p>
<ul>
<li>Choose between multiple workflows to evaluate job performance.</li>
<li>Name typical performance issues.</li>
<li>Determine if their job is affected by one of these issues.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="accordionInstructor1" class="accordion instructor-note accordion-flush">
<div class="accordion-item">
<button class="accordion-button instructor-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseInstructor1" aria-expanded="false" aria-controls="collapseInstructor1">
  <h3 class="accordion-header" id="headingInstructor1">
  <div class="note-square"><i aria-hidden="true" class="callout-icon" data-feather="edit-2"></i></div>
  Intention: Uncover one or two issues in the application
  </h3>
</button>
<div id="collapseInstructor1" class="accordion-collapse collapse" aria-labelledby="headingInstructor1" data-bs-parent="#accordionInstructor1">
<div class="accordion-body">
<p>Narrative:</p>
<ul>
<li>Okay, what’s slowest with creating snowman pictures?</li>
<li>Where does our system choke?</li>
</ul>
<p>What we’re doing here:</p>
<ul>
<li>What’s a bottleneck?</li>
<li>How can we identify a bottleneck?</li>
<li>“Online” and “after the fact” workflows of performance measurements
(trace, accumulated results, attached to the process (live), or after it
ran)</li>
<li>Point to additional resources of common performance/bottleneck
issues, e.g. on hpc-wiki</li>
</ul>
<p>Maybe something like this already occurred before in 4. Scaling
Study, or 5. Performance Overview</p>
</div>
</div>
</div>
</div>
<section><h2 class="section-heading" id="how-to-identify-a-bottleneck">How to identify a bottleneck?<a class="anchor" aria-label="anchor" href="#how-to-identify-a-bottleneck"></a>
</h2>
<hr class="half-width">
<!-- EPISODE CONTENT HERE --></section><section><h2 class="section-heading" id="summary">Summary<a class="anchor" aria-label="anchor" href="#summary"></a>
</h2>
<hr class="half-width">
<p>Leading question: We were looking at a standard configuration with
CPU, Memory, Disks, Network, so far. What about GPU applications, which
are very common these days?</p>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<span class="callout-header">Key Points</span>
<div class="callout-inner">
<div class="callout-content">
<ul>
<li>General advice on the workflow</li>
<li>Performance reports may provide an automated summary with
recommendations</li>
<li>Performance metrics can be categorized by the underlying hardware,
e.g. CPU, memory, I/O, accelerators.</li>
<li>Bottlenecks can appear by metrics being saturated at the physical
limits of the hardware or indirectly by other metrics being far from
what the physical limits are.</li>
<li>Interpreting bottlenecks is closely related to what the application
is supposed to do.</li>
<li>Relative measurements (baseline vs. change)
<ul>
<li>system is quiescent, fixed CPU freq + affinity, warmups, …</li>
<li>Reproducibility -&gt; link to git course?</li>
</ul>
</li>
<li>Scanning results for smoking guns</li>
<li>Any best practices etc.</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</section></section><section id="aio-08_accelerators"><p>Content from <a href="08_accelerators.html">Performance of Accelerators</a></p>
<hr>
<p>Last updated on 2025-09-24 |

        <a href="https://github.com/stderr-enst/jobefficiency/edit/main/episodes/08_accelerators.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 10 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>What are accelerators?</li>
<li>How do they affect my jobs performance?</li>
<li>How can I measure accelerator utilization?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<p>After completing this episode, participants should be able to …</p>
<ul>
<li>Understand difference of performance measurements on accelerators
(GPUs, FPGAs) to CPUs.</li>
<li>Understand how batch systems and performance measurements tools
treat accelerators.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="accordionInstructor1" class="accordion instructor-note accordion-flush">
<div class="accordion-item">
<button class="accordion-button instructor-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseInstructor1" aria-expanded="false" aria-controls="collapseInstructor1">
  <h3 class="accordion-header" id="headingInstructor1">
  <div class="note-square"><i aria-hidden="true" class="callout-icon" data-feather="edit-2"></i></div>
  Intention: Jump onto accelerator with the example application
  </h3>
</button>
<div id="collapseInstructor1" class="accordion-collapse collapse" data-bs-parent="#accordionInstructor1" aria-labelledby="headingInstructor1">
<div class="accordion-body">
<p>Narrative:</p>
<ul>
<li>The deadline is creeping up, only few ways to go!</li>
<li>Hey, we have a GPU partition! Maybe this will help us speed up the
process!</li>
</ul>
<p>What we’re doing here:</p>
<ul>
<li>What changes?</li>
<li>New metrics</li>
<li>Transfer to/from accelerator</li>
<li>Different options/requirements to scheduler &amp; performance
measurement tools</li>
</ul>
</div>
</div>
</div>
</div>
<section><h2 class="section-heading" id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<hr class="half-width">
<p>Run the same example workload on GPU and compare.</p>
<div id="accordionInstructor2" class="accordion instructor-note accordion-flush">
<div class="accordion-item">
<button class="accordion-button instructor-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseInstructor2" aria-expanded="false" aria-controls="collapseInstructor2">
  <h3 class="accordion-header" id="headingInstructor2">
  <div class="note-square"><i aria-hidden="true" class="callout-icon" data-feather="edit-2"></i></div>
  ToDo
  </h3>
</button>
<div id="collapseInstructor2" class="accordion-collapse collapse" data-bs-parent="#accordionInstructor2" aria-labelledby="headingInstructor2">
<div class="accordion-body">
<p>Don’t mention FPGAs too much, maybe just a node what accelerators
could be, besides GPU. Goal is to keep it simple and accessible, focus
on what’s common in most HPC systems these days</p>
</div>
</div>
</div>
</div>
<div id="accordionInstructor3" class="accordion instructor-note accordion-flush">
<div class="accordion-item">
<button class="accordion-button instructor-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseInstructor3" aria-expanded="false" aria-controls="collapseInstructor3">
  <h3 class="accordion-header" id="headingInstructor3">
  <div class="note-square"><i aria-hidden="true" class="callout-icon" data-feather="edit-2"></i></div>
  ToDo
  </h3>
</button>
<div id="collapseInstructor3" class="accordion-collapse collapse" data-bs-parent="#accordionInstructor3" aria-labelledby="headingInstructor3">
<div class="accordion-body">
<p>Explain how to decide where to run something. CPU vs. small GPU
vs. high-end GPUs. Touches on transfer overhead etc.</p>
</div>
</div>
</div>
</div>
<!-- EPISODE CONTENT HERE -->
</section><section><h2 class="section-heading" id="summary">Summary<a class="anchor" aria-label="anchor" href="#summary"></a>
</h2>
<hr class="half-width">
<p>Leading question: Performance optimization is a deep topic and we are
not done learning. How could I continue exploring the topic?</p>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<span class="callout-header">Key Points</span>
<div class="callout-inner">
<div class="callout-content">
<ul>
<li>Tools to measure GPU/FPGA performance of a job</li>
<li>Common symptoms of GPU/FPGA problems</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</section></section><section id="aio-09_nextsteps"><p>Content from <a href="09_nextsteps.html">Next Steps</a></p>
<hr>
<p>Last updated on 2025-10-29 |

        <a href="https://github.com/stderr-enst/jobefficiency/edit/main/episodes/09_nextsteps.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 10 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>What are other patterns of performance bottlenecks?</li>
<li>How to evaluate an application in more detail?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<p>After completing this episode, participants should be able to …</p>
<ul>
<li>Find collection of performance patterns on hpc-wiki.info</li>
<li>Identify next steps to take with regard to performance
optimization.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="accordionInstructor1" class="accordion instructor-note accordion-flush">
<div class="accordion-item">
<button class="accordion-button instructor-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseInstructor1" aria-expanded="false" aria-controls="collapseInstructor1">
  <h3 class="accordion-header" id="headingInstructor1">
  <div class="note-square"><i aria-hidden="true" class="callout-icon" data-feather="edit-2"></i></div>
  Intention: Provide a roadmap learners could follow
  </h3>
</button>
<div id="collapseInstructor1" class="accordion-collapse collapse" aria-labelledby="headingInstructor1" data-bs-parent="#accordionInstructor1">
<div class="accordion-body">
<p><strong>Most important:</strong> enable users to translate from
example workload to their own code! Guide on how to translate learning
goals and key points to their situation. Additionally, provide some info
on where and how to dig deeper, if there is interest (application
profiling, etc.)</p>
<p>All ideas in this episode may need to be reworked, since they were
made with the outlook in mind, not so much to help learners transfer
insight</p>
<p>Narrative:</p>
<ul>
<li>Start with picture of beautiful title slide of the talk with the
snowman picture</li>
<li>Next time we want to tackle the issue way in advance</li>
<li>Approach our raytracing application more systematically, such that
we can get the title slide done much quicker</li>
<li>What could we do to dive deeper in optimizing the raytracer?</li>
<li>Where can we go from here?</li>
</ul>
<p>What we’re doing here:</p>
<ul>
<li>Learning important programming concepts (parallel programming on
many levels)</li>
<li>Deeper application profiling &amp; tools to use</li>
</ul>
</div>
</div>
</div>
</div>
<section><h2 class="section-heading" id="next-steps">Next Steps<a class="anchor" aria-label="anchor" href="#next-steps"></a>
</h2>
<hr class="half-width">
<p>hpc-wiki.info - I/O - CPU Front End - CPU Back End - Memory leak -
Oversubscription - Underutilization</p>
<!-- EPISODE CONTENT HERE -->
</section><section><h2 class="section-heading" id="summary">Summary<a class="anchor" aria-label="anchor" href="#summary"></a>
</h2>
<hr class="half-width">
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<span class="callout-header">Key Points</span>
<div class="callout-inner">
<div class="callout-content">
<ul>
<li>There are many profilers, some are language-specific, others are
vendor-related, …</li>
<li>Simple profile with exclusive resources</li>
<li>Repeated measurements for reliability</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</section></section>
</div>
    </main>
</div>
<!-- END  : inst/pkgdown/templates/content-extra.html -->

      </div>
<!--/div.row-->
      		<footer class="row footer mx-md-3"><hr>
<div class="col-md-6">
        <p>This lesson is subject to the <a href="CODE_OF_CONDUCT.html">Code of Conduct</a></p>
        <p>

        <a href="https://github.com/stderr-enst/jobefficiency/edit/main/README.md" class="external-link">Edit on GitHub</a>

	
        | <a href="https://github.com/stderr-enst/jobefficiency/blob/main/CONTRIBUTING.md" class="external-link">Contributing</a>
        | <a href="https://github.com/stderr-enst/jobefficiency/" class="external-link">Source</a></p>
        <p>
        <a href="../citation.html">Cite</a>
        | <a href="mailto:helpdesk@hpc.nrw">Contact</a> | <a href="https://carpentries.org/about/" class="external-link">About</a></p>
		</div>
		<div class="col-md-6">

        <p>Materials licensed under <a href="LICENSE.html">CC-BY 4.0</a> by the authors</p>

        <p>Template licensed under <a href="https://creativecommons.org/licenses/by-sa/4.0/" class="external-link">CC-BY 4.0</a> by <a href="https://carpentries.org/" class="external-link">The Carpentries</a></p>
        <p>Built with <a href="https://github.com/carpentries/sandpaper/tree/0.17.3" class="external-link">sandpaper (0.17.3)</a>, <a href="https://github.com/carpentries/pegboard/tree/0.7.9" class="external-link">pegboard (0.7.9)</a>, and <a href="https://github.com/carpentries/varnish/tree/1.0.9" class="external-link">varnish (1.0.9)</a></p>
		</div>
		</footer>
</div> <!-- / div.container -->
	<div id="to-top">
		<a href="#top">
      <i class="search-icon" data-feather="arrow-up" role="img" aria-label="Back To Top"></i><br><!-- <span class="d-none d-sm-none d-md-none d-lg-none d-xl-block">Back</span> To Top --><span class="d-none d-sm-none d-md-none d-lg-none d-xl-block">Back</span> To Top
		</a>
	</div>
  <script type="application/ld+json">
    {
  "@context": "https://schema.org",
  "@type": "LearningResource",
  "@id": "https://stderr-enst.github.io/jobefficiency/instructor/aio.html",
  "inLanguage": "en",
  "dct:conformsTo": "https://bioschemas.org/profiles/LearningResource/1.0-RELEASE",
  "description": "A Carpentries Lesson teaching foundational data and coding skills to researchers worldwide",
  "keywords": "hpc, software, data, lesson, The Carpentries",
  "name": "All in One View",
  "creativeWorkStatus": "active",
  "url": "https://stderr-enst.github.io/jobefficiency/instructor/aio.html",
  "identifier": "https://stderr-enst.github.io/jobefficiency/instructor/aio.html",
  "dateCreated": "2025-03-28",
  "dateModified": "2026-01-06",
  "datePublished": "2026-01-06"
}

  </script><script>
		feather.replace();
	</script>
</body>
</html><!-- END:   inst/pkgdown/templates/layout.html-->

